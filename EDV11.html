<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Echo Dungeon V10.5 Fixed</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #111;
        }
        #micButton {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: #222;
            border: none;
            cursor: pointer;
            transition: background 0.3s;
        }
        #micButton:active {
            background: #444;
        }
        .listening {
            background: #004400 !important;
        }
        .start-button {
            background: #000044 !important;
        }
        #textDisplay {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border: 0;
        }
    </style>
</head>
<body>
    <div id="textDisplay" role="status" aria-live="polite"></div>
    <button id="micButton" class="start-button" onclick="handleClick()" aria-label="Voice command button - Tap to speak"></button>

    <script>
        const micButton = document.getElementById('micButton');
        const textDisplay = document.getElementById('textDisplay');

        function displayText(text) {
            textDisplay.innerHTML = text;
        }

        let browserSupport = {
            speechSynthesis: false,
            speechRecognition: false,
            https: false
        };

        function checkBrowserSupport() {
            browserSupport.https = window.location.protocol === 'https:' || window.location.hostname === 'localhost';
            browserSupport.speechSynthesis = !!(window.speechSynthesis && window.SpeechSynthesisUtterance);
            browserSupport.speechRecognition = !!(window.webkitSpeechRecognition || window.SpeechRecognition);
        }

        const game = {
            player: {
                class: '',
                level: 1,
                experience: 0,
                experienceToNext: 100,
                health: 100,
                maxHealth: 100,
                mana: 50,
                maxMana: 50,
                gold: 25,
                inventory: [],
                equippedRings: [],
                learnedAbilities: [],
                equippedAmulet: '',
                position: { x: 6, y: 6 },
                baseAttack: 15,
                defense: 0,
                weapon: '',
                armor: '',
                shield: '',
                helmet: '',
                gloves: '',
                boots: '',
                leftBracelet: '',
                rightBracelet: '',
                specialItems: [],
                activeEffects: [],
                junkBag: []
            },
            dungeon: {
                grid: {},
                size: 12,
                secretRoom: null,
                hasSecretRoom: false,
                currentLevel: 1 
            },
            currentRoom: null,
            combat: null,
            listening: false,
            started: false,
            needsClass: true,
            initialized: false,
            phase: 'init',
            merchantOpen: false,
            purchaseQuantity: 1
        };

        const classes = {
            warrior: {
                name: 'Warrior',
                health: 120,
                maxHealth: 120,
                mana: 30,
                maxMana: 30,
                gold: 50,
                items: ['Steel Sword', 'Health Potion', 'Health Potion', 'Chainmail', 'Iron Shield'],
                special: { name: 'Power Strike', damage: 100, cost: 15, type: 'damage' }
            },
            mage: { 
                name: 'Mage',
                health: 80,
                maxHealth: 80,
                mana: 100,
                maxMana: 100,
                gold: 75,
                items: ['Mystic Staff', 'Mana Potion', 'Health Potion', 'Enchanted Robes'],
                special: { name: 'Mana Shield', damage: 0, cost: 20, type: 'shield' }
            },
            rogue: {
                name: 'Rogue',
                health: 100,
                maxHealth: 100,
                mana: 60,
                maxMana: 60,
                gold: 100,
                items: ['Shadow Daggers', 'Lockpicks', 'Health Potion', 'Shadow Leather'],
                special: { name: 'Sneak Attack', damage: 75, cost: 15, type: 'sneak' }
            }
        };

        const equipment = {
            weapons: [
                { name: 'Steel Sword', attack: 12, class: 'warrior', value: 100 },
                { name: 'Mystic Staff', attack: 8, mana: 15, class: 'mage', value: 150 },
                { name: 'Shadow Daggers', attack: 10, class: 'rogue', value: 120 },
                { name: 'Legendary Greatsword', attack: 25, class: 'warrior', value: 300 },
                { name: 'Archmage Staff', attack: 12, mana: 25, class: 'mage', value: 350 },
                { name: 'Vorpal Daggers', attack: 16, class: 'rogue', value: 320 },
                { name: 'Demon Slayer Blade', attack: 40, class: 'warrior', value: 500 },
                { name: 'Staff of the Cosmos', attack: 15, mana: 35, class: 'mage', value: 600 },
                { name: 'Ethereal Blades', attack: 22, class: 'rogue', value: 550 },
                { name: 'Godslayer Greatsword', attack: 30, class: 'warrior', value: 1000, minLevel: 6 },
                { name: 'Staff of Eternity', attack: 20, mana: 45, class: 'mage', value: 1200, minLevel: 6 },
                { name: 'Nightfall Daggers', attack: 32, class: 'rogue', value: 1100, minLevel: 6 },
                { name: 'Excalibur', attack: 50, class: 'warrior', value: 2000, minLevel: 8 },
                { name: 'Infinity Staff', attack: 25, mana: 60, class: 'mage', value: 2500, minLevel: 8 },
                { name: 'Oblivion Blades', attack: 42, class: 'rogue', value: 2200, minLevel: 8 },
                { name: 'Sword of the Ancients', attack: 70, class: 'warrior', value: 5000, minLevel: 10 },
                { name: 'Cosmic Scepter', attack: 35, mana: 80, class: 'mage', value: 6000, minLevel: 10 },
                { name: 'Void Assassin Blades', attack: 60, class: 'rogue', value: 5500, minLevel: 10 },
                { name: 'Ragnarok', attack: 100, class: 'warrior', value: 10000, minLevel: 20 },
                { name: 'Genesis Staff', attack: 50, mana: 120, class: 'mage', value: 12000, minLevel: 20 },
                { name: 'Apocalypse Daggers', attack: 85, class: 'rogue', value: 11000, minLevel: 20 }
            ],
            armor: [
                { name: 'Chainmail', defense: 10, class: 'warrior', value: 100 },
                { name: 'Enchanted Robes', defense: 5, class: 'mage', value: 120 },
                { name: 'Shadow Leather', defense: 6, class: 'rogue', value: 110 },
                { name: 'Dragonscale Plate', defense: 15, class: 'warrior', value: 350 },
                { name: 'Arcane Vestments', defense: 12, class: 'mage', value: 380 },
                { name: 'Phantom Suit', defense: 13, class: 'rogue', value: 360 },
                { name: 'Titanium Fortress', defense: 27, class: 'warrior', value: 550 },
                { name: 'Celestial Robes', defense: 18, mana: 25, class: 'mage', value: 600 },
                { name: 'Void Cloak', defense: 20, class: 'rogue', value: 580 },
                { name: 'Divine Plate', defense: 35, class: 'warrior', value: 1200, minLevel: 6 },
                { name: 'Robes of the Archmage', defense: 28, class: 'mage', value: 1100, minLevel: 6 },
                { name: 'Shadowweave Armor', defense: 30, class: 'rogue', value: 1150, minLevel: 6 },
                { name: 'Immortal Armor', defense: 50, class: 'warrior', value: 3000, minLevel: 8 },
                { name: 'Vestments of Infinity', defense: 40, mana: 60, class: 'mage', value: 2800, minLevel: 8 },
                { name: 'Cloak of Eternity', defense: 45, class: 'rogue', value: 2900, minLevel: 8 },
                { name: 'Armor of the Titans', defense: 70, class: 'warrior', value: 6000, minLevel: 10 },
                { name: 'Cosmic Vestments', defense: 55, mana: 90, class: 'mage', value: 7000, minLevel: 10 },
                { name: 'Void Emperor Cloak', defense: 65, class: 'rogue', value: 6500, minLevel: 10 },
                { name: 'Armor of Ragnarok', defense: 100, class: 'warrior', value: 12000, minLevel: 20 },
                { name: 'Genesis Robes', defense: 80, mana: 150, class: 'mage', value: 14000, minLevel: 20 },
                { name: 'Apocalypse Suit', defense: 90, class: 'rogue', value: 13000, minLevel: 20 }
            ],
            shields: [
                { name: 'Iron Shield', defense: 5, class: 'warrior', value: 80 },
                { name: 'Tower Shield', defense: 10, class: 'warrior', value: 250 },
                { name: 'Aegis Shield', defense: 15, class: 'warrior', value: 450 },
                { name: 'Shield of Heroes', defense: 25, class: 'warrior', value: 800, minLevel: 6 },
                { name: 'Bulwark of Ages', defense: 35, class: 'warrior', value: 1500, minLevel: 8 },
                { name: 'Titan Shield', defense: 50, class: 'warrior', value: 4000, minLevel: 10 },
                { name: 'Shield of Ragnarok', defense: 75, class: 'warrior', value: 10000, minLevel: 20 }
            ],
            helmets: [
                { name: 'Iron Helm', defense: 3, class: 'warrior', value: 50 },
                { name: 'Mage Hood', mana: 50, class: 'mage', value: 60 },
                { name: 'Shadow Mask', mana: 30, class: 'rogue', value: 55 },
                { name: 'Crown of Kings', defense: 38, class: 'warrior', value: 300, minLevel: 5 },
                { name: 'Circlet of Wisdom', mana: 120, class: 'mage', value: 350, minLevel: 5 },
                { name: 'Assassin Hood', mana: 50, class: 'rogue', value: 320, minLevel: 5 },
                { name: 'Helm of the Ancients', defense: 55, class: 'warrior', value: 3000, minLevel: 10 },
                { name: 'Crown of Cosmic Power', mana: 200, class: 'mage', value: 3500, minLevel: 10 },
                { name: 'Void Assassin Mask', mana: 150, class: 'rogue', value: 3200, minLevel: 10 },
                { name: 'Helm of Ragnarok', defense: 80, class: 'warrior', value: 8000, minLevel: 20 },
                { name: 'Genesis Crown', mana: 300, class: 'mage', value: 9000, minLevel: 20 },
                { name: 'Apocalypse Hood', mana: 250, class: 'rogue', value: 8500, minLevel: 20 }
            ],
            gloves: [
                { name: 'Leather Gloves', attack: 12, value: 40 },
                { name: 'Gauntlets of Strength', attack: 55, class: 'warrior', value: 200, minLevel: 4 },
                { name: 'Gloves of Casting', mana: 80, class: 'mage', value: 220, minLevel: 4 },
                { name: 'Shadow Grips', attack: 14, health: 30, class: 'rogue', value: 210, minLevel: 4 },
                { name: 'Titan Gauntlets', attack: 80, class: 'warrior', value: 2500, minLevel: 10 },
                { name: 'Cosmic Gloves', mana: 180, class: 'mage', value: 3000, minLevel: 10 },
                { name: 'Void Grips', attack: 70, health: 100, class: 'rogue', value: 2800, minLevel: 10 },
                { name: 'Gauntlets of Ragnarok', attack: 120, class: 'warrior', value: 7000, minLevel: 20 },
                { name: 'Genesis Gloves', mana: 280, class: 'mage', value: 8000, minLevel: 20 },
                { name: 'Apocalypse Grips', attack: 110, health: 200, class: 'rogue', value: 7500, minLevel: 20 }
            ],
            boots: [
                { name: 'Iron Boots', defense: 12, value: 35 },
                { name: 'Boots of Speed', mana: 15, value: 150, minLevel: 3 },
                { name: 'Greaves of the Titan', defense: 38, class: 'warrior', value: 300, minLevel: 5 },
                { name: 'Slippers of Wisdom', mana: 70, class: 'mage', value: 280, minLevel: 5 },
                { name: 'Boots of Shadow', health: 25, class: 'rogue', value: 320, minLevel: 5 },
                { name: 'Ancient Greaves', defense: 60, class: 'warrior', value: 2800, minLevel: 10 },
                { name: 'Cosmic Slippers', mana: 170, class: 'mage', value: 3200, minLevel: 10 },
                { name: 'Void Treads', health: 120, class: 'rogue', value: 3000, minLevel: 10 },
                { name: 'Greaves of Ragnarok', defense: 90, class: 'warrior', value: 7500, minLevel: 20 },
                { name: 'Genesis Slippers', mana: 270, class: 'mage', value: 8500, minLevel: 20 },
                { name: 'Apocalypse Boots', health: 250, class: 'rogue', value: 8000, minLevel: 20 }
            ],
            bracelets: [
                { name: 'Bronze Bracelet', attack: 5, mana: 10, value: 100 },
                { name: 'Silver Bracelet', attack: 10, mana: 20, value: 300, minLevel: 3 },
                { name: 'Gold Bracelet', attack: 15, mana: 40, value: 800, minLevel: 5 },
                { name: 'Platinum Bracelet', attack: 25, mana: 70, value: 2000, minLevel: 8 },
                { name: 'Ancient Bracelet', attack: 40, mana: 120, value: 5000, minLevel: 10 },
                { name: 'Cosmic Bracelet', attack: 60, mana: 180, value: 10000, minLevel: 20 },
                { name: 'Bracelet of Ragnarok', attack: 90, mana: 250, value: 20000, minLevel: 30 }
            ]
        };

        const abilities = [
            { name: 'Icy Blast', damage: 100, cost: 20, type: 'freeze', description: 'Deals damage and freezes enemy for 1 turn', class: 'mage' },
            { name: 'Shield Bash', damage: 80, cost: 20, type: 'stun', description: 'Stun enemy for one turn', class: 'warrior' },
            { name: 'Poison Blade', damage: 40, cost: 20, type: 'poison', duration: 3, description: 'Poison damages 15 per turn for 3 turns', class: 'rogue' },
            { name: 'Chain Lightning', damage: 95, cost: 25, type: 'damage', description: 'Devastating lightning attack', class: 'mage' },
            { name: 'Arcane Missiles', damage: 105, cost: 15, type: 'aoe', description: 'Magic missiles hit all enemies', class: 'mage' },
            { name: 'Whirlwind', damage: 70, cost: 25, type: 'aoe', description: 'Spin attack hitting all enemies', class: 'warrior'},
            { name: 'Shadow Strike', damage: 40, cost: 20, type: 'sneak', description: 'Strike from shadows without enemy retaliation', class: 'rogue' },
            { name: 'Meteor Storm', damage: 145, cost: 40, type: 'aoe', description: 'Massive fire damage to all enemies', class: 'mage', minLevel: 5 },
            { name: 'Titan Smash', damage: 190, cost: 35, type: 'damage', description: 'Devastating single target attack', class: 'warrior', minLevel: 5 },
            { name: 'Assassinate', damage: 125, cost: 30, type: 'sneak', description: 'Massive stealth strike with no counter', class: 'rogue', minLevel: 5 },
            { name: 'Time Stop', damage: 0, cost: 60, type: 'timestop', description: 'Freeze all enemies for 2 turns', class: 'mage', minLevel: 6 },
            { name: 'Berserker Rage', damage: 105, cost: 30, type: 'rage', description: 'Triple attack on single target', class: 'warrior', minLevel: 6 },
            { name: 'Shadowmeld', damage: 0, cost: 25, type: 'vanish', description: 'Become invisible, next attack deals 200% damage', class: 'rogue', minLevel: 6 },
            { name: 'Divine Smite', damage: 200, cost: 60, type: 'damage', description: 'Holy damage that ignores defense', class: 'warrior', minLevel: 8 },
            { name: 'Black Hole', damage: 250, cost: 55, type: 'aoe', description: 'Void magic crushes all foes', class: 'mage', minLevel: 8 },
            { name: 'Death Mark', damage: 100, cost: 35, type: 'mark', description: 'Mark enemy for 50% more damage taken', class: 'rogue', minLevel: 8 },
            { name: 'Cosmic Devastation', damage: 300, cost: 100, type: 'aoe', description: 'Ultimate spell destroys all enemies', class: 'mage', minLevel: 10 },
            { name: 'Annihilation', damage: 400, cost: 70, type: 'damage', description: 'Total destruction single target', class: 'warrior', minLevel: 10 },
            { name: 'Soul Reaper', damage: 250, cost: 60, type: 'sneak', description: 'Harvest souls from the shadows', class: 'rogue', minLevel: 10 },
            { name: 'Ragnarok', damage: 600, cost: 120, type: 'aoe', description: 'End of all things', class: 'mage', minLevel: 20 },
            { name: 'Apocalypse Strike', damage: 800, cost: 100, type: 'damage', description: 'The final blow', class: 'warrior', minLevel: 20 },
            { name: 'Oblivion', damage: 500, cost: 90, type: 'sneak', description: 'Erase from existence', class: 'rogue', minLevel: 20 }
        ];
        const amulets = [
            { name: 'Amulet of Vitality', effect: '+15 Max Health', stat: 'maxHealth', value: 15 },
            { name: 'Amulet of Mana', effect: '+15 Max Mana', stat: 'maxMana', value: 15 },
            { name: 'Amulet of Experience', effect: '+20% Experience Gain', stat: 'expGain', value: 30 },
            { name: 'Amulet of the Archmage', effect: '+30 Max Mana', stat: 'maxMana', value: 30 },
            { name: 'Amulet of the Titan', effect: '+30 Max Health', stat: 'maxHealth', value: 30 },
            { name: 'Amulet of Power', effect: '+5 Attack', stat: 'attack', value: 5 },
            { name: 'Ancient Amulet', effect: '+60 Max Health', stat: 'maxHealth', value: 60, minLevel: 10 },
            { name: 'Cosmic Amulet', effect: '+100 Max Mana', stat: 'maxMana', value: 100, minLevel: 10 },
            { name: 'Amulet of Destruction', effect: '+20 Attack', stat: 'attack', value: 20, minLevel: 10 },
            { name: 'Ragnarok Amulet', effect: '+150 Max Health', stat: 'maxHealth', value: 150, minLevel: 20 },
            { name: 'Genesis Amulet', effect: '+200 Max Mana', stat: 'maxMana', value: 200, minLevel: 20 },
            { name: 'Apocalypse Amulet', effect: '+50 Attack', stat: 'attack', value: 50, minLevel: 20 }
        ];

        const treasures = [
            { name: 'Sapphire Gem', value: 50 },
            { name: 'Ruby Gem', value: 75 },
            { name: 'Diamond', value: 100 },
            { name: 'Emerald', value: 60 },
            { name: 'Ancient Coin Collection', value: 40 },
            { name: 'Golden Chalice', value: 80 },
            { name: 'Silver Crown', value: 90 },
            { name: 'Enchanted Amulet', value: 120 }
        ];

        const rings = [
            { name: 'Ring of Vitality', effect: '+10 Max Health', stat: 'maxHealth', value: 10 },
            { name: 'Ring of Minor Mana', effect: '+40 Max Mana', stat: 'maxMana', value: 10 },
            { name: 'Ring of Protection', effect: '+50 Max Health', stat: 'maxHealth', value: 5 },
            { name: 'Ring of Strength', effect: '+4 Attack Damage', stat: 'attack', value: 2 },
            { name: 'Ring of Wisdom', effect: '+8 Max Mana', stat: 'maxMana', value: 5 },
            { name: 'Ring of the Titan', effect: '+20 Max Health', stat: 'maxHealth', value: 20 },
            { name: 'Ring of Arcane Power', effect: '+15 Max Mana', stat: 'maxMana', value: 15 },
            { name: 'Ring of the Berserker', effect: '+6 Attack Damage', stat: 'attack', value: 4 },
            { name: 'Ancient Ring', effect: '+50 Max Health', stat: 'maxHealth', value: 50, minLevel: 10 },
            { name: 'Cosmic Ring', effect: '+80 Max Mana', stat: 'maxMana', value: 80, minLevel: 10 },
            { name: 'Ring of Devastation', effect: '+15 Attack Damage', stat: 'attack', value: 15, minLevel: 10 },
            { name: 'Ragnarok Ring', effect: '+120 Max Health', stat: 'maxHealth', value: 120, minLevel: 20 },
            { name: 'Genesis Ring', effect: '+150 Max Mana', stat: 'maxMana', value: 150, minLevel: 20 },
            { name: 'Apocalypse Ring', effect: '+30 Attack Damage', stat: 'attack', value: 30, minLevel: 20 }
        ];

        const enemies = {
            goblin: { name: 'Goblin', health: 130, damage: 18, gold: 5, exp: 25, fleeChance: 0.8 },
            skeleton: { name: 'Skeleton', health: 140, damage: 20, gold: 8, exp: 30, fleeChance: 0.7 },
            orc: { name: 'Orc', health: 160, damage: 35, gold: 12, exp: 50, fleeChance: 0.5 },
            wraith: { name: 'Wraith', health: 150, damage: 38, gold: 15, exp: 75, fleeChance: 0.6 },
            troll: { name: 'Troll', health: 180, damage: 50, gold: 20, exp: 65, fleeChance: 0.4, regenerate: 5 },
            dragon: { name: 'Dragon', health: 350, damage: 75, gold: 50, exp: 450, fleeChance: 0.1 },
            demon: { name: 'Demon', health: 190, damage: 58, gold: 45, exp: 80, fleeChance: 0.3 },
            vampire: { name: 'Vampire', health: 200, damage: 95, gold: 40, exp: 100, fleeChance: 0.4, regenerate: 8 },
            orcChieftain: { name: 'Orc Chieftain', health: 190, damage: 72, gold: 25, exp: 65, fleeChance: 0.3 },
            ancientWraith: { name: 'Ancient Wraith', health: 190, damage: 96, gold: 30, exp: 80, fleeChance: 0.4 },
            elderTroll: { name: 'Elder Troll', health: 250, damage: 28, gold: 40, exp: 100, fleeChance: 0.2, regenerate: 10 },
            archDemon: { name: 'Arch Demon', health: 280, damage: 95, gold: 70, exp: 160, fleeChance: 0.2 },
            hydra: { name: 'Hydra', health: 240, damage: 130, gold: 55, exp: 125, fleeChance: 0.3, regenerate: 12 },
            phoenixGuardian: { name: 'Phoenix Guardian', health: 230, damage: 132, gold: 60, exp: 145, fleeChance: 0.3, regenerate: 15 },
            lichKing: { name: 'Lich King', health: 160, damage: 38, gold: 80, exp: 185, fleeChance: 0.1, regenerate: 10 },
            ancientDragon: { name: 'Ancient Dragon', health: 600, damage: 150, gold: 200, exp: 800, fleeChance: 0.05, regenerate: 20 },
            demonLord: { name: 'Demon Lord', health: 550, damage: 180, gold: 250, exp: 900, fleeChance: 0.05, regenerate: 25 },
            voidBeast: { name: 'Void Beast', health: 700, damage: 200, gold: 300, exp: 1000, fleeChance: 0.03, regenerate: 30 },
            cosmicHorror: { name: 'Cosmic Horror', health: 800, damage: 220, gold: 350, exp: 1200, fleeChance: 0.03, regenerate: 35 },
            titanLord: { name: 'Titan Lord', health: 1000, damage: 250, gold: 400, exp: 1500, fleeChance: 0.02, regenerate: 40 },
            harbingerOfRagnarok: { name: 'Harbinger of Ragnarok', health: 1500, damage: 300, gold: 600, exp: 2500, fleeChance: 0.01, regenerate: 50 },
            voidEmperor: { name: 'Void Emperor', health: 2000, damage: 350, gold: 800, exp: 3500, fleeChance: 0.01, regenerate: 60 },
            apocalypseTitan: { name: 'Apocalypse Titan', health: 2500, damage: 400, gold: 1000, exp: 5000, fleeChance: 0.01, regenerate: 75 }
        };

        const merchantItems = [
            { name: 'Health Potion', type: 'potion', price: 50 },
            { name: 'Mana Potion', type: 'potion', price: 40 },
            { name: 'Greater Health Potion', type: 'potion', price: 100, healing: 150 },
            { name: 'Greater Mana Potion', type: 'potion', price: 80, mana: 100 },
            { name: 'Supreme Health Potion', type: 'potion', price: 300, healing: 300, minLevel: 10 },
            { name: 'Supreme Mana Potion', type: 'potion', price: 250, mana: 200, minLevel: 10 },
            { name: 'Ultimate Health Potion', type: 'potion', price: 800, healing: 800, minLevel: 20 },
            { name: 'Ultimate Mana Potion', type: 'potion', price: 700, mana: 500, minLevel: 20 },
            { name: 'Elixir of Immortality', type: 'special_potion', price: 400, effect: 'revive', description: 'Auto-revive on death with 50% health' },
            { name: 'Potion of Giant Strength', type: 'special_potion', price: 300, effect: 'strength', duration: 3, description: 'Double attack damage for 3 battles' },
            { name: 'Elixir of Clarity', type: 'special_potion', price: 350, effect: 'clarity', description: 'All spells cost 50% less mana for 3 battles' },
            { name: "Merchant's Lucky Coin", type: 'special_item', price: 500, effect: '+50% gold from all sources', stat: 'goldBonus', value: 0.5 },
            { name: 'Crystal of Experience', type: 'special_item', price: 600, effect: '+100% experience gain', stat: 'expBonus', value: 1.0 },
            { name: 'Ring of Regeneration', type: 'special_ring', price: 400, effect: 'Restore 50 health per turn in combat', stat: 'regen', value: 50 },
            { name: 'Amulet of the Arcane Master', type: 'special_amulet', price: 700, effect: '+50 Max Mana and +10 spell damage', stat: 'arcane', manaValue: 50, damageValue: 10 },
            
            { name: 'Legendary Warhammer', type: 'weapon', price: 3500, attack: 65, class: 'warrior', description: 'Crushes all opposition' },
            { name: 'Staff of Ultimate Power', type: 'weapon', price: 4000, attack: 40, mana: 100, class: 'mage', description: 'Limitless arcane potential' },
            { name: 'Blades of the Phantom King', type: 'weapon', price: 3800, attack: 55, class: 'rogue', description: 'Strike from any shadow' },
            
            { name: 'Fortress Armor', type: 'armor', price: 4500, defense: 80, class: 'warrior', description: 'Impenetrable defense' },
            { name: 'Robes of Ultimate Magic', type: 'armor', price: 5000, defense: 60, mana: 120, class: 'mage', description: 'Channel infinite power' },
            { name: 'Suit of the Shadow Emperor', type: 'armor', price: 4800, defense: 70, class: 'rogue', description: 'One with darkness' },
            
            { name: 'Shield of the Immortal', type: 'shield', price: 5500, defense: 90, class: 'warrior', description: 'Nothing can harm you', minLevel: 10 },
            
            { name: 'Crown of Absolute Power', type: 'helmet', price: 6000, defense: 100, mana: 150, description: 'Ultimate authority', minLevel: 10 },
            
            { name: 'Gauntlets of the God Slayer', type: 'gloves', price: 5500, attack: 100, mana: 100, description: 'Destroy the divine', minLevel: 10 },
            
            { name: 'Boots of Infinity', type: 'boots', price: 5000, defense: 80, mana: 120, health: 150, description: 'Walk forever', minLevel: 10 },
            
            { name: 'Bracelet of the Cosmos', type: 'bracelet', price: 8000, attack: 80, mana: 200, description: 'Harness cosmic power', minLevel: 10 },
            { name: 'Bracelet of Annihilation', type: 'bracelet', price: 15000, attack: 150, mana: 350, description: 'Destroy all creation', minLevel: 20 }
        ];

        const roomTypes = {
            entrance: { 
                descriptions: [
                    'the grand entrance hall. Torches flicker on ancient stone walls.',
                    'the entrance chamber. A faded tapestry hangs on the north wall.',
                    'the starting hall. Cobwebs drape from vaulted ceilings above.'
                ], 
                hasEnemy: false 
            },
            empty: { 
                descriptions: [
                    'an abandoned barracks. Rusty weapons litter the floor.',
                    'a collapsed library. Torn pages scatter at your feet.',
                    'a crumbling shrine. A broken altar stands in the center.',
                    'a forgotten armory. Empty weapon racks line the walls.',
                    'a dusty workshop. Ancient tools hang from hooks.',
                    'a meditation chamber. Stone benches circle a dry fountain.',
                    'an old prison cell. Iron bars have rusted through.',
                    'a guard post. A skeleton sits slumped in a chair.'
                ], 
                hasEnemy: false 
            },
            treasure: { 
                descriptions: [
                    'a glittering treasure vault. Gold coins reflect torchlight.',
                    'a dragon\'s hoard chamber. Piles of jewels gleam in the darkness.',
                    'a royal treasury. Ancient chests overflow with riches.',
                    'a pirate\'s cache. Stolen goods fill every corner.',
                    'a wizard\'s vault. Magical artifacts pulse with energy.'
                ], 
                hasEnemy: false 
            },
            enemy: { 
                descriptions: [
                    'a dark chamber. You sense hostile eyes watching you.',
                    'a blood-stained arena. Old battle scars mark the floor.',
                    'a shadowy lair. Something growls in the darkness.',
                    'a monster\'s den. Bones crunch beneath your feet.',
                    'a cursed chamber. An evil presence fills the air.'
                ], 
                hasEnemy: true 
            },
            boss: { 
                descriptions: [
                    'the throne room of darkness. A massive beast awaits on a stone throne.',
                    'the dragon\'s lair. Heat radiates from the enormous creature before you.',
                    'the demon king\'s chamber. Dark energy swirls around your foe.'
                ], 
                hasEnemy: true 
            },
            trap: { 
                descriptions: [
                    'a trapped corridor. Pressure plates cover the floor.',
                    'a spike-filled chamber. Deadly traps line the walls.',
                    'a poison gas room. Strange vapors seep from cracks.'
                ], 
                hasEnemy: false 
            },
            stairs: { 
                descriptions: [
                    'a spiral stairwell. Dark stone steps descend into deeper darkness.',
                    'a grand staircase. Ancient carvings decorate the descent.',
                    'a hidden passage. Secret stairs lead to the next level.'
                ], 
                hasEnemy: false 
            },
            fountain: {
                descriptions: [
                    'a magical fountain room. Crystal clear water bubbles from an enchanted spring.',
                    'an ancient healing shrine. A mystical fountain glows with restorative power.'
                ],
                hasEnemy: false
            },
            crypt: {
                descriptions: [
                    'a dusty crypt. Stone sarcophagi line the walls.',
                    'an ancient burial chamber. Skeletal remains rest in alcoves.',
                    'a forgotten tomb. Hieroglyphs cover every surface.'
                ],
                hasEnemy: false
            },
            merchant: {
                descriptions: [
                    'a merchant\'s tent. A hooded figure tends to various wares.',
                    'a traveling shop. Mysterious goods line makeshift shelves.'
                ],
                hasEnemy: false
            }
        };

        function speak(text, callback) {
            displayText(text);
            if (!browserSupport.speechSynthesis) {
                if (callback) setTimeout(callback, 2000);
                return;
            }
            try {
                speechSynthesis.cancel();
                setTimeout(() => {
                    const utterance = new SpeechSynthesisUtterance(text.replace(/<[^>]*>/g, ''));
                    utterance.rate = 0.9;
                    if (callback) {
                        utterance.onend = callback;
                        utterance.onerror = callback;
                    }
                    speechSynthesis.speak(utterance);
                }, 100);
            } catch (error) {
                if (callback) setTimeout(callback,2000);
            }
        }

        function speakSequence(messages, callback) {
            if (messages.length === 0) {
                if (callback) callback();
                return;
            }
            const [first, ...rest] = messages;
            speak(first, () => {
                if (rest.length > 0) {
                    setTimeout(() => speakSequence(rest, callback), 500);
                } else if (callback) {
                    callback();
                }
            });
        }

        let recognition = null;

        function startListening() {
            if (!browserSupport.speechRecognition || !browserSupport.https) {
                speak('Voice recognition requires HTTPS and a compatible browser like Chrome or Edge.');
                return;
            }
            if (game.listening) { stopListening(); return; }
            try {
                const Recognition = window.webkitSpeechRecognition || window.SpeechRecognition;
                recognition = new Recognition();
                recognition.continuous = false;
                recognition.lang = 'en-US';
                recognition.onstart = () => {
                    game.listening = true;
                    micButton.classList.add('listening');
                };
                recognition.onresult = (event) => {
                    const command = event.results[0][0].transcript.toLowerCase().trim();
                    displayText(`You said: "${command}"`);
                    stopListening();
                    setTimeout(() => processCommand(command), 500);
                };
                recognition.onerror = (event) => {
                    stopListening();
                    if (event.error !== 'no-speech' && event.error !== 'aborted') {
                        speak('Voice error. Try again.');
                    }
                };
                recognition.onend = () => stopListening();
                recognition.start();
            } catch (error) {
                speak('Failed to start voice recognition.');
                stopListening();
            }
        }

        function stopListening() {
            game.listening = false;
            micButton.classList.remove('listening');
            if (recognition) {
                try { recognition.stop(); } catch (e) {}
                recognition = null;
            }
        }
        function processCommand(command) {
            if (command.includes('save game') || command.includes('save')) { 
                saveGame(); 
                return; 
            }
            
            if (command.includes('load game') || command.includes('load')) {
                speak('Please say your save PIN after the word "code".');
                game.phase = 'loading';
                return;
            }
            
            if (command.includes('code ') && game.phase === 'loading') {
                const pin = command.split('code ')[1].trim().replace(/\s/g, '');
                loadGame(pin);
                return;
            }

            if (game.merchantOpen) {
                if (command.includes('leave') || command.includes('exit') || command.includes('close')) {
                    game.merchantOpen = false;
                    game.purchaseQuantity = 1;
                    speak('You leave the merchant.');
                } else if (command.includes('quantity') || command.includes('buy quantity')) {
                    if (command.includes('one') || command.includes('1')) {
                        game.purchaseQuantity = 1;
                        speak('Purchase quantity set to 1.');
                    } else if (command.includes('five') || command.includes('5')) {
                        game.purchaseQuantity = 5;
                        speak('Purchase quantity set to 5.');
                    } else if (command.includes('ten') || command.includes('10')) {
                        game.purchaseQuantity = 10;
                        speak('Purchase quantity set to 10.');
                    } else {
                        speak('Say "quantity 1", "quantity 5", or "quantity 10".');
                    }
                } else if (command.includes('buy') || command.includes('purchase')) {
                    buyFromMerchant(command);
                } else if (command.includes('what') || command.includes('wares') || command.includes('stock')) {
                    listMerchantWares();
                } else {
                    speak('Say buy, quantity, what do you have, or leave.');
                }
                return;
            }

            if (game.needsClass) {
                if (command.includes('warrior') || command.includes('fighter')) selectClass('warrior');
                else if (command.includes('mage') || command.includes('wizard')) selectClass('mage'); 
                else if (command.includes('rogue') || command.includes('thief')) selectClass('rogue');
                else speak('Please say warrior, mage, or rogue.');
                return;
            }

            if (game.combat) {
                if (command.includes('attack') || command.includes('fight')) playerAttack();
                else if (command.includes('defend') || command.includes('block') || command.includes('guard')) playerDefend();
                else if (command.includes('special') || command.includes('ability')) playerSpecial();
                else if (command.includes('cast') || command.includes('spell')) castSpell(command);
                else if (command.includes('potion') || command.includes('use') || command.includes('drink') || command.includes('heal')) processPotionCommand(command); 
                else if (command.includes('flee') || command.includes('run') || command.includes('escape')) attemptFlee();
                else speak('Say attack, defend, special, cast spell, use potion, or flee.');
                return;
            }

            if (command.includes('status') || command.includes('stats') || command.includes('check')) characterStatus();
            else if (command.includes('inventory') || command.includes('items') || command.includes('bag')) listInventory();
            else if (command.includes('commands') || command.includes('what can i')) listCommands();
            else if (command.includes('hint') || command.includes('help me')) giveHint();
            else if (command.includes('remove ring') || command.includes('unequip ring')) removeRing(command);
            else if (command.includes('potion') || command.includes('use') || command.includes('drink') || command.includes('heal')) processPotionCommand(command);
            else if (command.includes('change bracelet') || command.includes('swap bracelet')) equipBracelet(command);
            else if (command.includes('north') || command.includes('forward')) move('north');
            else if (command.includes('south') || command.includes('back')) move('south');
            else if (command.includes('east')) move('east');
            else if (command.includes('west')) move('west');
            else if (command.includes('meditate') || command.includes('rest')) meditate(); 
            else if (command.includes('look') || command.includes('around') || command.includes('where')) describeRoom();
            else if (command.includes('search') || command.includes('examine')) searchRoom();
            else if (command.includes('open chest') || command.includes('chest') || command.includes('loot')) openChest();
            else if (command.includes('fountain') || command.includes('drink water')) useFountain();
            else if (command.includes('stairs') || command.includes('go down') || command.includes('descend')) useStairs();
            else if (command.includes('merchant') || command.includes('shop') || command.includes('trade')) talkToMerchant();
            else if (command.includes('wear ring') || command.includes('equip ring') || command.includes('put on ring')) equipRing(command);
            else if (command.includes('equip amulet') || command.includes('wear amulet')) equipAmulet(command);
            else if (command.includes('equip bracelet') || command.includes('wear bracelet')) equipBracelet(command);
            else if (command.includes('equip') || command.includes('wear')) equipItem(command);
            else if (command.includes('read book') || command.includes('read') || command.includes('learn')) readBook(command);
            else if (command.includes('unlearn') || command.includes('forget')) unlearnAbility(command);
            else if (command.includes('use lockpicks') || command.includes('lockpick')) useLockpicks();
            else if (command.includes('help')) showHelp();
            else if (command.includes('junk') && (command.includes('add') || command.includes('put'))) addToJunk(command);
            else if (command.includes('junk') && (command.includes('remove') || command.includes('take out'))) removeFromJunk(command);
            else if (command.includes('sell junk') || command.includes('sell all junk')) sellAllJunk();
            else if (command.includes('view junk') || command.includes('check junk')) viewJunk();
            else if (command.includes('clear junk')) clearJunk();
            else speak('Unknown command. Say help for options.');
        }

        function talkToMerchant() {
            if (game.currentRoom.type !== 'merchant') {
                speak('There is no merchant here.');
                return;
            }
            game.merchantOpen = true;
            game.purchaseQuantity = 1;
            speak('A mysterious merchant greets you. Say "what do you have" to see wares, "buy" to purchase, "quantity" to buy multiple, or "leave" to exit.');
        }

        function buyFromMerchant(command) {
            let itemToBuy = null;
            
            for (let item of merchantItems) {
                if (command.includes(item.name.toLowerCase())) {
                    if (item.minLevel && game.dungeon.currentLevel < item.minLevel) {
                        speak(`${item.name} requires dungeon level ${item.minLevel}. Come back later.`);
                        return;
                    }
                    if (item.type === 'weapon' || item.type === 'armor' || item.type === 'helmet' || 
                        item.type === 'gloves' || item.type === 'boots' || item.type === 'shield' || item.type === 'bracelet') {
                        if (!item.class || item.class === game.player.class) {
                            itemToBuy = item;
                            break;
                        }
                    } else {
                        itemToBuy = item;
                        break;
                    }
                }
            }

            if (!itemToBuy) {
                speak('Item not recognized or not for your class. Say "what do you have" to see available items.');
                return;
            }

            const quantity = game.purchaseQuantity;
            const totalCost = itemToBuy.price * quantity;

            if (game.player.gold < totalCost) {
                speak(`Not enough gold. You need ${totalCost} gold but only have ${game.player.gold}.`);
                return;
            }

            game.player.gold -= totalCost;
            
            if (itemToBuy.type === 'special_item') {
                if (!game.player.specialItems.includes(itemToBuy.name)) {
                    game.player.specialItems.push(itemToBuy.name);
                    speak(`You bought ${itemToBuy.name} for ${itemToBuy.price} gold! ${itemToBuy.effect}. This is now permanently active!`);
                } else {
                    speak(`You already have ${itemToBuy.name}.`);
                    game.player.gold += totalCost;
                }
            } else if (itemToBuy.type === 'special_ring') {
                for (let i = 0; i < quantity; i++) {
                    game.player.equippedRings.push(itemToBuy.name);
                }
                speak(`You bought ${quantity} ${itemToBuy.name}${quantity > 1 ? 's' : ''} for ${totalCost} gold! ${itemToBuy.effect}.`);
            } else if (itemToBuy.type === 'special_amulet') {
                if (game.player.equippedAmulet) {
                    game.player.inventory.push(game.player.equippedAmulet);
                }
                game.player.equippedAmulet = itemToBuy.name;
                game.player.maxMana += itemToBuy.manaValue;
                game.player.mana += itemToBuy.manaValue;
                speak(`You bought and equipped ${itemToBuy.name} for ${itemToBuy.price} gold! Max mana increased by ${itemToBuy.manaValue}!`);
            } else if (itemToBuy.type === 'weapon') {
                if (game.player.weapon) {
                    game.player.inventory.push(game.player.weapon);
                }
                game.player.weapon = itemToBuy.name;
                game.player.baseAttack = itemToBuy.attack;
                if (itemToBuy.mana) {
                    game.player.maxMana += itemToBuy.mana;
                    game.player.mana += itemToBuy.mana;
                    speak(`You bought and equipped ${itemToBuy.name} for ${itemToBuy.price} gold! Attack ${itemToBuy.attack}, Mana +${itemToBuy.mana}!`);
                } else {
                    speak(`You bought and equipped ${itemToBuy.name} for ${itemToBuy.price} gold! Attack ${itemToBuy.attack}!`);
                }
            } else if (itemToBuy.type === 'armor') {
                if (game.player.armor) {
                    game.player.inventory.push(game.player.armor);
                }
                game.player.armor = itemToBuy.name;
                recalculateDefense();
                if (itemToBuy.mana) {
                    game.player.maxMana += itemToBuy.mana;
                    game.player.mana += itemToBuy.mana;
                    speak(`You bought and equipped ${itemToBuy.name} for ${itemToBuy.price} gold! Defense ${itemToBuy.defense}, Mana +${itemToBuy.mana}!`);
                } else {
                    speak(`You bought and equipped ${itemToBuy.name} for ${itemToBuy.price} gold! Defense ${itemToBuy.defense}!`);
                }
            } else if (itemToBuy.type === 'shield') {
                if (game.player.shield) {
                    game.player.inventory.push(game.player.shield);
                }
                game.player.shield = itemToBuy.name;
                recalculateDefense();
                speak(`You bought and equipped ${itemToBuy.name} for ${itemToBuy.price} gold! Defense ${itemToBuy.defense}!`);
            } else if (itemToBuy.type === 'helmet') {
                if (game.player.helmet) {
                    game.player.inventory.push(game.player.helmet);
                }
                game.player.helmet = itemToBuy.name;
                if (itemToBuy.defense) {
                    recalculateDefense();
                    speak(`You bought and equipped ${itemToBuy.name} for ${itemToBuy.price} gold! Defense ${itemToBuy.defense}!`);
                } else if (itemToBuy.mana) {
                    game.player.maxMana += itemToBuy.mana;
                    game.player.mana += itemToBuy.mana;
                    speak(`You bought and equipped ${itemToBuy.name} for ${itemToBuy.price} gold! Mana +${itemToBuy.mana}!`);
                }
            } else if (itemToBuy.type === 'gloves') {
                if (game.player.gloves) {
                    game.player.inventory.push(game.player.gloves);
                }
                game.player.gloves = itemToBuy.name;
                if (itemToBuy.mana) {
                    game.player.maxMana += itemToBuy.mana;
                    game.player.mana += itemToBuy.mana;
                    speak(`You bought and equipped ${itemToBuy.name} for ${itemToBuy.price} gold! Mana +${itemToBuy.mana}!`);
                } else {
                    speak(`You bought and equipped ${itemToBuy.name} for ${itemToBuy.price} gold! Attack +${itemToBuy.attack}!`);
                }
            } else if (itemToBuy.type === 'boots') {
                if (game.player.boots) {
                    game.player.inventory.push(game.player.boots);
                }
                game.player.boots = itemToBuy.name;
                if (itemToBuy.defense) {
                    recalculateDefense();
                    speak(`You bought and equipped ${itemToBuy.name} for ${itemToBuy.price} gold! Defense ${itemToBuy.defense}!`);
                } else if (itemToBuy.mana) {
                    game.player.maxMana += itemToBuy.mana;
                    game.player.mana += itemToBuy.mana;
                    speak(`You bought and equipped ${itemToBuy.name} for ${itemToBuy.price} gold! Mana +${itemToBuy.mana}!`);
                }
            } else if (itemToBuy.type === 'bracelet') {
                const hand = !game.player.leftBracelet ? 'left' : !game.player.rightBracelet ? 'right' : null;
                
                if (!hand) {
                    speak('Both bracelet slots are full. Say "change bracelet" to replace one.');
                    game.player.gold += totalCost;
                    return;
                }
                
                if (hand === 'left') {
                    game.player.leftBracelet = itemToBuy.name;
                } else {
                    game.player.rightBracelet = itemToBuy.name;
                }
                
                if (itemToBuy.mana) {
                    game.player.maxMana += itemToBuy.mana;
                    game.player.mana += itemToBuy.mana;
                }
                speak(`You bought and equipped ${itemToBuy.name} on your ${hand} wrist for ${itemToBuy.price} gold! Attack +${itemToBuy.attack}, Mana +${itemToBuy.mana}!`);
            } else if (itemToBuy.type === 'potion' || itemToBuy.type === 'special_potion') {
                for (let i = 0; i < quantity; i++) {
                    game.player.inventory.push(itemToBuy.name);
                }
                speak(`You bought ${quantity} ${itemToBuy.name}${quantity > 1 ? 's' : ''} for ${totalCost} gold. Remaining gold: ${game.player.gold}.`);
            } else {
                for (let i = 0; i < quantity; i++) {
                    game.player.inventory.push(itemToBuy.name);
                }
                speak(`You bought ${quantity} ${itemToBuy.name}${quantity > 1 ? 's' : ''} for ${totalCost} gold. Remaining gold: ${game.player.gold}.`);
            }
        }

        function listMerchantWares() {
            const messages = ['The merchant offers:'];
            const level = game.dungeon.currentLevel;
            
            merchantItems.forEach(item => {
                if (item.minLevel && level < item.minLevel) return;
                
                if (item.type === 'weapon' && (!item.class || item.class === game.player.class)) {
                    let itemDesc = `${item.name} for ${item.price} gold. Attack ${item.attack}.`;
                    if (item.description) itemDesc += ` ${item.description}.`;
                    messages.push(itemDesc);
                } else if (item.type === 'armor' && (!item.class || item.class === game.player.class)) {
                    let itemDesc = `${item.name} for ${item.price} gold. Defense ${item.defense}.`;
                    if (item.description) itemDesc += ` ${item.description}.`;
                    messages.push(itemDesc);
                } else if (item.type === 'shield' && (!item.class || item.class === game.player.class)) {
                    let itemDesc = `${item.name} for ${item.price} gold. Defense ${item.defense}.`;
                    if (item.description) itemDesc += ` ${item.description}.`;
                    messages.push(itemDesc);
                } else if (item.type === 'helmet' && (!item.class || item.class === game.player.class)) {
                    let itemDesc = `${item.name} for ${item.price} gold.`;
                    if (item.defense) itemDesc += ` Defense ${item.defense}.`;
                    if (item.mana) itemDesc += ` Mana ${item.mana}.`;
                    if (item.description) itemDesc += ` ${item.description}.`;
                    messages.push(itemDesc);
                } else if (item.type === 'gloves' && (!item.class || item.class === game.player.class)) {
                    let itemDesc = `${item.name} for ${item.price} gold.`;
                    if (item.attack) itemDesc += ` Attack ${item.attack}.`;
                    if (item.mana) itemDesc += ` Mana ${item.mana}.`;
                    if (item.description) itemDesc += ` ${item.description}.`;
                    messages.push(itemDesc);
                } else if (item.type === 'boots' && (!item.class || item.class === game.player.class)) {
                    let itemDesc = `${item.name} for ${item.price} gold.`;
                    if (item.defense) itemDesc += ` Defense ${item.defense}.`;
                    if (item.mana) itemDesc += ` Mana ${item.mana}.`;
                    if (item.health) itemDesc += ` Health ${item.health}.`;
                    if (item.description) itemDesc += ` ${item.description}.`;
                    messages.push(itemDesc);
                } else if (item.type === 'bracelet') {
                    let itemDesc = `${item.name} for ${item.price} gold. Attack ${item.attack}, Mana ${item.mana}.`;
                    if (item.description) itemDesc += ` ${item.description}.`;
                    messages.push(itemDesc);
                } else if (item.type === 'potion' || item.type === 'special_potion') {
                    messages.push(`${item.name} for ${item.price} gold.`);
                } else if (item.type === 'special_item' || item.type === 'special_ring' || item.type === 'special_amulet') {
                    messages.push(`${item.name} for ${item.price} gold. ${item.description || item.effect}.`);
                }
            });
            messages.push('Say "quantity 1, 5, or 10" to buy multiple. Say "buy" followed by the item name to purchase.');
            speakSequence(messages);
        }
        function addToJunk(command) {
            const sellableItems = game.player.inventory.filter(item => {
                return equipment.weapons.some(w => w.name === item) ||
                       equipment.armor.some(a => a.name === item) ||
                       equipment.shields.some(s => s.name === item) ||
                       equipment.helmets.some(h => h.name === item) ||
                       equipment.gloves.some(g => g.name === item) ||
                       equipment.boots.some(b => b.name === item) ||
                       equipment.bracelets.some(b => b.name === item) ||
                       treasures.some(t => t.name === item);
            });

            if (sellableItems.length === 0) {
                speak('You have no equipment or treasures to add to junk bag.');
                return;
            }

            let itemToAdd = null;
            for (let i = 0; i < sellableItems.length; i++) {
                const item = sellableItems[i];
                if (command.includes(item.toLowerCase())) {
                    itemToAdd = item;
                    break;
                }
            }

            if (!itemToAdd) {
                speak(`You can add to junk: ${sellableItems.join(', ')}. Say which item.`);
                return;
            }

            if (game.player.junkBag.includes(itemToAdd)) {
                speak(`${itemToAdd} is already in your junk bag.`);
                return;
            }

            game.player.junkBag.push(itemToAdd);
            speak(`Added ${itemToAdd} to junk bag. Say "sell junk" at a merchant to sell all junk.`);
        }

        function removeFromJunk(command) {
            if (game.player.junkBag.length === 0) {
                speak('Your junk bag is empty.');
                return;
            }

            let itemToRemove = null;
            for (let item of game.player.junkBag) {
                if (command.includes(item.toLowerCase())) {
                    itemToRemove = item;
                    break;
                }
            }

            if (!itemToRemove) {
                speak(`Junk bag contains: ${game.player.junkBag.join(', ')}. Say which to remove.`);
                return;
            }

            const index = game.player.junkBag.indexOf(itemToRemove);
            game.player.junkBag.splice(index, 1);
            speak(`Removed ${itemToRemove} from junk bag.`);
        }

        function sellAllJunk() {
            if (!game.merchantOpen) {
                speak('You need to be at a merchant to sell junk.');
                return;
            }

            if (game.player.junkBag.length === 0) {
                speak('Your junk bag is empty. Say "add to junk" followed by item names to mark items for sale.');
                return;
            }

            let totalGold = 0;
            const soldItems = [];

            for (let itemName of game.player.junkBag) {
                const itemIndex = game.player.inventory.indexOf(itemName);
                if (itemIndex === -1) continue;

                let itemValue = 0;
                const weaponData = equipment.weapons.find(w => w.name === itemName);
                const armorData = equipment.armor.find(a => a.name === itemName);
                const shieldData = equipment.shields.find(s => s.name === itemName);
                const helmetData = equipment.helmets.find(h => h.name === itemName);
                const glovesData = equipment.gloves.find(g => g.name === itemName);
                const bootsData = equipment.boots.find(b => b.name === itemName);
                const braceletData = equipment.bracelets.find(b => b.name === itemName);
                const treasureData = treasures.find(t => t.name === itemName);

                if (weaponData) itemValue = Math.floor(weaponData.value * 0.6);
                else if (armorData) itemValue = Math.floor(armorData.value * 0.6);
                else if (shieldData) itemValue = Math.floor(shieldData.value * 0.6);
                else if (helmetData) itemValue = Math.floor(helmetData.value * 0.6);
                else if (glovesData) itemValue = Math.floor(glovesData.value * 0.6);
                else if (bootsData) itemValue = Math.floor(bootsData.value * 0.6);
                else if (braceletData) itemValue = Math.floor(braceletData.value * 0.6);
                else if (treasureData) itemValue = treasureData.value;
                else itemValue = 20;

                if (game.player.specialItems.includes("Merchant's Lucky Coin")) {
                    itemValue = Math.floor(itemValue * 1.5);
                }

                game.player.inventory.splice(itemIndex, 1);
                totalGold += itemValue;
                soldItems.push(itemName);
            }

            game.player.gold += totalGold;
            game.player.junkBag = [];

            speak(`Sold ${soldItems.length} items for ${totalGold} gold! Total gold: ${game.player.gold}.`);
        }

        function viewJunk() {
            if (game.player.junkBag.length === 0) {
                speak('Your junk bag is empty.');
            } else {
                speak(`Junk bag contains: ${game.player.junkBag.join(', ')}. ${game.player.junkBag.length} items ready to sell.`);
            }
        }

        function clearJunk() {
            if (game.player.junkBag.length === 0) {
                speak('Your junk bag is already empty.');
            } else {
                game.player.junkBag = [];
                speak('Junk bag cleared. All items remain in inventory.');
            }
        }

        function recalculateDefense() {
            game.player.defense = 0;
            
            if (game.player.armor) {
                const armorData = equipment.armor.find(a => a.name === game.player.armor) ||
                                  merchantItems.find(i => i.name === game.player.armor && i.type === 'armor');
                if (armorData) game.player.defense += armorData.defense;
            }
            
            if (game.player.shield) {
                const shieldData = equipment.shields.find(s => s.name === game.player.shield) ||
                                   merchantItems.find(i => i.name === game.player.shield && i.type === 'shield');
                if (shieldData) game.player.defense += shieldData.defense;
            }
            
            if (game.player.helmet) {
                const helmetData = equipment.helmets.find(h => h.name === game.player.helmet) ||
                                   merchantItems.find(i => i.name === game.player.helmet && i.type === 'helmet');
                if (helmetData && helmetData.defense) game.player.defense += helmetData.defense;
            }
            
            if (game.player.gloves) {
                const glovesData = equipment.gloves.find(g => g.name === game.player.gloves) ||
                                   merchantItems.find(i => i.name === game.player.gloves && i.type === 'gloves');
                if (glovesData && glovesData.defense) game.player.defense += glovesData.defense;
            }
            
            if (game.player.boots) {
                const bootsData = equipment.boots.find(b => b.name === game.player.boots) ||
                                  merchantItems.find(i => i.name === game.player.boots && i.type === 'boots');
                if (bootsData && bootsData.defense) game.player.defense += bootsData.defense;
            }
        }

        function equipBracelet(command) {
            const braceletName = equipment.bracelets.map(b => b.name).find(name => command.includes(name.toLowerCase()));

            if (!braceletName) {
                const availableBracelets = game.player.inventory.filter(item => 
                    equipment.bracelets.some(b => b.name === item)
                );
                if (availableBracelets.length > 0) {
                    speak(`You have: ${availableBracelets.join(', ')}. Say which one to equip.`);
                } else {
                    speak('You have no bracelets. Find them in treasure chests.');
                }
                return;
            }

            const braceletIndex = game.player.inventory.findIndex(item => item === braceletName);
            if (braceletIndex === -1) {
                speak(`You do not have ${braceletName}.`);
                return;
            }

            const braceletData = equipment.bracelets.find(b => b.name === braceletName) || 
                                 merchantItems.find(i => i.name === braceletName && i.type === 'bracelet');

            if (!braceletData) {
                speak(`Error: Bracelet data not found.`);
                return;
            }

            // Ask which hand to equip to
            speak(`Which wrist? Say "equip on left" or "equip on right".`);
            
            // Store the bracelet info for the next command
            game.pendingBraceletEquip = { name: braceletName, data: braceletData, index: braceletIndex };
            return;
        }

        function finalizeBraceletEquip(hand) {
            if (!game.pendingBraceletEquip) {
                speak('No bracelet selected. Say "equip bracelet" first.');
                return;
            }

            const { name, data, index } = game.pendingBraceletEquip;

            if (hand === 'left' && game.player.leftBracelet) {
                const oldBracelet = game.player.leftBracelet;
                const oldData = equipment.bracelets.find(b => b.name === oldBracelet) ||
                                merchantItems.find(i => i.name === oldBracelet && i.type === 'bracelet');
                
                if (oldData && oldData.mana) {
                    game.player.maxMana -= oldData.mana;
                    game.player.mana = Math.min(game.player.mana, game.player.maxMana);
                }
                
                game.player.inventory.push(oldBracelet);
            } else if (hand === 'right' && game.player.rightBracelet) {
                const oldBracelet = game.player.rightBracelet;
                const oldData = equipment.bracelets.find(b => b.name === oldBracelet) ||
                                merchantItems.find(i => i.name === oldBracelet && i.type === 'bracelet');
                
                if (oldData && oldData.mana) {
                    game.player.maxMana -= oldData.mana;
                    game.player.mana = Math.min(game.player.mana, game.player.maxMana);
                }
                
                game.player.inventory.push(oldBracelet);
            }

            game.player.inventory.splice(index, 1);
            
            if (hand === 'left') {
                game.player.leftBracelet = name;
            } else {
                game.player.rightBracelet = name;
            }

            if (data.mana) {
                game.player.maxMana += data.mana;
                game.player.mana += data.mana;
            }

            speak(`You equip ${name} on your ${hand} wrist. Attack +${data.attack}, Mana +${data.mana}!`);
            game.pendingBraceletEquip = null;
        }

        function equipWeaponOrArmor(command) {
            let itemToEquip = null;
            let itemType = null;
            
            for (let item of game.player.inventory) {
                if (command.includes(item.toLowerCase())) {
                    if (equipment.weapons.some(w => w.name === item)) {
                        itemToEquip = item;
                        itemType = 'weapon';
                        break;
                    }
                    else if (equipment.armor.some(a => a.name === item)) {
                        itemToEquip = item;
                        itemType = 'armor';
                        break;
                    }
                    else if (equipment.shields.some(s => s.name === item)) {
                        itemToEquip = item;
                        itemType = 'shield';
                        break;
                    }
                    else if (equipment.helmets.some(h => h.name === item)) {
                        itemToEquip = item;
                        itemType = 'helmet';
                        break;
                    }
                    else if (equipment.gloves.some(g => g.name === item)) {
                        itemToEquip = item;
                        itemType = 'gloves';
                        break;
                    }
                    else if (equipment.boots.some(b => b.name === item)) {
                        itemToEquip = item;
                        itemType = 'boots';
                        break;
                    }
                    else if (equipment.bracelets.some(b => b.name === item)) {
                        equipBracelet(command);
                        return;
                    }
                }
            }
            
            if (!itemToEquip) {
                speak('You do not have that item. Check inventory.');
                return;
            }
            
            const itemIndex = game.player.inventory.indexOf(itemToEquip);
            game.player.inventory.splice(itemIndex, 1);
            
            if (itemType === 'weapon' && game.player.weapon) {
                game.player.inventory.push(game.player.weapon);
            } else if (itemType === 'armor' && game.player.armor) {
                game.player.inventory.push(game.player.armor);
            } else if (itemType === 'shield' && game.player.shield) {
                game.player.inventory.push(game.player.shield);
            } else if (itemType === 'helmet' && game.player.helmet) {
                game.player.inventory.push(game.player.helmet);
            } else if (itemType === 'gloves' && game.player.gloves) {
                game.player.inventory.push(game.player.gloves);
            } else if (itemType === 'boots' && game.player.boots) {
                game.player.inventory.push(game.player.boots);
            }
            
            if (itemType === 'weapon') {
                game.player.weapon = itemToEquip;
                const weaponData = equipment.weapons.find(w => w.name === itemToEquip);
                game.player.baseAttack = weaponData.attack;
                
                let equipMessage = `You equip ${itemToEquip}. Attack is now ${weaponData.attack}.`;
                
                if (weaponData.mana && game.player.class === 'mage') {
                    game.player.maxMana += weaponData.mana;
                    game.player.mana += weaponData.mana;
                    equipMessage += ` Max mana increased by ${weaponData.mana}!`;
                }
                
                speak(equipMessage);
            } else if (itemType === 'armor') {
                game.player.armor = itemToEquip;
                recalculateDefense();
                speak(`You equip ${itemToEquip}. Defense is now ${game.player.defense}.`);
            } else if (itemType === 'shield') {
                game.player.shield = itemToEquip;
                recalculateDefense();
                speak(`You equip ${itemToEquip}. Defense is now ${game.player.defense}.`);
            } else if (itemType === 'helmet') {
                game.player.helmet = itemToEquip;
                const helmetData = equipment.helmets.find(h => h.name === itemToEquip);
                if (helmetData.defense) {
                    recalculateDefense();
                    speak(`You equip ${itemToEquip}. Defense is now ${game.player.defense}.`);
                } else if (helmetData.mana) {
                    game.player.maxMana += helmetData.mana;
                    game.player.mana += helmetData.mana;
                    speak(`You equip ${itemToEquip}. Max mana increased by ${helmetData.mana}!`);
                }
            } else if (itemType === 'gloves') {
                game.player.gloves = itemToEquip;
                const glovesData = equipment.gloves.find(g => g.name === itemToEquip);
                if (glovesData.attack) {
                    speak(`You equip ${itemToEquip}. Attack damage increased by ${glovesData.attack}!`);
                } else if (glovesData.mana) {
                    game.player.maxMana += glovesData.mana;
                    game.player.mana += glovesData.mana;
                    speak(`You equip ${itemToEquip}. Max mana increased by ${glovesData.mana}!`);
                } else if (glovesData.health) {
                    game.player.maxHealth += glovesData.health;
                    game.player.health += glovesData.health;
                    speak(`You equip ${itemToEquip}. Max health increased by ${glovesData.health}!`);
                }
            } else if (itemType === 'boots') {
                game.player.boots = itemToEquip;
                const bootsData = equipment.boots.find(b => b.name === itemToEquip);
                if (bootsData.defense) {
                    recalculateDefense();
                    speak(`You equip ${itemToEquip}. Defense is now ${game.player.defense}.`);
                } else if (bootsData.mana) {
                    game.player.maxMana += bootsData.mana;
                    game.player.mana += bootsData.mana;
                    speak(`You equip ${itemToEquip}. Max mana increased by ${bootsData.mana}!`);
                } else if (bootsData.health) {
                    game.player.maxHealth += bootsData.health;
                    game.player.health += bootsData.health;
                    speak(`You equip ${itemToEquip}. Max health increased by ${bootsData.health}!`);
                }
            }
        }

        function equipItem(command) {
            if (command.includes('ring')) {
                speak('Say "wear ring" to equip rings.');
            } else if (command.includes('amulet')) {
                speak('Say "equip amulet" for amulets.');
            } else if (command.includes('bracelet')) {
                equipBracelet(command);
            } else if (command.includes('on left') || command.includes('on right')) {
                const hand = command.includes('on left') ? 'left' : 'right';
                finalizeBraceletEquip(hand);
            } else {
                equipWeaponOrArmor(command);
            }
        }

        function useLockpicks() {
            if (!game.player.inventory.includes('Lockpicks')) {
                speak('You do not have lockpicks. Rogues start with them.');
                return;
            }
            
            if (game.currentRoom.hasChest && !game.currentRoom.searched) {
                speak('You expertly pick the lock on the chest!');
                openChest();
            } else {
                speak('There is nothing to pick here.');
            }
        }
        function processPotionCommand(command) {
            let potionType = null;
            
            if (command.includes('immortality') || command.includes('elixir of immortality')) {
                potionType = 'Elixir of Immortality';
            } else if (command.includes('giant strength') || command.includes('strength')) {
                potionType = 'Potion of Giant Strength';
            } else if (command.includes('clarity') || command.includes('elixir of clarity')) {
                potionType = 'Elixir of Clarity';
            } else if (command.includes('ultimate') && (command.includes('health') || command.includes('heal'))) {
                potionType = 'Ultimate Health Potion';
            } else if (command.includes('ultimate') && command.includes('mana')) {
                potionType = 'Ultimate Mana Potion';
            } else if (command.includes('supreme') && (command.includes('health') || command.includes('heal'))) {
                potionType = 'Supreme Health Potion';
            } else if (command.includes('supreme') && command.includes('mana')) {
                potionType = 'Supreme Mana Potion';
            } else if (command.includes('greater') && (command.includes('health') || command.includes('heal'))) {
                potionType = 'Greater Health Potion';
            } else if (command.includes('greater') && command.includes('mana')) {
                potionType = 'Greater Mana Potion';
            } else if (command.includes('health') || command.includes('heal')) {
                potionType = 'Health Potion';
            } else if (command.includes('mana')) {
                potionType = 'Mana Potion';
            }
            
            if (!potionType) {
                const healthIdx = game.player.inventory.indexOf('Health Potion');
                const manaIdx = game.player.inventory.indexOf('Mana Potion');
                
                if (healthIdx !== -1 && game.player.health < game.player.maxHealth) {
                    potionType = 'Health Potion';
                } else if (manaIdx !== -1 && game.player.mana < game.player.maxMana) {
                    potionType = 'Mana Potion';
                } else if (healthIdx !== -1) {
                    potionType = 'Health Potion';
                } else if (manaIdx !== -1) {
                    potionType = 'Mana Potion';
                }
            }
            
            if (potionType) {
                usePotion(potionType);
            } else {
                speak('You have no potions.');
            }
        }

        function usePotion(potionType) {
            const idx = game.player.inventory.indexOf(potionType);
            if (idx === -1) {
                speak(`You do not have a ${potionType}.`);
                return;
            }
            
            game.player.inventory.splice(idx, 1);
            
            if (potionType === 'Health Potion') {
                const heal = 50;
                const oldHealth = game.player.health;
                game.player.health = Math.min(game.player.maxHealth, game.player.health + heal);
                const actualHeal = game.player.health - oldHealth;
                speak(`You drink a health potion and restore ${actualHeal} health. Health: ${game.player.health}.`, () => {
                    if (game.combat) {
                        setTimeout(() => enemyTurn(), 1000);
                    }
                });
            } else if (potionType === 'Greater Health Potion') {
                const heal = 150;
                const oldHealth = game.player.health;
                game.player.health = Math.min(game.player.maxHealth, game.player.health + heal);
                const actualHeal = game.player.health - oldHealth;
                speak(`You drink a greater health potion and restore ${actualHeal} health. Health: ${game.player.health}.`, () => {
                    if (game.combat) {
                        setTimeout(() => enemyTurn(), 1000);
                    }
                });
            } else if (potionType === 'Supreme Health Potion') {
                const heal = 300;
                const oldHealth = game.player.health;
                game.player.health = Math.min(game.player.maxHealth, game.player.health + heal);
                const actualHeal = game.player.health - oldHealth;
                speak(`You drink a supreme health potion and restore ${actualHeal} health. Health: ${game.player.health}.`, () => {
                    if (game.combat) {
                        setTimeout(() => enemyTurn(), 1000);
                    }
                });
            } else if (potionType === 'Ultimate Health Potion') {
                const heal = 800;
                const oldHealth = game.player.health;
                game.player.health = Math.min(game.player.maxHealth, game.player.health + heal);
                const actualHeal = game.player.health - oldHealth;
                speak(`You drink an ultimate health potion and restore ${actualHeal} health. Health: ${game.player.health}.`, () => {
                    if (game.combat) {
                        setTimeout(() => enemyTurn(), 1000);
                    }
                });
            } else if (potionType === 'Mana Potion') {
                const restore = 30;
                const oldMana = game.player.mana;
                game.player.mana = Math.min(game.player.maxMana, game.player.mana + restore);
                const actualRestore = game.player.mana - oldMana;
                speak(`You drink a mana potion and restore ${actualRestore} mana. Mana: ${game.player.mana}.`, () => {
                    if (game.combat) {
                        setTimeout(() => enemyTurn(), 1000);
                    }
                });
            } else if (potionType === 'Greater Mana Potion') {
                const restore = 100;
                const oldMana = game.player.mana;
                game.player.mana = Math.min(game.player.maxMana, game.player.mana + restore);
                const actualRestore = game.player.mana - oldMana;
                speak(`You drink a greater mana potion and restore ${actualRestore} mana. Mana: ${game.player.mana}.`, () => {
                    if (game.combat) {
                        setTimeout(() => enemyTurn(), 1000);
                    }
                });
            } else if (potionType === 'Supreme Mana Potion') {
                const restore = 200;
                const oldMana = game.player.mana;
                game.player.mana = Math.min(game.player.maxMana, game.player.mana + restore);
                const actualRestore = game.player.mana - oldMana;
                speak(`You drink a supreme mana potion and restore ${actualRestore} mana. Mana: ${game.player.mana}.`, () => {
                    if (game.combat) {
                        setTimeout(() => enemyTurn(), 1000);
                    }
                });
            } else if (potionType === 'Ultimate Mana Potion') {
                const restore = 500;
                const oldMana = game.player.mana;
                game.player.mana = Math.min(game.player.maxMana, game.player.mana + restore);
                const actualRestore = game.player.mana - oldMana;
                speak(`You drink an ultimate mana potion and restore ${actualRestore} mana. Mana: ${game.player.mana}.`, () => {
                    if (game.combat) {
                        setTimeout(() => enemyTurn(), 1000);
                    }
                });
            } else if (potionType === 'Elixir of Immortality') {
                game.player.activeEffects.push({ type: 'revive', uses: 1 });
                speak(`You drink the Elixir of Immortality! You will revive once if you die.`, () => {
                    if (game.combat) {
                        setTimeout(() => enemyTurn(), 1000);
                    }
                });
            } else if (potionType === 'Potion of Giant Strength') {
                game.player.activeEffects.push({ type: 'strength', battles: 3 });
                speak(`You drink the Potion of Giant Strength! Your attacks deal double damage for 3 battles!`, () => {
                    if (game.combat) {
                        setTimeout(() => enemyTurn(), 1000);
                    }
                });
            } else if (potionType === 'Elixir of Clarity') {
                game.player.activeEffects.push({ type: 'clarity', battles: 3 });
                speak(`You drink the Elixir of Clarity! All spells cost 50% less mana for 3 battles!`, () => {
                    if (game.combat) {
                        setTimeout(() => enemyTurn(), 1000);
                    }
                });
            }
        }

        function gainExperience(exp) {
            let actualExp = exp;
            
            if (game.player.equippedAmulet && amulets.find(a => a.name === game.player.equippedAmulet)?.stat === 'expGain') {
                actualExp = Math.floor(exp * 1.2);
            }
            
            if (game.player.specialItems.includes('Crystal of Experience')) {
                actualExp = Math.floor(actualExp * 2);
            }
            
            game.player.experience += actualExp;
            
            if (game.player.experience >= game.player.experienceToNext) {
                levelUp();
            }
        }

        function levelUp() {
            game.player.level++;
            game.player.experience -= game.player.experienceToNext;
            game.player.experienceToNext = Math.floor(game.player.experienceToNext * 1.20);
            
            const healthGain = 20;
            const manaGain = 10;
            
            game.player.maxHealth += healthGain;
            game.player.health = game.player.maxHealth;
            game.player.maxMana += manaGain;
            game.player.mana = game.player.maxMana;
            
            speakSequence([
                `Level up! You are now level ${game.player.level}!`,
                `Max health increased by ${healthGain}!`,
                `Max mana increased by ${manaGain}!`,
                `Fully healed and restored!`
            ]);
        }

        function equipRing(command) {
            const ringName = command.includes('vitality') || command.includes('health') ? 'Ring of Vitality' :
                             command.includes('minor mana') || command.includes('mana ring') ? 'Ring of Minor Mana' :
                             command.includes('protection') ? 'Ring of Protection' :
                             command.includes('strength') ? 'Ring of Strength' :
                             command.includes('wisdom') ? 'Ring of Wisdom' :
                             command.includes('titan') ? 'Ring of the Titan' :
                             command.includes('arcane power') ? 'Ring of Arcane Power' :
                             command.includes('berserker') ? 'Ring of the Berserker' :
                             command.includes('regeneration') ? 'Ring of Regeneration' :
                             command.includes('ancient ring') ? 'Ancient Ring' :
                             command.includes('cosmic ring') ? 'Cosmic Ring' :
                             command.includes('devastation') ? 'Ring of Devastation' :
                             command.includes('ragnarok ring') ? 'Ragnarok Ring' :
                             command.includes('genesis ring') ? 'Genesis Ring' :
                             command.includes('apocalypse ring') ? 'Apocalypse Ring' : null;

            if (!ringName) {
                const availableRings = game.player.inventory.filter(item => 
                    rings.some(r => r.name === item) || item === 'Ring of Regeneration'
                );
                if (availableRings.length > 0) {
                    speak(`You have: ${availableRings.join(', ')}. Say which one to equip.`);
                } else {
                    speak('You have no rings. Find them in treasure chests or by searching rooms.');
                }
                return;
            }

            const ringIndex = game.player.inventory.findIndex(item => item === ringName);
            if (ringIndex === -1) {
                speak(`You do not have a ${ringName}.`);
                return;
            }

            if (game.player.equippedRings.length >= 10) {
                speak(`You already have 10 rings equipped. Say "remove ring" first.`);
                return;
            }

            const equippedCount = game.player.equippedRings.filter(r => r === ringName).length;
            
            if (equippedCount >= 2) {
                speak(`You already have 2 ${ringName} equipped. You can only stack 2 of the same ring.`);
                return;
            }

            const ringData = rings.find(r => r.name === ringName);
            if (!ringData && ringName !== 'Ring of Regeneration') {
                speak(`Error: Ring data not found.`);
                return;
            }

            game.player.inventory.splice(ringIndex, 1);
            game.player.equippedRings.push(ringName);
            
            if (ringName === 'Ring of Regeneration') {
                speak(`You equip the ${ringName}. You will restore 50 health per turn in combat! You have ${game.player.equippedRings.length} rings equipped.`);
            } else if (ringData.stat === 'maxHealth') {
                game.player.maxHealth += ringData.value;
                game.player.health += ringData.value;
                speak(`You equip the ${ringName}. Your max health increased by ${ringData.value}! You have ${game.player.equippedRings.length} rings equipped.`);
            } else if (ringData.stat === 'maxMana') {
                game.player.maxMana += ringData.value;
                game.player.mana += ringData.value;
                speak(`You equip the ${ringName}. Your max mana increased by ${ringData.value}! You have ${game.player.equippedRings.length} rings equipped.`);
            } else if (ringData.stat === 'attack') {
                speak(`You equip the ${ringName}. Your attacks are now stronger! You have ${game.player.equippedRings.length} rings equipped.`);
            }
        }

        function removeRing(command) {
            if (game.player.equippedRings.length === 0) {
                speak('You have no rings equipped.');
                return;
            }

            const ringName = command.includes('vitality') || command.includes('health') ? 'Ring of Vitality' :
                             command.includes('minor mana') || command.includes('mana ring') ? 'Ring of Minor Mana' :
                             command.includes('protection') ? 'Ring of Protection' :
                             command.includes('strength') ? 'Ring of Strength' :
                             command.includes('wisdom') ? 'Ring of Wisdom' :
                             command.includes('titan') ? 'Ring of the Titan' :
                             command.includes('arcane power') ? 'Ring of Arcane Power' :
                             command.includes('berserker') ? 'Ring of the Berserker' :
                             command.includes('regeneration') ? 'Ring of Regeneration' :
                             command.includes('ancient ring') ? 'Ancient Ring' :
                             command.includes('cosmic ring') ? 'Cosmic Ring' :
                             command.includes('devastation') ? 'Ring of Devastation' :
                             command.includes('ragnarok ring') ? 'Ragnarok Ring' :
                             command.includes('genesis ring') ? 'Genesis Ring' :
                             command.includes('apocalypse ring') ? 'Apocalypse Ring' : null;

            if (!ringName) {
                const equippedCounts = {};
                game.player.equippedRings.forEach(ring => equippedCounts[ring] = (equippedCounts[ring] || 0) + 1);
                const equippedList = Object.entries(equippedCounts).map(([ring, count]) => 
                    count > 1 ? `${ring} x${count}` : ring
                );
                speak(`Equipped rings: ${equippedList.join(', ')}. Say which one to remove.`);
                return;
            }

            const ringIndex = game.player.equippedRings.findIndex(r => r === ringName);
            if (ringIndex === -1) {
                speak(`You do not have ${ringName} equipped.`);
                return;
            }

            game.player.equippedRings.splice(ringIndex, 1);
            game.player.inventory.push(ringName);

            const ringData = rings.find(r => r.name === ringName);
            if (ringName === 'Ring of Regeneration') {
                speak(`You remove the ${ringName}. You have ${game.player.equippedRings.length} rings equipped.`);
            } else if (ringData.stat === 'maxHealth') {
                game.player.maxHealth -= ringData.value;
                game.player.health = Math.min(game.player.health, game.player.maxHealth);
                speak(`You remove the ${ringName}. Max health decreased by ${ringData.value}. You have ${game.player.equippedRings.length} rings equipped.`);
            } else if (ringData.stat === 'maxMana') {
                game.player.maxMana -= ringData.value;
                game.player.mana = Math.min(game.player.mana, game.player.maxMana);
                speak(`You remove the ${ringName}. Max mana decreased by ${ringData.value}. You have ${game.player.equippedRings.length} rings equipped.`);
            } else if (ringData.stat === 'attack') {
                speak(`You remove the ${ringName}. You have ${game.player.equippedRings.length} rings equipped.`);
            }
        }

        function equipAmulet(command) {
            const amuletName = command.includes('vitality') ? 'Amulet of Vitality' :
                               command.includes('amulet of mana') || command.includes('mana') && !command.includes('archmage') && !command.includes('arcane') ? 'Amulet of Mana' :
                               command.includes('experience') ? 'Amulet of Experience' :
                               command.includes('archmage') ? 'Amulet of the Archmage' :
                               command.includes('titan') ? 'Amulet of the Titan' :
                               command.includes('power') ? 'Amulet of Power' :
                               command.includes('ancient amulet') ? 'Ancient Amulet' :
                               command.includes('cosmic amulet') ? 'Cosmic Amulet' :
                               command.includes('destruction') ? 'Amulet of Destruction' :
                               command.includes('ragnarok amulet') ? 'Ragnarok Amulet' :
                               command.includes('genesis amulet') ? 'Genesis Amulet' :
                               command.includes('apocalypse amulet') ? 'Apocalypse Amulet' :
                               command.includes('arcane master') ? 'Amulet of the Arcane Master' : null;

            if (!amuletName) {
                const availableAmulets = game.player.inventory.filter(item => 
                    amulets.some(a => a.name === item) || item === 'Amulet of the Arcane Master'
                );
                if (availableAmulets.length > 0) {
                    speak(`You have: ${availableAmulets.join(', ')}. Say which one to equip.`);
                } else {
                    speak('You have no amulets. Find them in treasure chests or by searching rooms.');
                }
                return;
            }

            const amuletIndex = game.player.inventory.findIndex(item => item === amuletName);
            if (amuletIndex === -1) {
                speak(`You do not have the ${amuletName}.`);
                return;
            }

            if (game.player.equippedAmulet === amuletName) {
                speak(`You are already wearing the ${amuletName}.`);
                return;
            }

            const amuletData = amulets.find(a => a.name === amuletName);
            const specialAmulet = merchantItems.find(i => i.name === amuletName && i.type === 'special_amulet');
            
            if (!amuletData && !specialAmulet) {
                speak(`Error: Amulet data not found.`);
                return;
            }

            if (game.player.equippedAmulet) {
                const oldAmulet = game.player.equippedAmulet;
                const oldAmuletData = amulets.find(a => a.name === oldAmulet);
                const oldSpecialAmulet = merchantItems.find(i => i.name === oldAmulet && i.type === 'special_amulet');
                
                if (oldAmuletData) {
                    if (oldAmuletData.stat === 'maxHealth') {
                        game.player.maxHealth -= oldAmuletData.value;
                        game.player.health = Math.min(game.player.health, game.player.maxHealth);
                    } else if (oldAmuletData.stat === 'maxMana') {
                        game.player.maxMana -= oldAmuletData.value;
                        game.player.mana = Math.min(game.player.mana, game.player.maxMana);
                    }
                } else if (oldSpecialAmulet) {
                    if (oldSpecialAmulet.manaValue) {
                        game.player.maxMana -= oldSpecialAmulet.manaValue;
                        game.player.mana = Math.min(game.player.mana, game.player.maxMana);
                    }
                }
                
                game.player.inventory.push(oldAmulet);
            }

            game.player.inventory.splice(amuletIndex, 1);
            game.player.equippedAmulet = amuletName;

            if (specialAmulet) {
                if (specialAmulet.manaValue) {
                    game.player.maxMana += specialAmulet.manaValue;
                    game.player.mana += specialAmulet.manaValue;
                }
                speak(`You equip the ${amuletName}. ${specialAmulet.effect}!`);
            } else if (amuletData.stat === 'maxHealth') {
                game.player.maxHealth += amuletData.value;
                game.player.health += amuletData.value;
                speak(`You equip the ${amuletName}. Your max health increased by ${amuletData.value}!`);
            } else if (amuletData.stat === 'maxMana') {
                game.player.maxMana += amuletData.value;
                game.player.mana += amuletData.value;
                speak(`You equip the ${amuletName}. Your max mana increased by ${amuletData.value}!`);
            } else if (amuletData.stat === 'expGain') {
                speak(`You equip the ${amuletName}. You now gain 20% more experience!`);
            } else if (amuletData.stat === 'attack') {
                speak(`You equip the ${amuletName}. Your attack power increases by ${amuletData.value}!`);
            }
        }

        function readBook(command) {
            const abilityBooks = abilities.filter(ab => 
                game.player.inventory.includes(ab.name) && 
                (ab.class === game.player.class || !ab.class)
            );

            if (abilityBooks.length === 0) {
                speak('You have no ability books to read. Find them in treasure chests.');
                return;
            }

            let bookToRead = null;
            
            for (let ability of abilityBooks) {
                if (command.includes(ability.name.toLowerCase())) {
                    bookToRead = ability;
                    break;
                }
            }

            if (!bookToRead) {
                bookToRead = abilityBooks[0];
            }

            if (game.player.learnedAbilities.includes(bookToRead.name)) {
                speak(`You already know ${bookToRead.name}.`);
                return;
            }

            const bookIndex = game.player.inventory.indexOf(bookToRead.name);
            game.player.inventory.splice(bookIndex, 1);
            game.player.learnedAbilities.push(bookToRead.name);
            speak(`You read the ancient tome and learn ${bookToRead.name}! ${bookToRead.description}. Say "cast ${bookToRead.name}" in combat to use it.`);
        }

        function unlearnAbility(command) {
            if (game.player.learnedAbilities.length === 0) {
                speak('You have no learned abilities to forget.');
                return;
            }

            let abilityToUnlearn = null;
            
            for (let abilityName of game.player.learnedAbilities) {
                if (command.includes(abilityName.toLowerCase())) {
                    abilityToUnlearn = abilityName;
                    break;
                }
            }

            if (!abilityToUnlearn) {
                speak(`You know: ${game.player.learnedAbilities.join(', ')}. Say which one to unlearn.`);
                return;
            }

            const abilityIndex = game.player.learnedAbilities.indexOf(abilityToUnlearn);
            game.player.learnedAbilities.splice(abilityIndex, 1);
            game.player.inventory.push(abilityToUnlearn);
            
            speak(`You forget ${abilityToUnlearn}. The knowledge returns to book form in your inventory.`);
        }
        function selectClass(className) {
            const classData = classes[className];
            game.player.class = className;
            game.player.health = classData.health;
            game.player.maxHealth = classData.maxHealth;
            game.player.mana = classData.mana;
            game.player.maxMana = classData.maxMana;
            game.player.gold = classData.gold;
            game.player.inventory = [...classData.items];
            game.player.equippedRings = [];
            game.player.learnedAbilities = [];
            game.player.equippedAmulet = '';
            
            game.player.weapon = classData.items.find(item => equipment.weapons.some(w => w.name === item)) || '';
            game.player.armor = classData.items.find(item => equipment.armor.some(a => a.name === item)) || '';
            game.player.shield = '';
            game.player.helmet = '';
            game.player.gloves = '';
            game.player.boots = '';
            game.player.leftBracelet = '';
            game.player.rightBracelet = '';
            
            if (equipment.shields) {
                const foundShield = classData.items.find(item => equipment.shields.some(s => s.name === item));
                if (foundShield) {
                    game.player.shield = foundShield;
                }
            }
            
            const weaponData = equipment.weapons.find(w => w.name === game.player.weapon);
            game.player.baseAttack = weaponData ? weaponData.attack : 15;
            
            const armorData = equipment.armor.find(a => a.name === game.player.armor);
            game.player.defense = armorData ? armorData.defense : 0;
            
            if (game.player.shield && equipment.shields) {
                const shieldData = equipment.shields.find(s => s.name === game.player.shield);
                if (shieldData) {
                    game.player.defense += shieldData.defense;
                }
            }
            
            game.needsClass = false;
            game.started = true;
            game.phase = 'exploration';
            
            generateDungeon();
            
            let messages = [
                `You are now a ${classData.name}.`,
                `Health: ${classData.health}.`,
                `Mana: ${classData.mana}.`,
                `Starting gold: ${classData.gold}.`
            ];

            if (game.player.weapon && game.player.armor) {
                messages.push(`Equipped: ${game.player.weapon} and ${game.player.armor}.`);
            }

            if (game.player.shield) {
                messages.push(`Shield: ${game.player.shield}.`);
            }

            messages.push(`Your adventure begins!`);
            
            speakSequence(messages, () => {
                setTimeout(() => describeRoom(), 1000);
            });
        }

        function startCombat(enemy, secondEnemy = null) {
            game.combat = { 
                enemy: { ...enemy }, 
                secondEnemy: secondEnemy ? { ...secondEnemy } : null,
                playerDefending: false,
                twoEnemyFight: secondEnemy ? true : false
            };
            game.phase = 'combat';
            
            let messages = [`Combat begins!`, `${enemy.name} has ${enemy.health} health.`];
            
            if (secondEnemy) {
                messages.push(`${secondEnemy.name} has ${secondEnemy.health} health.`);
                messages.push(`You face two enemies!`);
            }
            
            if (enemy.regenerate) {
                messages.push(`Warning: ${enemy.name} regenerates ${enemy.regenerate} health per turn!`);
            }
            if (secondEnemy && secondEnemy.regenerate) {
                messages.push(`Warning: ${secondEnemy.name} regenerates ${secondEnemy.regenerate} health per turn!`);
            }
            
            messages.push(`What will you do? Attack, defend, special, cast spell, use potion, or flee.`);
            
            speakSequence(messages);
        }

        function playerAttack() {
            const weaponData = equipment.weapons.find(w => w.name === game.player.weapon) ||
                               merchantItems.find(i => i.name === game.player.weapon && i.type === 'weapon');
            const weaponAttack = weaponData ? weaponData.attack : 0;
            
            let amuletBonus = 0;
            if (game.player.equippedAmulet) {
                const amuletData = amulets.find(a => a.name === game.player.equippedAmulet);
                if (amuletData && amuletData.stat === 'attack') {
                    amuletBonus = amuletData.value;
                }
                const specialAmulet = merchantItems.find(i => i.name === game.player.equippedAmulet && i.type === 'special_amulet');
                if (specialAmulet && specialAmulet.damageValue) {
                    amuletBonus += specialAmulet.damageValue;
                }
            }
            
            let glovesBonus = 0;
            if (game.player.gloves) {
                const glovesData = equipment.gloves.find(g => g.name === game.player.gloves) ||
                                   merchantItems.find(i => i.name === game.player.gloves && i.type === 'gloves');
                if (glovesData && glovesData.attack) {
                    glovesBonus = glovesData.attack;
                }
            }
            
            let braceletBonus = 0;
            if (game.player.leftBracelet) {
                const leftData = equipment.bracelets.find(b => b.name === game.player.leftBracelet) ||
                                 merchantItems.find(i => i.name === game.player.leftBracelet && i.type === 'bracelet');
                if (leftData && leftData.attack) {
                    braceletBonus += leftData.attack;
                }
            }
            if (game.player.rightBracelet) {
                const rightData = equipment.bracelets.find(b => b.name === game.player.rightBracelet) ||
                                  merchantItems.find(i => i.name === game.player.rightBracelet && i.type === 'bracelet');
                if (rightData && rightData.attack) {
                    braceletBonus += rightData.attack;
                }
            }
            
            let baseDamage = game.player.baseAttack + weaponAttack + amuletBonus + glovesBonus + braceletBonus;
            
            if (game.player.class === 'warrior' || game.player.class === 'rogue') {
                baseDamage += (game.player.level - 1) * 5;
            }
            
            const ringBonus = game.player.equippedRings.reduce((total, ring) => {
                const ringData = rings.find(r => r.name === ring);
                return total + (ringData && ringData.stat === 'attack' ? ringData.value : 0);
            }, 0);
            
            let damage = baseDamage + ringBonus + Math.floor(Math.random() * 10);
            
            const strengthEffect = game.player.activeEffects.find(e => e.type === 'strength');
            if (strengthEffect) {
                damage = Math.floor(damage * 2);
            }
            
            const merchantArmor = merchantItems.find(i => i.name === game.player.armor && i.type === 'armor');
            if (merchantArmor && merchantArmor.effect === 'strength_bonus') {
                damage = Math.floor(damage * 1.15);
            }
            
            if (game.combat.playerShadowmelded) {
                damage = Math.floor(damage * 2);
                game.combat.playerShadowmelded = false;
            }
            
            if (game.combat.enemy.deathMarked) {
                damage = Math.floor(damage * 1.5);
            }
            
            game.combat.enemy.health -= damage;
            
            let messages = [`You attack for ${damage} damage!`];
            if (strengthEffect) {
                messages.push(`Giant Strength doubles your damage!`);
            }
            if (merchantArmor && merchantArmor.effect === 'strength_bonus') {
                messages.push(`Your armor amplifies your strike!`);
            }
            if (game.combat.enemy.deathMarked) {
                messages.push(`Death Mark amplifies your strike!`);
            }
            messages.push(`${game.combat.enemy.name} has ${Math.max(0, game.combat.enemy.health)} health left.`);
            
            speakSequence(messages, () => {
                if (game.combat.enemy.health <= 0) {
                    if (game.combat.secondEnemy && game.combat.secondEnemy.health > 0) {
                        game.combat.enemy = game.combat.secondEnemy;
                        game.combat.secondEnemy = null;
                        speak(`${game.combat.enemy.name} remains! Health: ${game.combat.enemy.health}.`, () => {
                            setTimeout(() => enemyTurn(), 1000);
                        });
                    } else {
                        setTimeout(() => combatVictory(), 1000);
                    }
                } else {
                    setTimeout(() => enemyTurn(), 1000);
                }
            });
        }

        function playerDefend() {
            game.combat.playerDefending = true;
            speak('You brace for impact.', () => {
                setTimeout(() => enemyTurn(), 1000);
            });
        }

        function playerSpecial() {
            const classData = classes[game.player.class];
            const special = classData.special;
            
            if (game.player.mana < special.cost) {
                speak(`Not enough mana. You need ${special.cost}.`);
                return;
            }
            
            game.player.mana -= special.cost;
            
            if (special.type === 'damage') {
                // Warrior Power Strike - scales with level
                let damage = special.damage;
                const levelTier = Math.floor(game.player.level / 10);
                damage = damage * (1 + levelTier);
                
                damage += (game.player.level - 1) * 5;
                
                game.combat.enemy.health -= damage;
                
                speakSequence([
                    `You unleash ${special.name}!`,
                    `${damage} damage!`,
                    `${game.combat.enemy.name} has ${Math.max(0, game.combat.enemy.health)} health left.`
                ], () => {
                    if (game.combat.enemy.health <= 0) {
                        if (game.combat.secondEnemy && game.combat.secondEnemy.health > 0) {
                            game.combat.enemy = game.combat.secondEnemy;
                            game.combat.secondEnemy = null;
                            speak(`${game.combat.enemy.name} remains! Health: ${game.combat.enemy.health}.`, () => {
                                setTimeout(() => enemyTurn(), 1000);
                            });
                        } else {
                            setTimeout(() => combatVictory(), 1000);
                        }
                    } else {
                        setTimeout(() => enemyTurn(), 1000);
                    }
                });
            } else if (special.type === 'shield') {
                // Mage Mana Shield - absorbs 50% of next hit using mana
                game.combat.manaShieldActive = true;
                speak('You create a Mana Shield! 50% of the next hit will drain mana instead of health.', () => {
                    setTimeout(() => enemyTurn(), 1000);
                });
            } else if (special.type === 'sneak') {
                // Rogue Sneak Attack - no retaliation
                let damage = special.damage;
                const levelTier = Math.floor(game.player.level / 10);
                damage = damage * (1 + levelTier);
                
                damage += (game.player.level - 1) * 5;
                
                game.combat.enemy.health -= damage;
                
                speakSequence([
                    `You strike from the shadows!`,
                    `${damage} damage!`,
                    `The enemy cannot counter!`,
                    `${game.combat.enemy.name} has ${Math.max(0, game.combat.enemy.health)} health left.`
                ], () => {
                    if (game.combat.enemy.health <= 0) {
                        if (game.combat.secondEnemy && game.combat.secondEnemy.health > 0) {
                            game.combat.enemy = game.combat.secondEnemy;
                            game.combat.secondEnemy = null;
                            speak(`${game.combat.enemy.name} remains! Health: ${game.combat.enemy.health}.`);
                        } else {
                            setTimeout(() => combatVictory(), 1000);
                        }
                    } else {
                        speak('Your turn again.');
                    }
                });
            }
        }

        function attemptFlee() {
            const chance = game.combat.enemy.fleeChance;
            const roll = Math.random();
            
            speak(`Attempting to flee...`, () => {
                setTimeout(() => {
                    if (roll < chance) {
                        speak('You successfully escape!', () => {
                            game.combat = null;
                            game.phase = 'exploration';
                            setTimeout(() => {
                                const centerX = 6;
                                const centerY = 6;
                                game.player.position = { x: centerX, y: centerY };
                                const key = `${centerX},${centerY}`;
                                game.currentRoom = game.dungeon.grid[key];
                                speak('You flee back to the entrance.');
                            }, 1000);
                        });
                    } else {
                        speak('You fail to escape!', () => {
                            setTimeout(() => enemyTurn(), 1000);
                        });
                    }
                }, 1000);
            });
        }

        function enemyTurn() {
            let messages = [];
            
            const regenRingCount = game.player.equippedRings.filter(r => r === 'Ring of Regeneration').length;
            if (regenRingCount > 0) {
                const regenAmount = 50 * regenRingCount;
                const oldHealth = game.player.health;
                game.player.health = Math.min(game.player.maxHealth, game.player.health + regenAmount);
                const actualHeal = game.player.health - oldHealth;
                if (actualHeal > 0) {
                    messages.push(`Your Ring${regenRingCount > 1 ? 's' : ''} of Regeneration heal${regenRingCount === 1 ? 's' : ''} you for ${actualHeal} health!`);
                }
            }
            
            if (game.combat.enemy.frozen) {
                if (game.combat.enemy.timestopTurns) {
                    game.combat.enemy.timestopTurns--;
                    if (game.combat.enemy.timestopTurns <= 0) {
                        game.combat.enemy.frozen = false;
                        game.combat.enemy.timestopTurns = 0;
                    }
                } else {
                    game.combat.enemy.frozen = false;
                }
                messages.push(`${game.combat.enemy.name} is frozen and cannot act!`);
            } else if (game.combat.enemy.stunned) {
                messages.push(`${game.combat.enemy.name} is stunned and cannot act!`);
                game.combat.enemy.stunned = false;
            } else {
                if (game.combat.enemy.regenerate) {
                    game.combat.enemy.health += game.combat.enemy.regenerate;
                    messages.push(`${game.combat.enemy.name} regenerates ${game.combat.enemy.regenerate} health!`);
                }
                
                if (game.combat.enemy.poisoned) {
                    game.combat.enemy.health -= game.combat.enemy.poisoned.damage;
                    messages.push(`${game.combat.enemy.name} takes ${game.combat.enemy.poisoned.damage} poison damage!`);
                    game.combat.enemy.poisoned.duration--;
                    if (game.combat.enemy.poisoned.duration <= 0) {
                        game.combat.enemy.poisoned = null;
                    }
                    if (game.combat.enemy.health <= 0) {
                        speakSequence(messages, () => {
                            setTimeout(() => {
                                if (game.combat.secondEnemy && game.combat.secondEnemy.health > 0) {
                                    game.combat.enemy = game.combat.secondEnemy;
                                    game.combat.secondEnemy = null;
                                    speak(`${game.combat.enemy.name} remains! Health: ${game.combat.enemy.health}.`);
                                } else {
                                    combatVictory();
                                }
                            }, 1000);
                        });
                        return;
                    }
                }
                
                let damage = game.combat.enemy.damage;
                
                if (game.combat.playerDefending) {
                    damage = Math.floor(damage * 0.5);
                    game.combat.playerDefending = false;
                }
                
                // Mana Shield check
                if (game.combat.manaShieldActive) {
                    const shieldAbsorb = Math.floor(damage * 0.5);
                    const manaCost = shieldAbsorb;
                    
                    if (game.player.mana >= manaCost) {
                        game.player.mana -= manaCost;
                        damage -= shieldAbsorb;
                        messages.push(`Mana Shield absorbs ${shieldAbsorb} damage using ${manaCost} mana!`);
                    } else {
                        messages.push('Mana Shield fizzles - not enough mana!');
                    }
                    game.combat.manaShieldActive = false;
                }
                
                const reducedDamage = Math.max(1, damage - game.player.defense);
                game.player.health -= reducedDamage;
                
                messages.push(`${game.combat.enemy.name} attacks for ${reducedDamage} damage!`);
            }
            
            if (game.combat.secondEnemy && game.combat.secondEnemy.health > 0) {
                if (game.combat.secondEnemy.frozen) {
                    if (game.combat.secondEnemy.timestopTurns) {
                        game.combat.secondEnemy.timestopTurns--;
                        if (game.combat.secondEnemy.timestopTurns <= 0) {
                            game.combat.secondEnemy.frozen = false;
                            game.combat.secondEnemy.timestopTurns = 0;
                        }
                    } else {
                        game.combat.secondEnemy.frozen = false;
                    }
                    messages.push(`${game.combat.secondEnemy.name} is frozen and cannot act!`);
                } else {
                    if (game.combat.secondEnemy.regenerate) {
                        game.combat.secondEnemy.health += game.combat.secondEnemy.regenerate;
                        messages.push(`${game.combat.secondEnemy.name} regenerates ${game.combat.secondEnemy.regenerate} health!`);
                    }
                    
                    let damage2 = game.combat.secondEnemy.damage;
                    const reducedDamage2 = Math.max(1, damage2 - game.player.defense);
                    game.player.health -= reducedDamage2;
                    messages.push(`${game.combat.secondEnemy.name} attacks for ${reducedDamage2} damage!`);
                }
            }
            
            messages.push(`Your health: ${Math.max(0, game.player.health)}.`);
            
            speakSequence(messages, () => {
                if (game.player.health <= 0) {
                    setTimeout(() => gameOver(), 1000);
                } else {
                    setTimeout(() => speak('What will you do?'), 500);
                }
            });
        }

        function combatVictory() {
            let gold = game.combat.enemy.gold;
            let exp = game.combat.enemy.exp;
            
            if (game.player.specialItems.includes("Merchant's Lucky Coin")) {
                gold = Math.floor(gold * 1.5);
            }
            
            const wasTwoEnemyFight = game.combat.twoEnemyFight || false;
            
            if (wasTwoEnemyFight) {
                exp = exp * 2;
            }
            
            game.player.gold += gold;
            
            if (game.currentRoom.enemy) {
                game.currentRoom.enemy.health = 0;
            }
            if (game.currentRoom.secondEnemy) {
                game.currentRoom.secondEnemy.health = 0;
            }
            
            const messages = [
                `${game.combat.enemy.name} defeated!`,
                `You gain ${gold} gold and ${exp} experience!`
            ];
            if (wasTwoEnemyFight) {
                messages.push(`Double experience for defeating 2 enemies!`);
            }
            
            const strengthEffect = game.player.activeEffects.find(e => e.type === 'strength');
            if (strengthEffect) {
                strengthEffect.battles--;
                if (strengthEffect.battles <= 0) {
                    game.player.activeEffects = game.player.activeEffects.filter(e => e.type !== 'strength');
                    messages.push(`Giant Strength effect has worn off.`);
                }
            }
            
            const clarityEffect = game.player.activeEffects.find(e => e.type === 'clarity');
            if (clarityEffect) {
                clarityEffect.battles--;
                if (clarityEffect.battles <= 0) {
                    game.player.activeEffects = game.player.activeEffects.filter(e => e.type !== 'clarity');
                    messages.push(`Clarity effect has worn off.`);
                }
            }
            
            speakSequence(messages, () => {
                game.combat = null;
                game.phase = 'exploration';
                gainExperience(exp);
                
                if (game.currentRoom.type === 'boss') {
                    setTimeout(() => dungeonComplete(), 1500);
                } else {
                    setTimeout(() => speak('What will you do next?'), 1000);
                }
            });
        }

        function dungeonComplete() {
            speakSequence([
                'You defeated the boss!',
                'The dungeon level is cleared!',
                'Seek the stairs to descend deeper!',
                `You are now level ${game.player.level} with ${game.player.gold} gold.`
            ]);
        }

        function gameOver() {
            const reviveEffect = game.player.activeEffects.find(e => e.type === 'revive');
            if (reviveEffect && reviveEffect.uses > 0) {
                reviveEffect.uses--;
                game.player.activeEffects = game.player.activeEffects.filter(e => e.type !== 'revive');
                game.player.health = Math.floor(game.player.maxHealth * 0.5);
                
                speakSequence([
                    'You have fallen!',
                    'But the Elixir of Immortality revives you!',
                    `You return with ${game.player.health} health!`,
                    'What will you do?'
                ]);
                return;
            }
            
            speakSequence([
                'You have been defeated.',
                'Your adventure ends here.',
                `You reached level ${game.player.level} and collected ${game.player.gold} gold.`,
                'Game over. Refresh to play again.'
            ]);
        }
        function castSpell(command) {
            if (!game.combat) {
                speak('You can only cast spells in combat.');
                return;
            }

            let spellToCast = null;

            for (let ability of abilities) {
                if (command.includes(ability.name.toLowerCase()) && game.player.learnedAbilities.includes(ability.name)) {
                    spellToCast = ability;
                    break;
                }
            }

            if (!spellToCast) {
                const learned = game.player.learnedAbilities.join(', ');
                if (learned) {
                    speak(`You know: ${learned}. Say which spell to cast.`);
                } else {
                    speak('You have not learned any spells yet. Find ability books in chests.');
                }
                return;
            }

            let spellCost = spellToCast.cost;
            
            // Level-based cost scaling after level 10
            if (game.dungeon.currentLevel > 10) {
                spellCost = Math.floor(spellCost * (1 + (game.dungeon.currentLevel - 10) * 0.1));
            }
            
            const clarityEffect = game.player.activeEffects.find(e => e.type === 'clarity');
            if (clarityEffect) {
                spellCost = Math.floor(spellCost * 0.5);
            }

            if (game.player.mana < spellCost) {
                speak(`Not enough mana. You need ${spellCost} mana.`);
                return;
            }

            game.player.mana -= spellCost;

            // Calculate spell damage with massive scaling after level 10
            let baseDamage = spellToCast.damage;
            let levelBonus = 0;
            
            if (game.dungeon.currentLevel <= 10) {
                levelBonus = game.player.level * (game.player.class === 'mage' ? 6 : 5);
            } else {
                // Massive scaling after level 10
                const baseLevelBonus = 10 * (game.player.class === 'mage' ? 6 : 5);
                const additionalLevels = game.player.level - 10;
                levelBonus = baseLevelBonus + (additionalLevels * (game.player.class === 'mage' ? 15 : 12));
            }
            
            const totalDamage = baseDamage + levelBonus;

            if (spellToCast.type === 'freeze') {
                game.combat.enemy.health -= totalDamage;
                game.combat.enemy.frozen = true;

                speakSequence([
                    `You cast ${spellToCast.name}!`,
                    `Icy shards pierce the ${game.combat.enemy.name} for ${totalDamage} damage!`,
                    `The enemy is frozen solid for 1 turn!`,
                    `${game.combat.enemy.name} has ${Math.max(0, game.combat.enemy.health)} health left.`
                ], () => {
                    if (game.combat.enemy.health <= 0) {
                        setTimeout(() => combatVictory(), 1000);
                    } else {
                        setTimeout(() => enemyTurn(), 1000);
                    }
                });
            } else if (spellToCast.type === 'stun') {
                game.combat.enemy.health -= totalDamage;
                game.combat.enemy.stunned = true;

                let messages = [`You bash with your shield!`];
                messages.push(`${totalDamage} total damage!`);
                messages.push(`${game.combat.enemy.name} is stunned!`);
                messages.push(`${game.combat.enemy.name} has ${Math.max(0, game.combat.enemy.health)} health left.`);

                speakSequence(messages, () => {
                    if (game.combat.enemy.health <= 0) {
                        setTimeout(() => combatVictory(), 1000);
                    } else {
                        setTimeout(() => enemyTurn(), 1000);
                    }
                });
            } else if (spellToCast.type === 'poison') {
                game.combat.enemy.health -= totalDamage;
                const poisonDamage = 15 + Math.floor(game.player.level * 1.5);
                game.combat.enemy.poisoned = { damage: poisonDamage, duration: spellToCast.duration };

                speakSequence([
                    `You coat your blade in deadly poison!`,
                    `${totalDamage} initial damage!`,
                    `Poison will damage ${poisonDamage} per turn for ${spellToCast.duration} turns!`,
                    `${game.combat.enemy.name} has ${Math.max(0, game.combat.enemy.health)} health left.`
                ], () => {
                    if (game.combat.enemy.health <= 0) {
                        setTimeout(() => combatVictory(), 1000);
                    } else {
                        setTimeout(() => enemyTurn(), 1000);
                    }
                });
            } else if (spellToCast.type === 'aoe') {
                game.combat.enemy.health -= totalDamage;
                
                let messages = [
                    `You cast ${spellToCast.name}!`,
                    `${totalDamage} damage to ${game.combat.enemy.name}!`
                ];
                
                if (game.combat.secondEnemy && game.combat.secondEnemy.health > 0) {
                    game.combat.secondEnemy.health -= totalDamage;
                    messages.push(`${totalDamage} damage to ${game.combat.secondEnemy.name}!`);
                }
                
                messages.push(`${game.combat.enemy.name} has ${Math.max(0, game.combat.enemy.health)} health left.`);
                if (game.combat.secondEnemy && game.combat.secondEnemy.health > 0) {
                    messages.push(`${game.combat.secondEnemy.name} has ${Math.max(0, game.combat.secondEnemy.health)} health left.`);
                }
                
                speakSequence(messages, () => {
                    if (game.combat.enemy.health <= 0 && (!game.combat.secondEnemy || game.combat.secondEnemy.health <= 0)) {
                        setTimeout(() => combatVictory(), 1000);
                    } else if (game.combat.enemy.health <= 0 && game.combat.secondEnemy && game.combat.secondEnemy.health > 0) {
                        game.combat.enemy = game.combat.secondEnemy;
                        game.combat.secondEnemy = null;
                        speak(`${game.combat.enemy.name} remains!`, () => {
                            setTimeout(() => enemyTurn(), 1000);
                        });
                    } else {
                        setTimeout(() => enemyTurn(), 1000);
                    }
                });
            } else if (spellToCast.type === 'sneak') {
                game.combat.enemy.health -= totalDamage;
                
                let messages = [`You strike from the shadows!`, `${totalDamage} damage!`];
                messages.push(`The enemy doesn't see you coming!`);
                messages.push(`${game.combat.enemy.name} has ${Math.max(0, game.combat.enemy.health)} health left.`);
                messages.push(`You vanish before they can counter!`);
                
                speakSequence(messages, () => {
                    if (game.combat.enemy.health <= 0) {
                        if (game.combat.secondEnemy && game.combat.secondEnemy.health > 0) {
                            game.combat.enemy = game.combat.secondEnemy;
                            game.combat.secondEnemy = null;
                            setTimeout(() => speak(`${game.combat.enemy.name} remains! Health: ${game.combat.enemy.health}. What will you do?`), 500);
                        } else {
                            setTimeout(() => combatVictory(), 1000);
                        }
                    } else {
                        setTimeout(() => speak('What will you do?'), 500);
                    }
                });
            } else if (spellToCast.type === 'timestop') {
                game.combat.enemy.frozen = true;
                game.combat.enemy.timestopTurns = 2;
                if (game.combat.secondEnemy && game.combat.secondEnemy.health > 0) {
                    game.combat.secondEnemy.frozen = true;
                    game.combat.secondEnemy.timestopTurns = 2;
                }
                speakSequence([
                    `You cast Time Stop!`,
                    `Time freezes around you!`,
                    `All enemies are frozen for 2 turns!`
                ], () => {
                    setTimeout(() => speak('What will you do?'), 500);
                });
            } else if (spellToCast.type === 'rage') {
                const weaponData = equipment.weapons.find(w => w.name === game.player.weapon) ||
                                   merchantItems.find(i => i.name === game.player.weapon && i.type === 'weapon');
                const weaponAttack = weaponData ? weaponData.attack : 0;
                let baseDamage = game.player.baseAttack + weaponAttack;
                baseDamage += (game.player.level - 1) * 5;
                const tripleStrike = baseDamage * 3;
                
                game.combat.enemy.health -= tripleStrike;
                
                speakSequence([
                    `You enter a berserker rage!`,
                    `You strike three times for ${tripleStrike} total damage!`,
                    `${game.combat.enemy.name} has ${Math.max(0, game.combat.enemy.health)} health left.`
                ], () => {
                    if (game.combat.enemy.health <= 0) {
                        setTimeout(() => combatVictory(), 1000);
                    } else {
                        setTimeout(() => enemyTurn(), 1000);
                    }
                });
            } else if (spellToCast.type === 'vanish') {
                game.combat.playerShadowmelded = true;
                speakSequence([
                    `You meld into the shadows!`,
                    `You become invisible!`,
                    `Your next attack will deal 200% damage!`
                ], () => {
                    setTimeout(() => speak('What will you do?'), 500);
                });
            } else if (spellToCast.type === 'mark') {
                game.combat.enemy.health -= totalDamage;
                game.combat.enemy.deathMarked = true;
                
                speakSequence([
                    `You cast Death Mark!`,
                    `${totalDamage} damage!`,
                    `The enemy is marked! They take 50% more damage!`,
                    `${game.combat.enemy.name} has ${Math.max(0, game.combat.enemy.health)} health left.`
                ], () => {
                    if (game.combat.enemy.health <= 0) {
                        setTimeout(() => combatVictory(), 1000);
                    } else {
                        setTimeout(() => enemyTurn(), 1000);
                    }
                });
            } else {
                game.combat.enemy.health -= totalDamage;

                speakSequence([
                    `You cast ${spellToCast.name}!`,
                    `${totalDamage} damage!`,
                    `${game.combat.enemy.name} has ${Math.max(0, game.combat.enemy.health)} health left.`
                ], () => {
                    if (game.combat.enemy.health <= 0) {
                        setTimeout(() => combatVictory(), 1000);
                    } else {
                        setTimeout(() => enemyTurn(), 1000);
                    }
                });
            }
        }

        function getRandomDescription(roomType) {
            const descriptions = roomTypes[roomType].descriptions;
            return descriptions[Math.floor(Math.random() * descriptions.length)];
        }

        function scaleEnemyForLevel(enemy, level) {
            const scaleFactor = 1 + ((level - 1) * 0.3);
            return {
                ...enemy,
                health: Math.floor(enemy.health * scaleFactor),
                damage: Math.floor(enemy.damage * scaleFactor),
                gold: Math.floor(enemy.gold * scaleFactor),
                exp: Math.floor(enemy.exp * scaleFactor),
                regenerate: enemy.regenerate
            };
        }

        function generateDungeon() {
            const size = game.dungeon.size;
            const currentLevel = game.dungeon.currentLevel;
            game.dungeon.grid = {};
            
            const centerX = 6; 
            const centerY = 6;
            
            for (let x = 0; x < size; x++) {
                for (let y = 0; y < size; y++) {
                    const key = `${x},${y}`;
                    const distanceX = Math.abs(x - centerX);
                    const distanceY = Math.abs(y - centerY);
                    const distanceFromCenter = distanceX + distanceY;
                    
                    let roomData = { visited: false, searched: false, hasChest: false, fountainUsed: false };

                    if (x === centerX && y === centerY) {
                        game.dungeon.grid[key] = { 
                            type: 'entrance', 
                            description: getRandomDescription('entrance'),
                            ...roomData
                        };
                    } else if (x === size - 1 && y === size - 1) { 
                        let bossEnemy = null;
                        
                        if (currentLevel >= 20) {
                            bossEnemy = scaleEnemyForLevel(enemies.apocalypseTitan, currentLevel);
                        } else if (currentLevel >= 10) {
                            bossEnemy = scaleEnemyForLevel(enemies.voidEmperor, currentLevel);
                        } else {
                            bossEnemy = scaleEnemyForLevel(enemies.dragon, currentLevel);
                        }
                        
                        game.dungeon.grid[key] = {
                            type: 'boss',
                            description: getRandomDescription('boss'),
                            ...roomData,
                            hasChest: true,
                            enemy: bossEnemy
                        };
                    } else if (x === size - 1 && y === size - 2) { 
                        game.dungeon.grid[key] = { 
                            type: 'stairs', 
                            description: getRandomDescription('stairs'),
                            ...roomData 
                        };
                    } else {
                        let roomType = null;
                        let enemyType = null;
                        
                        const roll = Math.random();
                        const isElite = currentLevel >= 2 && Math.random() < 0.15;
                        
                        if (Math.random() < 0.1) {
                            game.dungeon.grid[key] = {
                                type: 'merchant',
                                description: getRandomDescription('merchant'),
                                ...roomData
                            };
                            continue;
                        }
                        
                        if (distanceFromCenter >= 7) {
                            if (roll < 0.5) {
                                roomType = 'enemy';
                                if (currentLevel >= 20) {
                                    if (Math.random() < 0.4) {
                                        enemyType = 'harbingerOfRagnarok';
                                    } else {
                                        enemyType = Math.random() < 0.5 ? 'voidBeast' : 'titanLord';
                                    }
                                } else if (currentLevel >= 10) {
                                    if (Math.random() < 0.4) {
                                        enemyType = Math.random() < 0.5 ? 'cosmicHorror' : 'titanLord';
                                    } else if (isElite) {
                                        enemyType = 'demonLord';
                                    } else {
                                        enemyType = Math.random() < 0.5 ? 'ancientDragon' : 'voidBeast';
                                    }
                                } else if (currentLevel >= 5) {
                                    if (Math.random() < 0.4) {
                                        enemyType = Math.random() < 0.5 ? 'hydra' : 'phoenixGuardian';
                                    } else if (isElite) {
                                        enemyType = 'archDemon';
                                    } else {
                                        enemyType = Math.random() < 0.5 ? 'demon' : 'vampire';
                                    }
                                } else if (isElite) {
                                    enemyType = currentLevel >= 3 ? 'archDemon' : 'elderTroll';
                                } else if (currentLevel >= 3) {
                                    enemyType = Math.random() < 0.5 ? 'demon' : 'vampire';
                                } else {
                                    enemyType = Math.random() < 0.5 ? 'troll' : 'wraith';
                                }
                            } else if (roll < 0.7) {
                                roomType = 'treasure';
                                roomData.hasChest = true;
                            } else if (roll < 0.8) {
                                roomType = 'fountain';
                            } else {
                                roomType = 'crypt';
                                roomData.hasChest = Math.random() < 0.3;
                            }
                        } else if (distanceFromCenter >= 4) {
                            if (roll < 0.45) {
                                roomType = 'enemy';
                                if (currentLevel >= 20) {
                                    if (Math.random() < 0.3) {
                                        enemyType = 'cosmicHorror';
                                    } else if (isElite) {
                                        enemyType = 'voidBeast';
                                    } else {
                                        enemyType = Math.random() < 0.5 ? 'demonLord' : 'ancientDragon';
                                    }
                                } else if (currentLevel >= 10) {
                                    if (Math.random() < 0.3) {
                                        enemyType = 'voidBeast';
                                    } else if (isElite) {
                                        enemyType = 'ancientDragon';
                                    } else {
                                        enemyType = Math.random() < 0.5 ? 'demonLord' : 'lichKing';
                                    }
                                } else if (currentLevel >= 5) {
                                    if (Math.random() < 0.3) {
                                        enemyType = 'lichKing';
                                    } else if (isElite) {
                                        enemyType = 'elderTroll';
                                    } else {
                                        enemyType = Math.random() < 0.5 ? 'wraith' : 'troll';
                                    }
                                } else if (isElite) {
                                    enemyType = currentLevel >= 2 ? 'ancientWraith' : 'orcChieftain';
                                } else if (currentLevel >= 2) {
                                    enemyType = Math.random() < 0.5 ? 'wraith' : 'troll';
                                } else {
                                    enemyType = Math.random() < 0.6 ? 'orc' : 'skeleton';
                                }
                            } else if (roll < 0.65) {
                                roomType = 'treasure';
                                roomData.hasChest = true;
                            } else if (roll < 0.75) {
                                roomType = 'trap';
                            } else if (roll < 0.8) {
                                roomType = 'fountain';
                            } else {
                                roomType = 'empty';
                                roomData.hasChest = Math.random() < 0.2;
                            }
                        } else {
                            if (roll < 0.35) {
                                roomType = 'enemy';
                                if (isElite) {
                                    enemyType = 'orcChieftain';
                                } else if (currentLevel >= 2) {
                                    enemyType = Math.random() < 0.5 ? 'orc' : 'skeleton';
                                } else {
                                    enemyType = 'goblin';
                                }
                            } else if (roll < 0.55) {
                                roomType = 'treasure';
                                roomData.hasChest = true;
                            } else if (roll < 0.6) {
                                roomType = 'fountain';
                            } else {
                                roomType = 'empty';
                                roomData.hasChest = Math.random() < 0.15;
                            }
                        }
                        
                        if (roomType === 'enemy') {
                            let scaledEnemy = scaleEnemyForLevel(enemies[enemyType], currentLevel);
                            
                            if (currentLevel >= 3 && Math.random() < 0.2) {
                                game.dungeon.grid[key] = {
                                    type: 'enemy',
                                    description: getRandomDescription('enemy') + ' Two creatures lurk here!',
                                    ...roomData,
                                    enemy: scaledEnemy,
                                    secondEnemy: scaleEnemyForLevel(enemies[enemyType], currentLevel)
                                };
                            } else {
                                game.dungeon.grid[key] = {
                                    type: 'enemy',
                                    description: getRandomDescription('enemy'),
                                    ...roomData,
                                    enemy: scaledEnemy
                                };
                            }
                        } else {
                            game.dungeon.grid[key] = {
                                type: roomType,
                                description: getRandomDescription(roomType),
                                ...roomData
                            };
                        }
                    }
                }
            }
            // Secret room generation
            if (Math.random() < 0.05) {
                const secretX = Math.floor(Math.random() * size);
                const secretY = Math.floor(Math.random() * size);
                const secretKey = `${secretX},${secretY}`;
                
                if (game.dungeon.grid[secretKey] && game.dungeon.grid[secretKey].type === 'empty') {
                    game.dungeon.grid[secretKey] = {
                        type: 'treasure',
                        description: 'a hidden treasure vault! Riches beyond imagination fill this secret chamber.',
                        visited: false,
                        searched: false,
                        hasChest: true,
                        fountainUsed: false,
                        isSecret: true
                    };
                    game.dungeon.hasSecretRoom = true;
                    game.dungeon.secretRoom = { x: secretX, y: secretY };
                }
            }
            
            game.currentRoom = game.dungeon.grid[`${centerX},${centerY}`];
            game.player.position = { x: centerX, y: centerY };
        }

        function move(direction) {
            const { x, y } = game.player.position;
            let newX = x, newY = y;
            
            if (direction === 'north') newY--;
            else if (direction === 'south') newY++;
            else if (direction === 'east') newX++;
            else if (direction === 'west') newX--;
            
            const key = `${newX},${newY}`;
            
            if (newX < 0 || newX >= game.dungeon.size || newY < 0 || newY >= game.dungeon.size) {
                speak('You cannot go that way. There is a wall.');
                return;
            }
            
            if (!game.dungeon.grid[key]) {
                speak('There is nothing in that direction.');
                return;
            }
            
            game.player.position = { x: newX, y: newY };
            game.currentRoom = game.dungeon.grid[key];
            game.currentRoom.visited = true;
            
            describeRoom();
        }

        function describeRoom() {
            const room = game.currentRoom;
            let messages = [`You enter ${room.description}`];
            
            if (room.type === 'enemy' && room.enemy && room.enemy.health > 0) {
                messages.push(`A ${room.enemy.name} blocks your path!`);
                if (room.secondEnemy && room.secondEnemy.health > 0) {
                    messages.push(`A ${room.secondEnemy.name} joins the fight!`);
                }
                speakSequence(messages, () => {
                    setTimeout(() => startCombat(room.enemy, room.secondEnemy), 1000);
                });
            } else if (room.type === 'boss' && room.enemy && room.enemy.health > 0) {
                messages.push(`The dungeon boss awaits!`);
                speakSequence(messages, () => {
                    setTimeout(() => startCombat(room.enemy), 1000);
                });
            } else {
                if (room.hasChest && !room.searched) {
                    messages.push('You see a treasure chest. Say "open chest" to loot it.');
                }
                if (room.type === 'fountain' && !room.fountainUsed) {
                    messages.push('A magical fountain bubbles here. Say "fountain" to drink.');
                }
                if (room.type === 'stairs') {
                    messages.push('Ancient stairs descend deeper. Say "stairs" to go down.');
                }
                if (room.type === 'merchant') {
                    messages.push('Say "merchant" to trade.');
                }
                speakSequence(messages);
            }
        }

        function searchRoom() {
            if (game.currentRoom.searched) {
                speak('You already searched this room.');
                return;
            }
            
            game.currentRoom.searched = true;
            
            const findChance = game.player.class === 'rogue' ? 0.4 : 0.2;
            
            if (Math.random() < findChance) {
                const lootTable = [...rings, ...amulets];
                const loot = lootTable[Math.floor(Math.random() * lootTable.length)];
                
                if (loot.minLevel && game.dungeon.currentLevel < loot.minLevel) {
                    const goldFound = Math.floor(Math.random() * 30) + 10;
                    game.player.gold += goldFound;
                    speak(`You search carefully and find ${goldFound} gold hidden in the shadows.`);
                } else {
                    game.player.inventory.push(loot.name);
                    speak(`You search carefully and find a ${loot.name}! ${loot.effect}.`);
                }
            } else {
                speak('You search the room but find nothing of value.');
            }
        }

        function openChest() {
            if (!game.currentRoom.hasChest) {
                speak('There is no chest here.');
                return;
            }
            
            if (game.currentRoom.searched) {
                speak('You already opened this chest.');
                return;
            }
            
            game.currentRoom.searched = true;
            
            const level = game.dungeon.currentLevel;
            const isBoss = game.currentRoom.type === 'boss';
            const isSecret = game.currentRoom.isSecret;
            
            let lootMessages = ['You open the chest and find:'];
            
            if (isBoss) {
                const bossGold = 200 + (level * 50);
                game.player.gold += bossGold;
                lootMessages.push(`${bossGold} gold!`);
                
                const tierWeapons = equipment.weapons.filter(w => 
                    (!w.minLevel || level >= w.minLevel) && 
                    w.class === game.player.class
                ).sort((a, b) => b.value - a.value).slice(0, 3);
                
                if (tierWeapons.length > 0) {
                    const weapon = tierWeapons[Math.floor(Math.random() * tierWeapons.length)];
                    game.player.inventory.push(weapon.name);
                    lootMessages.push(`${weapon.name}!`);
                }
                
                const tierArmor = equipment.armor.filter(a => 
                    (!a.minLevel || level >= a.minLevel) && 
                    a.class === game.player.class
                ).sort((a, b) => b.value - a.value).slice(0, 3);
                
                if (tierArmor.length > 0) {
                    const armor = tierArmor[Math.floor(Math.random() * tierArmor.length)];
                    game.player.inventory.push(armor.name);
                    lootMessages.push(`${armor.name}!`);
                }
                
                for (let i = 0; i < 3; i++) {
                    game.player.inventory.push('Greater Health Potion');
                }
                for (let i = 0; i < 3; i++) {
                    game.player.inventory.push('Greater Mana Potion');
                }
                lootMessages.push('3 Greater Health Potions and 3 Greater Mana Potions!');
                
                const classAbilities = abilities.filter(a => 
                    a.class === game.player.class && 
                    (!a.minLevel || level >= a.minLevel)
                );
                if (classAbilities.length > 0) {
                    const ability = classAbilities[Math.floor(Math.random() * classAbilities.length)];
                    game.player.inventory.push(ability.name);
                    lootMessages.push(`Ability book: ${ability.name}!`);
                }
            } else if (isSecret) {
                const secretGold = 500 + (level * 100);
                game.player.gold += secretGold;
                lootMessages.push(`${secretGold} gold!`);
                
                const legendaryItems = [
                    ...equipment.weapons.filter(w => w.value >= 1000 && w.class === game.player.class),
                    ...equipment.armor.filter(a => a.value >= 1000 && a.class === game.player.class)
                ];
                
                if (legendaryItems.length > 0) {
                    const item = legendaryItems[Math.floor(Math.random() * legendaryItems.length)];
                    game.player.inventory.push(item.name);
                    lootMessages.push(`Legendary ${item.name}!`);
                }
            } else {
                const baseGold = 30 + (level * 10);
                const gold = Math.floor(Math.random() * baseGold) + baseGold;
                game.player.gold += gold;
                lootMessages.push(`${gold} gold!`);
                
                if (Math.random() < 0.5) {
                    const potion = Math.random() < 0.5 ? 'Health Potion' : 'Mana Potion';
                    game.player.inventory.push(potion);
                    lootMessages.push(`A ${potion}!`);
                }
                
                if (Math.random() < 0.3) {
                    const treasure = treasures[Math.floor(Math.random() * treasures.length)];
                    game.player.inventory.push(treasure.name);
                    lootMessages.push(`A ${treasure.name}!`);
                }
                
                if (Math.random() < 0.25) {
                    const validEquipment = [
                        ...equipment.weapons.filter(w => (!w.minLevel || level >= w.minLevel) && w.class === game.player.class),
                        ...equipment.armor.filter(a => (!a.minLevel || level >= a.minLevel) && a.class === game.player.class),
                        ...equipment.helmets.filter(h => (!h.minLevel || level >= h.minLevel) && (!h.class || h.class === game.player.class)),
                        ...equipment.gloves.filter(g => (!g.minLevel || level >= g.minLevel) && (!g.class || g.class === game.player.class)),
                        ...equipment.boots.filter(b => (!b.minLevel || level >= b.minLevel) && (!b.class || b.class === game.player.class))
                    ];
                    
                    if (game.player.class === 'warrior') {
                        validEquipment.push(...equipment.shields.filter(s => !s.minLevel || level >= s.minLevel));
                    }
                    
                    if (validEquipment.length > 0) {
                        const item = validEquipment[Math.floor(Math.random() * validEquipment.length)];
                        game.player.inventory.push(item.name);
                        lootMessages.push(`${item.name}!`);
                    }
                }
                
                if (Math.random() < 0.15) {
                    const classAbilities = abilities.filter(a => 
                        a.class === game.player.class && 
                        (!a.minLevel || level >= a.minLevel)
                    );
                    if (classAbilities.length > 0) {
                        const ability = classAbilities[Math.floor(Math.random() * classAbilities.length)];
                        game.player.inventory.push(ability.name);
                        lootMessages.push(`Ability book: ${ability.name}!`);
                    }
                }
            }
            
            speakSequence(lootMessages);
        }

        function useFountain() {
            if (game.currentRoom.type !== 'fountain') {
                speak('There is no fountain here.');
                return;
            }
            
            if (game.currentRoom.fountainUsed) {
                speak('The fountain has run dry.');
                return;
            }
            
            game.currentRoom.fountainUsed = true;
            game.player.health = game.player.maxHealth;
            game.player.mana = game.player.maxMana;
            
            speak('You drink from the magical fountain. You are fully healed and restored!');
        }

        function useStairs() {
            if (game.currentRoom.type !== 'stairs') {
                speak('There are no stairs here.');
                return;
            }
            
            game.dungeon.currentLevel++;
            
            speakSequence([
                `You descend to dungeon level ${game.dungeon.currentLevel}.`,
                'The dungeon grows darker and more dangerous.',
                'Generating new dungeon...'
            ], () => {
                setTimeout(() => {
                    generateDungeon();
                    speak('You stand at a new entrance. What will you do?');
                }, 1000);
            });
        }

        function meditate() {
            const manaRestore = Math.floor(game.player.maxMana * 0.3);
            const oldMana = game.player.mana;
            game.player.mana = Math.min(game.player.maxMana, game.player.mana + manaRestore);
            const actualRestore = game.player.mana - oldMana;
            
            speak(`You meditate and restore ${actualRestore} mana. Current mana: ${game.player.mana}.`);
        }

        function characterStatus() {
            const weaponData = equipment.weapons.find(w => w.name === game.player.weapon) ||
                               merchantItems.find(i => i.name === game.player.weapon && i.type === 'weapon');
            const totalAttack = game.player.baseAttack + (weaponData ? weaponData.attack : 0);
            
            let messages = [
                `Level ${game.player.level} ${game.player.class}.`,
                `Health: ${game.player.health} of ${game.player.maxHealth}.`,
                `Mana: ${game.player.mana} of ${game.player.maxMana}.`,
                `Attack: ${totalAttack}. Defense: ${game.player.defense}.`,
                `Gold: ${game.player.gold}.`,
                `Experience: ${game.player.experience} of ${game.player.experienceToNext}.`,
                `Dungeon level: ${game.dungeon.currentLevel}.`
            ];
            
            if (game.player.equippedRings.length > 0) {
                const ringCounts = {};
                game.player.equippedRings.forEach(ring => ringCounts[ring] = (ringCounts[ring] || 0) + 1);
                const ringList = Object.entries(ringCounts).map(([ring, count]) => 
                    count > 1 ? `${ring} x${count}` : ring
                );
                messages.push(`Rings: ${ringList.join(', ')}.`);
            }
            
            if (game.player.equippedAmulet) {
                messages.push(`Amulet: ${game.player.equippedAmulet}.`);
            }
            
            if (game.player.leftBracelet || game.player.rightBracelet) {
                let braceletMsg = 'Bracelets:';
                if (game.player.leftBracelet) braceletMsg += ` Left: ${game.player.leftBracelet}.`;
                if (game.player.rightBracelet) braceletMsg += ` Right: ${game.player.rightBracelet}.`;
                messages.push(braceletMsg);
            }
            
            if (game.player.activeEffects.length > 0) {
                const effects = game.player.activeEffects.map(e => {
                    if (e.type === 'revive') return 'Immortality active';
                    if (e.type === 'strength') return `Giant Strength: ${e.battles} battles left`;
                    if (e.type === 'clarity') return `Clarity: ${e.battles} battles left`;
                    return e.type;
                });
                messages.push(`Active effects: ${effects.join(', ')}.`);
            }
            
            if (game.player.specialItems.length > 0) {
                messages.push(`Special items: ${game.player.specialItems.join(', ')}.`);
            }
            
            speakSequence(messages);
        }

        function listInventory() {
            if (game.player.inventory.length === 0) {
                speak('Your inventory is empty.');
                return;
            }
            
            const itemCounts = {};
            game.player.inventory.forEach(item => {
                itemCounts[item] = (itemCounts[item] || 0) + 1;
            });
            
            const itemList = Object.entries(itemCounts).map(([item, count]) => 
                count > 1 ? `${item} x${count}` : item
            );
            
            speak(`You have: ${itemList.join(', ')}.`);
        }

        function listCommands() {
            const messages = [
                'Movement: north, south, east, west.',
                'Actions: look, search, open chest, use fountain, go down stairs, meditate.',
                'Character: status, inventory.',
                'Equipment: equip, wear ring, equip amulet, remove ring.',
                'Abilities: read book, unlearn ability.',
                'Combat: attack, defend, special, cast spell, use potion, flee.',
                'Merchant: merchant, buy, quantity, sell junk.',
                'Junk: add to junk, view junk, clear junk.',
                'System: save game, load game, hint, help.'
            ];
            speakSequence(messages);
        }

        function giveHint() {
            const hints = [
                'Search rooms to find hidden treasures.',
                'Fountains fully restore health and mana.',
                'Merchants sell powerful items.',
                'Boss rooms contain the best loot.',
                'Save your game regularly.',
                'Level up by gaining experience.',
                'Rings can be stacked, up to 2 of the same type.',
                'Use lockpicks as a rogue to open chests easily.',
                'Ability books teach you new spells.',
                'The junk bag helps you sell items quickly.',
                'Special potions provide powerful temporary buffs.',
                'Explore thoroughly to find secret rooms.',
                'Higher dungeon levels have better rewards.',
                'Stack rings and equipment for maximum power.',
                'Meditation restores 30% of your max mana.'
            ];
            
            const hint = hints[Math.floor(Math.random() * hints.length)];
            speak(`Hint: ${hint}`);
        }

        function showHelp() {
            speakSequence([
                'This is Echo Dungeon, a voice-controlled adventure.',
                'Tap the screen and speak commands.',
                'Say "commands" for a full list.',
                'Say "hint" for helpful tips.',
                'Say "status" to check your character.',
                'Say "save game" to get a save code.',
                'Good luck, adventurer!'
            ]);
        }

        function saveGame() {
            const saveData = {
                player: game.player,
                dungeon: {
                    currentLevel: game.dungeon.currentLevel,
                    size: game.dungeon.size
                }
            };
            
            const jsonString = JSON.stringify(saveData);
            const pin = btoa(jsonString).substring(0, 8);
            
            try {
                localStorage.setItem(`echoDungeon_${pin}`, jsonString);
                speak(`Your save code is: ${pin.split('').join(' ')}. Write this down!`);
            } catch (e) {
                speak(`Save code: ${pin.split('').join(' ')}. Note: Could not auto-save.`);
            }
        }

        function loadGame(pin) {
            try {
                const cleanPin = pin.toUpperCase();
                const saveData = localStorage.getItem(`echoDungeon_${cleanPin}`);
                
                if (!saveData) {
                    speak('Invalid save code. Please try again.');
                    game.phase = 'init';
                    return;
                }
                
                const data = JSON.parse(saveData);
                
                game.player = data.player;
                game.dungeon.currentLevel = data.dungeon.currentLevel;
                game.dungeon.size = data.dungeon.size;
                
                game.needsClass = false;
                game.started = true;
                game.phase = 'exploration';
                
                generateDungeon();
                
                speakSequence([
                    'Game loaded successfully!',
                    `Welcome back, level ${game.player.level} ${game.player.class}.`,
                    `You are on dungeon level ${game.dungeon.currentLevel}.`
                ], () => {
                    setTimeout(() => describeRoom(), 1000);
                });
            } catch (e) {
                speak('Error loading game. Invalid save code.');
                game.phase = 'init';
            }
        }

        function handleClick() {
            if (!game.initialized) {
                game.initialized = true;
                checkBrowserSupport();
                micButton.classList.remove('start-button');
                
                const messages = [
                    'Welcome to Echo Dungeon.',
                    'A voice-controlled adventure.',
                    'Choose your class.',
                    'Say warrior for strength.',
                    'Say mage for magic.',
                    'Say rogue for stealth.'
                ];
                
                speakSequence(messages);
                return;
            }
            
            startListening();
        }

        window.addEventListener('load', () => {
            displayText('Tap anywhere to begin');
        });
    </script>
</body>
</html>
        