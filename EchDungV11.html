<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Echo Dungeon V11 - Part 1</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #111;
        }
        #micButton {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: #222;
            border: none;
            cursor: pointer;
            transition: background 0.3s;
        }
        #micButton:active {
            background: #444;
        }
        .listening {
            background: #004400 !important;
        }
        .start-button {
            background: #000044 !important;
        }
        #textDisplay {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border: 0;
        }
    </style>
</head>
<body>
    <div id="textDisplay" role="status" aria-live="polite"></div>
    <button id="micButton" class="start-button" onclick="handleClick()" aria-label="Voice command button - Tap to speak"></button>

    <script>
        const micButton = document.getElementById('micButton');
        const textDisplay = document.getElementById('textDisplay');

        function displayText(text) {
            textDisplay.innerHTML = text;
        }

        let browserSupport = {
            speechSynthesis: false,
            speechRecognition: false,
            https: false
        };

        function checkBrowserSupport() {
            browserSupport.https = window.location.protocol === 'https:' || window.location.hostname === 'localhost';
            browserSupport.speechSynthesis = !!(window.speechSynthesis && window.SpeechSynthesisUtterance);
            browserSupport.speechRecognition = !!(window.webkitSpeechRecognition || window.SpeechRecognition);
        }

        const game = {
            player: {
                class: '',
                level: 1,
                experience: 0,
                experienceToNext: 100,
                health: 100,
                maxHealth: 100,
                mana: 50,
                maxMana: 50,
                gold: 25,
                inventory: [],
                equippedRings: [],
                equippedBracelets: [],
                learnedAbilities: [],
                equippedAmulet: '',
                equippedShoulderItem: '',
                position: { x: 6, y: 6 },
                baseAttack: 15,
                defense: 0,
                weapon: '',
                armor: '',
                shield: '',
                helmet: '',
                gloves: '',
                boots: '',
                specialItems: [],
                activeEffects: [],
                junkBag: [],
                inspectMode: false,
                inspectItem: null
            },
            dungeon: {
                grid: {},
                size: 12,
                secretRoom: null,
                hasSecretRoom: false,
                currentLevel: 1 
            },
            currentRoom: null,
            combat: null,
            listening: false,
            started: false,
            needsClass: true,
            initialized: false,
            phase: 'init',
            merchantOpen: false
        };

        const classes = {
            warrior: {
                name: 'Warrior',
                health: 120,
                maxHealth: 120,
                mana: 30,
                maxMana: 30,
                gold: 50,
                items: ['Steel Sword', 'Large Health Potion', 'Large Health Potion', 'Chainmail', 'Iron Shield'],
                special: { name: 'Power Strike', damage: 100, cost: 15, type: 'damage' }
            },
            mage: { 
                name: 'Mage',
                health: 80,
                maxHealth: 80,
                mana: 100,
                maxMana: 100,
                gold: 75,
                items: ['Mystic Staff', 'Large Mana Potion', 'Large Health Potion', 'Enchanted Robes'],
                special: { name: 'Fireball', damage: 100, cost: 20, type: 'damage' } 
            },
            rogue: {
                name: 'Rogue',
                health: 100,
                maxHealth: 100,
                mana: 60,
                maxMana: 60,
                gold: 100,
                items: ['Shadow Daggers', 'Lockpicks', 'Large Health Potion', 'Shadow Leather'],
                special: { name: 'Backstab', damage: 75, cost: 15, type: 'damage' }
            }
        };

        const equipment = {
            weapons: [
                { name: 'Steel Sword', attack: 12, class: 'warrior', value: 100 },
                { name: 'Mystic Staff', attack: 8, mana: 15, class: 'mage', value: 150 },
                { name: 'Shadow Daggers', attack: 10, class: 'rogue', value: 120 },
                { name: 'Legendary Greatsword', attack: 25, class: 'warrior', value: 300 },
                { name: 'Archmage Staff', attack: 12, mana: 25, class: 'mage', value: 350 },
                { name: 'Vorpal Daggers', attack: 16, class: 'rogue', value: 320 },
                { name: 'Demon Slayer Blade', attack: 40, class: 'warrior', value: 500 },
                { name: 'Staff of the Cosmos', attack: 15, mana: 35, class: 'mage', value: 600 },
                { name: 'Ethereal Blades', attack: 22, class: 'rogue', value: 550 },
                { name: 'Godslayer Greatsword', attack: 30, class: 'warrior', value: 1000, minLevel: 6 },
                { name: 'Staff of Eternity', attack: 20, mana: 45, class: 'mage', value: 1200, minLevel: 6 },
                { name: 'Nightfall Daggers', attack: 32, class: 'rogue', value: 1100, minLevel: 6 },
                { name: 'Excalibur', attack: 50, class: 'warrior', value: 2000, minLevel: 8 },
                { name: 'Infinity Staff', attack: 25, mana: 60, class: 'mage', value: 2500, minLevel: 8 },
                { name: 'Oblivion Blades', attack: 42, class: 'rogue', value: 2200, minLevel: 8 },
                { name: 'Sword of the Ancients', attack: 100, class: 'warrior', value: 5000, minLevel: 10 },
                { name: 'Cosmic Scepter', attack: 70, mana: 80, class: 'mage', value: 6000, minLevel: 10 },
                { name: 'Void Assassin Blades', attack: 85, class: 'rogue', value: 5500, minLevel: 10 },
                { name: 'Blade of Titans', attack: 200, class: 'warrior', value: 10000, minLevel: 20 },
                { name: 'Staff of Creation', attack: 140, mana: 160, class: 'mage', value: 12000, minLevel: 20 },
                { name: 'Reality Ripper Daggers', attack: 170, class: 'rogue', value: 11000, minLevel: 20 },
                { name: 'Worldbreaker Sword', attack: 400, class: 'warrior', value: 20000, minLevel: 30 },
                { name: 'Genesis Core Staff', attack: 280, mana: 320, class: 'mage', value: 24000, minLevel: 30 },
                { name: 'Entropy Blades', attack: 340, class: 'rogue', value: 22000, minLevel: 30 }
            ],
            armor: [
                { name: 'Chainmail', defense: 10, class: 'warrior', value: 100 },
                { name: 'Enchanted Robes', defense: 5, class: 'mage', value: 120 },
                { name: 'Shadow Leather', defense: 6, class: 'rogue', value: 110 },
                { name: 'Dragonscale Plate', defense: 15, class: 'warrior', value: 350 },
                { name: 'Arcane Vestments', defense: 12, class: 'mage', value: 380 },
                { name: 'Phantom Suit', defense: 13, class: 'rogue', value: 360 },
                { name: 'Titanium Fortress', defense: 27, class: 'warrior', value: 550 },
                { name: 'Celestial Robes', defense: 18, mana: 25, class: 'mage', value: 600 },
                { name: 'Void Cloak', defense: 20, class: 'rogue', value: 580 },
                { name: 'Divine Plate', defense: 50, class: 'warrior', value: 1200, minLevel: 6 },
                { name: 'Robes of the Archmage', defense: 40, class: 'mage', value: 1100, minLevel: 6 },
                { name: 'Shadowweave Armor', defense: 45, class: 'rogue', value: 1150, minLevel: 6 },
                { name: 'Immortal Armor', defense: 80, class: 'warrior', value: 3000, minLevel: 8 },
                { name: 'Vestments of Infinity', defense: 65, mana: 60, class: 'mage', value: 2800, minLevel: 8 },
                { name: 'Cloak of Eternity', defense: 70, class: 'rogue', value: 2900, minLevel: 8 },
                { name: 'Armor of the Titans', defense: 150, class: 'warrior', value: 6000, minLevel: 10 },
                { name: 'Cosmic Vestments', defense: 120, mana: 90, class: 'mage', value: 7000, minLevel: 10 },
                { name: 'Void Emperor Cloak', defense: 130, class: 'rogue', value: 6500, minLevel: 10 },
                { name: 'Worldguard Plate', defense: 300, class: 'warrior', value: 12000, minLevel: 20 },
                { name: 'Reality Weave Robes', defense: 240, mana: 180, class: 'mage', value: 14000, minLevel: 20 },
                { name: 'Entropy Shroud', defense: 260, class: 'rogue', value: 13000, minLevel: 20 },
                { name: 'Godforge Armor', defense: 600, class: 'warrior', value: 24000, minLevel: 30 },
                { name: 'Genesis Vestments', defense: 480, mana: 360, class: 'mage', value: 28000, minLevel: 30 },
                { name: 'Oblivion Suit', defense: 520, class: 'rogue', value: 26000, minLevel: 30 }
            ],
            shields: [
                { name: 'Iron Shield', defense: 5, class: 'warrior', value: 80 },
                { name: 'Tower Shield', defense: 10, class: 'warrior', value: 250 },
                { name: 'Aegis Shield', defense: 15, class: 'warrior', value: 450 },
                { name: 'Shield of Heroes', defense: 35, class: 'warrior', value: 800, minLevel: 6 },
                { name: 'Bulwark of Ages', defense: 55, class: 'warrior', value: 1500, minLevel: 8 },
                { name: 'Titan Shield', defense: 100, class: 'warrior', value: 4000, minLevel: 10 },
                { name: 'Worldshield', defense: 200, class: 'warrior', value: 10000, minLevel: 20 },
                { name: 'Bulwark of Eternity', defense: 400, class: 'warrior', value: 20000, minLevel: 30 }
            ],
            helmets: [
                { name: 'Iron Helm', defense: 3, class: 'warrior', value: 50 },
                { name: 'Mage Hood', mana: 50, class: 'mage', value: 60 },
                { name: 'Shadow Mask', mana: 30, class: 'rogue', value: 55 },
                { name: 'Crown of Kings', defense: 38, class: 'warrior', value: 300, minLevel: 5 },
                { name: 'Circlet of Wisdom', mana: 120, class: 'mage', value: 350, minLevel: 5 },
                { name: 'Assassin Hood', mana: 50, class: 'rogue', value: 320, minLevel: 5 },
                { name: 'Helm of the Ancients', defense: 75, class: 'warrior', value: 3000, minLevel: 10 },
                { name: 'Crown of Cosmic Power', mana: 200, class: 'mage', value: 3500, minLevel: 10 },
                { name: 'Void Assassin Mask', mana: 150, class: 'rogue', value: 3200, minLevel: 10 },
                { name: 'Helm of Titans', defense: 150, class: 'warrior', value: 8000, minLevel: 20 },
                { name: 'Reality Crown', mana: 400, class: 'mage', value: 9000, minLevel: 20 },
                { name: 'Entropy Hood', mana: 300, class: 'rogue', value: 8500, minLevel: 20 },
                { name: 'Godhelm', defense: 300, class: 'warrior', value: 16000, minLevel: 30 },
                { name: 'Genesis Crown', mana: 800, class: 'mage', value: 18000, minLevel: 30 },
                { name: 'Oblivion Mask', mana: 600, class: 'rogue', value: 17000, minLevel: 30 }
            ],
            gloves: [
                { name: 'Leather Gloves', attack: 12, value: 40 },
                { name: 'Gauntlets of Strength', attack: 55, class: 'warrior', value: 200, minLevel: 4 },
                { name: 'Gloves of Casting', mana: 80, class: 'mage', value: 220, minLevel: 4 },
                { name: 'Shadow Grips', attack: 14, health: 30, class: 'rogue', value: 210, minLevel: 4 },
                { name: 'Titan Gauntlets', attack: 110, class: 'warrior', value: 2500, minLevel: 10 },
                { name: 'Cosmic Gloves', mana: 180, class: 'mage', value: 3000, minLevel: 10 },
                { name: 'Void Grips', attack: 95, health: 100, class: 'rogue', value: 2800, minLevel: 10 },
                { name: 'Worldbreaker Gauntlets', attack: 220, class: 'warrior', value: 7000, minLevel: 20 },
                { name: 'Reality Gloves', mana: 360, class: 'mage', value: 8000, minLevel: 20 },
                { name: 'Entropy Grips', attack: 190, health: 200, class: 'rogue', value: 7500, minLevel: 20 },
                { name: 'Godforged Gauntlets', attack: 440, class: 'warrior', value: 14000, minLevel: 30 },
                { name: 'Genesis Gloves', mana: 720, class: 'mage', value: 16000, minLevel: 30 },
                { name: 'Oblivion Grips', attack: 380, health: 400, class: 'rogue', value: 15000, minLevel: 30 }
            ],
            boots: [
                { name: 'Iron Boots', defense: 12, value: 35 },
                { name: 'Boots of Speed', mana: 15, value: 150, minLevel: 3 },
                { name: 'Greaves of the Titan', defense: 38, class: 'warrior', value: 300, minLevel: 5 },
                { name: 'Slippers of Wisdom', mana: 70, class: 'mage', value: 280, minLevel: 5 },
                { name: 'Boots of Shadow', health: 25, class: 'rogue', value: 320, minLevel: 5 },
                { name: 'Ancient Greaves', defense: 75, class: 'warrior', value: 2800, minLevel: 10 },
                { name: 'Cosmic Slippers', mana: 170, class: 'mage', value: 3200, minLevel: 10 },
                { name: 'Void Treads', health: 120, class: 'rogue', value: 3000, minLevel: 10 },
                { name: 'Titan Greaves', defense: 150, class: 'warrior', value: 7500, minLevel: 20 },
                { name: 'Reality Slippers', mana: 340, class: 'mage', value: 8500, minLevel: 20 },
                { name: 'Entropy Boots', health: 250, class: 'rogue', value: 8000, minLevel: 20 },
                { name: 'Worldstep Greaves', defense: 300, class: 'warrior', value: 15000, minLevel: 30 },
                { name: 'Genesis Slippers', mana: 680, class: 'mage', value: 17000, minLevel: 30 },
                { name: 'Oblivion Treads', health: 500, class: 'rogue', value: 16000, minLevel: 30 }
            ],
            bracelets: [
                { name: 'Bronze Bracelet', attack: 5, value: 100 },
                { name: 'Silver Bracelet', attack: 10, mana: 20, value: 300, minLevel: 3 },
                { name: 'Gold Bracelet', attack: 15, mana: 40, value: 800, minLevel: 5 },
                { name: 'Platinum Bracelet', attack: 25, mana: 70, value: 2000, minLevel: 8 },
                { name: 'Ancient Bracelet', attack: 50, mana: 120, value: 5000, minLevel: 10 },
                { name: 'Titan Bracelet', attack: 100, mana: 240, value: 10000, minLevel: 20 },
                { name: 'Reality Bracelet', attack: 200, mana: 480, value: 20000, minLevel: 30 }
            ],
            shoulderItems: [
                { name: 'Battle Banner', effect: 'warrior_damage', bonus: 0.5, class: 'warrior', value: 2000, minLevel: 5, description: '+50% attack damage' },
                { name: 'Arcane Scarf', effect: 'mage_spell', bonus: 0.5, class: 'mage', value: 2000, minLevel: 5, description: '+50% spell damage' },
                { name: 'Spelled Cat Stole', effect: 'rogue_stealth', bonus: 0.5, class: 'rogue', value: 2000, minLevel: 5, description: '+50% stealth damage' },
                { name: 'Titan War Banner', effect: 'warrior_damage', bonus: 1.0, class: 'warrior', value: 10000, minLevel: 20, description: '+100% attack damage' },
                { name: 'Cosmic Mantle', effect: 'mage_spell', bonus: 1.0, class: 'mage', value: 10000, minLevel: 20, description: '+100% spell damage' },
                { name: 'Shadow Cloak Stole', effect: 'rogue_stealth', bonus: 1.0, class: 'rogue', value: 10000, minLevel: 20, description: '+100% stealth damage' }
            ]
        };
        const abilities = [
            { name: 'Icy Blast', damage: 100, cost: 20, type: 'freeze', description: 'Deals damage and freezes enemy for 1 turn', class: 'mage' },
            { name: 'Shield Bash', damage: 80, cost: 20, type: 'stun', description: 'Stun enemy for one turn', class: 'warrior' },
            { name: 'Poison Blade', damage: 40, cost: 20, type: 'poison', duration: 3, description: 'Poison damages 15 per turn for 3 turns', class: 'rogue' },
            { name: 'Chain Lightning', damage: 95, cost: 25, type: 'damage', description: 'Devastating lightning attack', class: 'mage' },
            { name: 'Arcane Missiles', damage: 105, cost: 15, type: 'aoe', description: 'Magic missiles hit all enemies', class: 'mage' },
            { name: 'Whirlwind', damage: 70, cost: 25, type: 'aoe', description: 'Spin attack hitting all enemies', class: 'warrior'},
            { name: 'Shadow Strike', damage: 40, cost: 20, type: 'sneak', description: 'Strike from shadows without enemy retaliation', class: 'rogue' },
            { name: 'Meteor Storm', damage: 145, cost: 40, type: 'aoe', description: 'Massive fire damage to all enemies', class: 'mage', minLevel: 5 },
            { name: 'Titan Smash', damage: 190, cost: 35, type: 'damage', description: 'Devastating single target attack', class: 'warrior', minLevel: 5 },
            { name: 'Assassinate', damage: 125, cost: 30, type: 'sneak', description: 'Massive stealth strike with no counter', class: 'rogue', minLevel: 5 },
            { name: 'Time Stop', damage: 0, cost: 60, type: 'timestop', description: 'Freeze all enemies for 2 turns', class: 'mage', minLevel: 6 },
            { name: 'Berserker Rage', damage: 105, cost: 30, type: 'rage', description: 'Triple attack on single target', class: 'warrior', minLevel: 6 },
            { name: 'Vanish', damage: 0, cost: 25, type: 'vanish', description: 'Become invisible, next attack deals 200% damage', class: 'rogue', minLevel: 6 },
            { name: 'Divine Smite', damage: 200, cost: 60, type: 'damage', description: 'Holy damage that ignores defense', class: 'warrior', minLevel: 8 },
            { name: 'Black Hole', damage: 250, cost: 55, type: 'aoe', description: 'Void magic crushes all foes', class: 'mage', minLevel: 8 },
            { name: 'Death Mark', damage: 100, cost: 35, type: 'mark', description: 'Mark enemy for 50% more damage taken', class: 'rogue', minLevel: 8 },
            { name: 'Cosmic Devastation', damage: 600, cost: 100, type: 'aoe', description: 'Ultimate spell destroys all enemies', class: 'mage', minLevel: 10 },
            { name: 'Annihilation', damage: 800, cost: 70, type: 'damage', description: 'Total destruction single target', class: 'warrior', minLevel: 10 },
            { name: 'Soul Reaper', damage: 500, cost: 60, type: 'sneak', description: 'Harvest souls from the shadows', class: 'rogue', minLevel: 10 },
            { name: 'Supernova', damage: 1200, cost: 200, type: 'aoe', description: 'Star-destroying power', class: 'mage', minLevel: 20 },
            { name: 'World Shatter', damage: 1600, cost: 140, type: 'damage', description: 'Break reality itself', class: 'warrior', minLevel: 20 },
            { name: 'Entropy Strike', damage: 1000, cost: 120, type: 'sneak', description: 'Unravel existence', class: 'rogue', minLevel: 20 },
            { name: 'Genesis Beam', damage: 2400, cost: 400, type: 'aoe', description: 'Create and destroy universes', class: 'mage', minLevel: 30 },
            { name: 'Oblivion Crash', damage: 3200, cost: 280, type: 'damage', description: 'The end of everything', class: 'warrior', minLevel: 30 },
            { name: 'Void Erasure', damage: 2000, cost: 240, type: 'sneak', description: 'Remove from all timelines', class: 'rogue', minLevel: 30 }
        ];

        const amulets = [
            { name: 'Amulet of Vitality', effect: '+15 Max Health', stat: 'maxHealth', value: 15 },
            { name: 'Amulet of Mana', effect: '+15 Max Mana', stat: 'maxMana', value: 15 },
            { name: 'Amulet of Experience', effect: '+20% Experience Gain', stat: 'expGain', value: 30 },
            { name: 'Amulet of the Archmage', effect: '+30 Max Mana', stat: 'maxMana', value: 30 },
            { name: 'Amulet of the Titan', effect: '+30 Max Health', stat: 'maxHealth', value: 30 },
            { name: 'Amulet of Power', effect: '+5 Attack', stat: 'attack', value: 5 },
            { name: 'Ancient Amulet', effect: '+100 Max Health', stat: 'maxHealth', value: 100, minLevel: 10 },
            { name: 'Cosmic Amulet', effect: '+200 Max Mana', stat: 'maxMana', value: 200, minLevel: 10 },
            { name: 'Amulet of Destruction', effect: '+30 Attack', stat: 'attack', value: 30, minLevel: 10 },
            { name: 'Titan Amulet', effect: '+250 Max Health', stat: 'maxHealth', value: 250, minLevel: 20 },
            { name: 'Reality Amulet', effect: '+400 Max Mana', stat: 'maxMana', value: 400, minLevel: 20 },
            { name: 'Worldbreaker Amulet', effect: '+75 Attack', stat: 'attack', value: 75, minLevel: 20 },
            { name: 'Genesis Amulet', effect: '+500 Max Health', stat: 'maxHealth', value: 500, minLevel: 30 },
            { name: 'Oblivion Amulet', effect: '+800 Max Mana', stat: 'maxMana', value: 800, minLevel: 30 },
            { name: 'God Slayer Amulet', effect: '+150 Attack', stat: 'attack', value: 150, minLevel: 30 }
        ];

        const treasures = [
            { name: 'Sapphire Gem', value: 50 },
            { name: 'Ruby Gem', value: 75 },
            { name: 'Diamond', value: 100 },
            { name: 'Emerald', value: 60 },
            { name: 'Ancient Coin Collection', value: 40 },
            { name: 'Golden Chalice', value: 80 },
            { name: 'Silver Crown', value: 90 },
            { name: 'Enchanted Amulet', value: 120 }
        ];

        const rings = [
            { name: 'Ring of Vitality', effect: '+10 Max Health', stat: 'maxHealth', value: 10 },
            { name: 'Ring of Minor Mana', effect: '+40 Max Mana', stat: 'maxMana', value: 10 },
            { name: 'Ring of Protection', effect: '+50 Max Health', stat: 'maxHealth', value: 5 },
            { name: 'Ring of Strength', effect: '+4 Attack Damage', stat: 'attack', value: 2 },
            { name: 'Ring of Wisdom', effect: '+8 Max Mana', stat: 'maxMana', value: 5 },
            { name: 'Ring of the Titan', effect: '+20 Max Health', stat: 'maxHealth', value: 20 },
            { name: 'Ring of Arcane Power', effect: '+15 Max Mana', stat: 'maxMana', value: 15 },
            { name: 'Ring of the Berserker', effect: '+6 Attack Damage', stat: 'attack', value: 4 },
            { name: 'Ring of Regeneration', effect: 'Restore 50 health per turn in combat', stat: 'regen', value: 50 },
            { name: 'Ancient Ring', effect: '+75 Max Health', stat: 'maxHealth', value: 75, minLevel: 10 },
            { name: 'Cosmic Ring', effect: '+150 Max Mana', stat: 'maxMana', value: 150, minLevel: 10 },
            { name: 'Ring of Devastation', effect: '+20 Attack Damage', stat: 'attack', value: 20, minLevel: 10 },
            { name: 'Titan Ring', effect: '+200 Max Health', stat: 'maxHealth', value: 200, minLevel: 20 },
            { name: 'Reality Ring', effect: '+300 Max Mana', stat: 'maxMana', value: 300, minLevel: 20 },
            { name: 'Worldbreaker Ring', effect: '+50 Attack Damage', stat: 'attack', value: 50, minLevel: 20 },
            { name: 'Genesis Ring', effect: '+400 Max Health', stat: 'maxHealth', value: 400, minLevel: 30 },
            { name: 'Oblivion Ring', effect: '+600 Max Mana', stat: 'maxMana', value: 600, minLevel: 30 },
            { name: 'God Ring', effect: '+100 Attack Damage', stat: 'attack', value: 100, minLevel: 30 }
        ];

        const enemies = {
            goblin: { name: 'Goblin', health: 130, damage: 18, gold: 5, exp: 25, fleeChance: 0.8 },
            skeleton: { name: 'Skeleton', health: 140, damage: 20, gold: 8, exp: 30, fleeChance: 0.7 },
            orc: { name: 'Orc', health: 160, damage: 35, gold: 12, exp: 50, fleeChance: 0.5 },
            wraith: { name: 'Wraith', health: 150, damage: 38, gold: 15, exp: 75, fleeChance: 0.6 },
            troll: { name: 'Troll', health: 180, damage: 50, gold: 20, exp: 65, fleeChance: 0.4, regenerate: 5 },
            dragon: { name: 'Dragon', health: 350, damage: 75, gold: 50, exp: 450, fleeChance: 0.1 },
            demon: { name: 'Demon', health: 190, damage: 58, gold: 45, exp: 80, fleeChance: 0.3 },
            vampire: { name: 'Vampire', health: 200, damage: 95, gold: 40, exp: 100, fleeChance: 0.4, regenerate: 8 },
            orcChieftain: { name: 'Orc Chieftain', health: 190, damage: 72, gold: 25, exp: 65, fleeChance: 0.3 },
            ancientWraith: { name: 'Ancient Wraith', health: 190, damage: 96, gold: 30, exp: 80, fleeChance: 0.4 },
            elderTroll: { name: 'Elder Troll', health: 250, damage: 28, gold: 40, exp: 100, fleeChance: 0.2, regenerate: 10 },
            archDemon: { name: 'Arch Demon', health: 280, damage: 95, gold: 70, exp: 160, fleeChance: 0.2 },
            hydra: { name: 'Hydra', health: 240, damage: 130, gold: 55, exp: 125, fleeChance: 0.3, regenerate: 12 },
            phoenixGuardian: { name: 'Phoenix Guardian', health: 230, damage: 132, gold: 60, exp: 145, fleeChance: 0.3, regenerate: 15 },
            lichKing: { name: 'Lich King', health: 160, damage: 38, gold: 80, exp: 185, fleeChance: 0.1, regenerate: 10 },
            ancientDragon: { name: 'Ancient Dragon', health: 600, damage: 150, gold: 200, exp: 800, fleeChance: 0.05, regenerate: 20 },
            demonLord: { name: 'Demon Lord', health: 550, damage: 180, gold: 250, exp: 900, fleeChance: 0.05, regenerate: 25 },
            voidBeast: { name: 'Void Beast', health: 700, damage: 200, gold: 300, exp: 1000, fleeChance: 0.03, regenerate: 30 },
            cosmicHorror: { name: 'Cosmic Horror', health: 800, damage: 220, gold: 350, exp: 1200, fleeChance: 0.03, regenerate: 35 },
            titanLord: { name: 'Titan Lord', health: 1000, damage: 250, gold: 400, exp: 1500, fleeChance: 0.02, regenerate: 40 },
            harbingerOfRagnarok: { name: 'Harbinger of Ragnarok', health: 1500, damage: 300, gold: 600, exp: 2500, fleeChance: 0.01, regenerate: 50 },
            voidEmperor: { name: 'Void Emperor', health: 2000, damage: 350, gold: 800, exp: 3500, fleeChance: 0.01, regenerate: 60 },
            apocalypseTitan: { name: 'Apocalypse Titan', health: 2500, damage: 400, gold: 1000, exp: 5000, fleeChance: 0.01, regenerate: 75 },
            worldEater: { name: 'World Eater', health: 5000, damage: 800, gold: 2000, exp: 10000, fleeChance: 0.01, regenerate: 150 },
            realityBender: { name: 'Reality Bender', health: 8000, damage: 1200, gold: 3000, exp: 15000, fleeChance: 0.01, regenerate: 200 },
            genesisLord: { name: 'Genesis Lord', health: 10000, damage: 1600, gold: 5000, exp: 25000, fleeChance: 0.01, regenerate: 300 }
        };

        const merchantItems = [
            { name: 'Large Health Potion', type: 'potion', price: 50, healing: 50 },
            { name: 'Large Mana Potion', type: 'potion', price: 40, mana: 30 },
            { name: 'Greater Health Potion', type: 'potion', price: 100, healing: 100 },
            { name: 'Greater Mana Potion', type: 'potion', price: 80, mana: 75 },
            { name: 'Supreme Health Potion', type: 'potion', price: 300, healing: 300, minLevel: 10 },
            { name: 'Supreme Mana Potion', type: 'potion', price: 250, mana: 200, minLevel: 10 },
            { name: 'Ultimate Health Potion', type: 'potion', price: 800, healing: 800, minLevel: 20 },
            { name: 'Ultimate Mana Potion', type: 'potion', price: 700, mana: 500, minLevel: 20 },
            { name: 'Godly Health Elixir', type: 'potion', price: 2000, healing: 2000, minLevel: 30 },
            { name: 'Godly Mana Elixir', type: 'potion', price: 1800, mana: 1500, minLevel: 30 },
            { name: 'Elixir of Immortality', type: 'special_potion', price: 400, effect: 'revive', description: 'Auto-revive on death with 50% health' },
            { name: 'Potion of Giant Strength', type: 'special_potion', price: 300, effect: 'strength', duration: 3, description: 'Double attack damage for 3 battles' },
            { name: 'Elixir of Clarity', type: 'special_potion', price: 350, effect: 'clarity', description: 'All spells cost 50% less mana for 3 battles' },
            { name: 'Golden Fortune Coin', type: 'special_item', price: 500, effect: '+50% gold from all sources', stat: 'goldBonus', value: 0.5 },
            { name: 'Ancient Knowledge Crystal', type: 'special_item', price: 600, effect: '+100% experience gain', stat: 'expBonus', value: 1.0 },
            
            { name: 'Legendary Warhammer', type: 'weapon', price: 3500, attack: 65, class: 'warrior', description: 'Crushes all opposition' },
            { name: 'Staff of Ultimate Power', type: 'weapon', price: 4000, attack: 40, mana: 100, class: 'mage', description: 'Limitless arcane potential' },
            { name: 'Blades of the Phantom King', type: 'weapon', price: 3800, attack: 55, class: 'rogue', description: 'Strike from any shadow' },
            
            { name: 'Fortress Armor', type: 'armor', price: 4500, defense: 80, class: 'warrior', description: 'Impenetrable defense' },
            { name: 'Robes of Ultimate Magic', type: 'armor', price: 5000, defense: 60, mana: 120, class: 'mage', description: 'Channel infinite power' },
            { name: 'Suit of the Shadow Emperor', type: 'armor', price: 4800, defense: 70, class: 'rogue', description: 'One with darkness' },
            
            { name: 'Shield of the Immortal', type: 'shield', price: 5500, defense: 90, class: 'warrior', description: 'Nothing can harm you', minLevel: 10 },
            
            { name: 'Crown of Absolute Power', type: 'helmet', price: 6000, defense: 100, mana: 150, description: 'Ultimate authority', minLevel: 10 },
            
            { name: 'Gauntlets of the God Slayer', type: 'gloves', price: 5500, attack: 100, mana: 100, description: 'Destroy the divine', minLevel: 10 },
            
            { name: 'Boots of Infinity', type: 'boots', price: 5000, defense: 80, mana: 120, health: 150, description: 'Walk forever', minLevel: 10 },
            
            { name: 'Bracelet of the Cosmos', type: 'bracelet', price: 8000, attack: 80, mana: 200, description: 'Harness cosmic power', minLevel: 10 },
            { name: 'Bracelet of Annihilation', type: 'bracelet', price: 15000, attack: 150, mana: 350, description: 'Destroy all creation', minLevel: 20 }
        ];
        const roomTypes = {
            entrance: { 
                descriptions: [
                    'the grand entrance hall. Torches flicker on ancient stone walls.',
                    'the entrance chamber. A faded tapestry hangs on the north wall.',
                    'the starting hall. Cobwebs drape from vaulted ceilings above.'
                ], 
                hasEnemy: false 
            },
            empty: { 
                descriptions: [
                    'an abandoned barracks. Rusty weapons litter the floor.',
                    'a collapsed library. Torn pages scatter at your feet.',
                    'a crumbling shrine. A broken altar stands in the center.',
                    'a forgotten armory. Empty weapon racks line the walls.',
                    'a dusty workshop. Ancient tools hang from hooks.',
                    'a meditation chamber. Stone benches circle a dry fountain.',
                    'an old prison cell. Iron bars have rusted through.',
                    'a guard post. A skeleton sits slumped in a chair.'
                ], 
                hasEnemy: false 
            },
            treasure: { 
                descriptions: [
                    'a glittering treasure vault. Gold coins reflect torchlight.',
                    'a dragon\'s hoard chamber. Piles of jewels gleam in the darkness.',
                    'a royal treasury. Ancient chests overflow with riches.',
                    'a pirate\'s cache. Stolen goods fill every corner.',
                    'a wizard\'s vault. Magical artifacts pulse with energy.'
                ], 
                hasEnemy: false 
            },
            enemy: { 
                descriptions: [
                    'a dark chamber. You sense hostile eyes watching you.',
                    'a blood-stained arena. Old battle scars mark the floor.',
                    'a shadowy lair. Something growls in the darkness.',
                    'a monster\'s den. Bones crunch beneath your feet.',
                    'a cursed chamber. An evil presence fills the air.'
                ], 
                hasEnemy: true 
            },
            boss: { 
                descriptions: [
                    'the throne room of darkness. A massive beast awaits on a stone throne.',
                    'the dragon\'s lair. Heat radiates from the enormous creature before you.',
                    'the demon king\'s chamber. Dark energy swirls around your foe.'
                ], 
                hasEnemy: true 
            },
            trap: { 
                descriptions: [
                    'a trapped corridor. Pressure plates cover the floor.',
                    'a spike-filled chamber. Deadly traps line the walls.',
                    'a poison gas room. Strange vapors seep from cracks.'
                ], 
                hasEnemy: false 
            },
            stairs: { 
                descriptions: [
                    'a spiral stairwell. Dark stone steps descend into deeper darkness.',
                    'a grand staircase. Ancient carvings decorate the descent.',
                    'a hidden passage. Secret stairs lead to the next level.'
                ], 
                hasEnemy: false 
            },
            fountain: {
                descriptions: [
                    'a magical fountain room. Crystal clear water bubbles from an enchanted spring.',
                    'an ancient healing shrine. A mystical fountain glows with restorative power.'
                ],
                hasEnemy: false
            },
            crypt: {
                descriptions: [
                    'a dusty crypt. Stone sarcophagi line the walls.',
                    'an ancient burial chamber. Skeletal remains rest in alcoves.',
                    'a forgotten tomb. Hieroglyphs cover every surface.'
                ],
                hasEnemy: false
            },
            merchant: {
                descriptions: [
                    'a merchant\'s tent. A hooded figure tends to various wares.',
                    'a traveling shop. Mysterious goods line makeshift shelves.'
                ],
                hasEnemy: false
            }
        };

        function speak(text, callback) {
            displayText(text);
            if (!browserSupport.speechSynthesis) {
                if (callback) setTimeout(callback, 2000);
                return;
            }
            try {
                speechSynthesis.cancel();
                setTimeout(() => {
                    const utterance = new SpeechSynthesisUtterance(text.replace(/<[^>]*>/g, ''));
                    utterance.rate = 0.9;
                    if (callback) {
                        utterance.onend = callback;
                        utterance.onerror = callback;
                    }
                    speechSynthesis.speak(utterance);
                }, 100);
            } catch (error) {
                if (callback) setTimeout(callback, 2000);
            }
        }

        function speakSequence(messages, callback) {
            if (messages.length === 0) {
                if (callback) callback();
                return;
            }
            const [first, ...rest] = messages;
            speak(first, () => {
                if (rest.length > 0) {
                    setTimeout(() => speakSequence(rest, callback), 500);
                } else if (callback) {
                    callback();
                }
            });
        }

        let recognition = null;

        function startListening() {
            if (!browserSupport.speechRecognition || !browserSupport.https) {
                speak('Voice recognition requires HTTPS and a compatible browser like Chrome or Edge.');
                return;
            }
            if (game.listening) { stopListening(); return; }
            try {
                const Recognition = window.webkitSpeechRecognition || window.SpeechRecognition;
                recognition = new Recognition();
                recognition.continuous = false;
                recognition.lang = 'en-US';
                recognition.onstart = () => {
                    game.listening = true;
                    micButton.classList.add('listening');
                };
                recognition.onresult = (event) => {
                    const command = event.results[0][0].transcript.toLowerCase().trim();
                    displayText(`You said: "${command}"`);
                    stopListening();
                    setTimeout(() => processCommand(command), 500);
                };
                recognition.onerror = (event) => {
                    stopListening();
                    if (event.error !== 'no-speech' && event.error !== 'aborted') {
                        speak('Voice error. Try again.');
                    }
                };
                recognition.onend = () => stopListening();
                recognition.start();
            } catch (error) {
                speak('Failed to start voice recognition.');
                stopListening();
            }
        }

        function stopListening() {
            game.listening = false;
            micButton.classList.remove('listening');
            if (recognition) {
                try { recognition.stop(); } catch (e) {}
                recognition = null;
            }
        }

        function getScalingMultiplier(dungeonLevel) {
            return Math.pow(2, Math.floor(dungeonLevel / 10));
        }

        function getScaledAbilityDamage(baseDamage, dungeonLevel) {
            return Math.floor(baseDamage * getScalingMultiplier(dungeonLevel));
        }

        function getScaledAbilityCost(baseCost, dungeonLevel) {
            return Math.floor(baseCost * getScalingMultiplier(dungeonLevel));
        }

        function saveGame() {
            const saveData = {
                player: game.player,
                dungeon: {
                    grid: game.dungeon.grid,
                    currentLevel: game.dungeon.currentLevel,
                    size: game.dungeon.size,
                    hasSecretRoom: game.dungeon.hasSecretRoom
                }
            };
            const saveStr = JSON.stringify(saveData);
            const pin = Math.floor(1000 + Math.random() * 9000).toString();
            localStorage.setItem(`echoDungeon_${pin}`, saveStr);
            const spokenPin = pin.split('').join(' ');
            speak(`Game saved! Your save PIN is ${spokenPin}. Say "load game" then "code ${spokenPin}" to load.`);
        }

        function loadGame(pin) {
            try {
                const saveStr = localStorage.getItem(`echoDungeon_${pin}`);
                if (!saveStr) {
                    speak(`No game found for PIN ${pin.split('').join(' ')}. Try another PIN or start a new game.`);
                    return;
                }
                const saveData = JSON.parse(saveStr);
                game.player = saveData.player;
                game.dungeon.grid = saveData.dungeon.grid;
                game.dungeon.currentLevel = saveData.dungeon.currentLevel;
                game.dungeon.size = saveData.dungeon.size;
                game.dungeon.hasSecretRoom = saveData.dungeon.hasSecretRoom;
                const key = `${game.player.position.x},${game.player.position.y}`;
                game.currentRoom = game.dungeon.grid[key];
                game.initialized = true;
                game.started = true;
                game.needsClass = false;
                game.phase = 'exploration';
                micButton.classList.remove('start-button');
                speak(`Game loaded! You are a level ${game.player.level} ${classes[game.player.class].name} on Dungeon Level ${game.dungeon.currentLevel}.`, () => {
                    describeRoom();
                });
            } catch (e) {
                speak('Error loading game. The PIN may be incorrect.');
            }
        }

        function initializeGame() {
            game.initialized = true;
            micButton.classList.remove('start-button');
            speak("Welcome to Echo Dungeon V11! Say 'load game' and provide your save PIN, or choose your class: warrior, mage, or rogue."); 
        }

        function handleClick() {
            if (!game.initialized) {
                initializeGame();
            } else {
                startListening();
            }
        }

        function gainExperience(exp) {
            let actualExp = exp;
            
            if (game.player.equippedAmulet && amulets.find(a => a.name === game.player.equippedAmulet)?.stat === 'expGain') {
                actualExp = Math.floor(exp * 1.2);
            }
            
            if (game.player.specialItems.includes('Ancient Knowledge Crystal')) {
                actualExp = Math.floor(actualExp * 2);
            }
            
            game.player.experience += actualExp;
            
            if (game.player.experience >= game.player.experienceToNext) {
                levelUp();
            }
        }

        function levelUp() {
            game.player.level++;
            game.player.experience -= game.player.experienceToNext;
            game.player.experienceToNext = Math.floor(game.player.experienceToNext * 1.20);
            
            const tier = Math.floor(game.dungeon.currentLevel / 10);
            const baseHealthGain = 20;
            const baseManaGain = 10;
            const healthGain = baseHealthGain * Math.pow(2, tier);
            const manaGain = baseManaGain * Math.pow(2, tier);
            
            game.player.maxHealth += healthGain;
            game.player.health = game.player.maxHealth;
            game.player.maxMana += manaGain;
            game.player.mana = game.player.maxMana;
            
            speakSequence([
                `Level up! You are now level ${game.player.level}!`,
                `Max health increased by ${healthGain}!`,
                `Max mana increased by ${manaGain}!`,
                `Fully healed and restored!`
            ]);
        }

        function recalculateDefense() {
            game.player.defense = 0;
            
            if (game.player.armor) {
                const armorData = equipment.armor.find(a => a.name === game.player.armor) ||
                                  merchantItems.find(i => i.name === game.player.armor && i.type === 'armor');
                if (armorData) game.player.defense += armorData.defense;
            }
            
            if (game.player.shield) {
                const shieldData = equipment.shields.find(s => s.name === game.player.shield) ||
                                   merchantItems.find(i => i.name === game.player.shield && i.type === 'shield');
                if (shieldData) game.player.defense += shieldData.defense;
            }
            
            if (game.player.helmet) {
                const helmetData = equipment.helmets.find(h => h.name === game.player.helmet) ||
                                   merchantItems.find(i => i.name === game.player.helmet && i.type === 'helmet');
                if (helmetData && helmetData.defense) game.player.defense += helmetData.defense;
            }
            
            if (game.player.gloves) {
                const glovesData = equipment.gloves.find(g => g.name === game.player.gloves) ||
                                   merchantItems.find(i => i.name === game.player.gloves && i.type === 'gloves');
                if (glovesData && glovesData.defense) game.player.defense += glovesData.defense;
            }
            
            if (game.player.boots) {
                const bootsData = equipment.boots.find(b => b.name === game.player.boots) ||
                                  merchantItems.find(i => i.name === game.player.boots && i.type === 'boots');
                if (bootsData && bootsData.defense) game.player.defense += bootsData.defense;
            }
        }

        function getRandomDescription(roomType) {
            const descriptions = roomTypes[roomType].descriptions;
            return descriptions[Math.floor(Math.random() * descriptions.length)];
        }

        function scaleEnemyForLevel(enemy, level) {
            const scaleFactor = 1 + ((level - 1) * 0.3);
            return {
                ...enemy,
                health: Math.floor(enemy.health * scaleFactor),
                damage: Math.floor(enemy.damage * scaleFactor),
                gold: Math.floor(enemy.gold * scaleFactor),
                exp: Math.floor(enemy.exp * scaleFactor),
                regenerate: enemy.regenerate
            };
        }

        function autoManageInventory(newItem) {
            const itemType = getItemType(newItem);
            
            if (itemType === 'treasure') {
                if (!game.player.junkBag.includes(newItem)) {
                    game.player.junkBag.push(newItem);
                }
                return;
            }
            
            if (itemType === 'ring') {
                if (newItem === 'Ring of Regeneration') {
                    return;
                }
                
                const ringCount = game.player.inventory.filter(i => i === newItem).length;
                const equippedCount = game.player.equippedRings.filter(i => i === newItem).length;
                const totalCount = ringCount + equippedCount;
                
                if (totalCount > 2) {
                    const indexInInventory = game.player.inventory.indexOf(newItem);
                    if (indexInInventory !== -1) {
                        game.player.inventory.splice(indexInInventory, 1);
                        if (!game.player.junkBag.includes(newItem)) {
                            game.player.junkBag.push(newItem);
                        }
                    }
                }
                return;
            }
            
            if (itemType === 'amulet') {
                const amuletCount = game.player.inventory.filter(i => i === newItem).length;
                const isEquipped = game.player.equippedAmulet === newItem;
                const totalCount = amuletCount + (isEquipped ? 1 : 0);
                
                if (totalCount > 1) {
                    const indexInInventory = game.player.inventory.indexOf(newItem);
                    if (indexInInventory !== -1) {
                        game.player.inventory.splice(indexInInventory, 1);
                        if (!game.player.junkBag.includes(newItem)) {
                            game.player.junkBag.push(newItem);
                        }
                    }
                }
                return;
            }
            
            if (itemType === 'equipment') {
                const equipmentSlot = getEquipmentSlot(newItem);
                const currentEquipped = game.player[equipmentSlot];
                
                const sameItemCount = game.player.inventory.filter(i => i === newItem).length;
                
                if (sameItemCount > 1 || (currentEquipped === newItem && sameItemCount > 0)) {
                    const indexInInventory = game.player.inventory.lastIndexOf(newItem);
                    if (indexInInventory !== -1) {
                        game.player.inventory.splice(indexInInventory, 1);
                        if (!game.player.junkBag.includes(newItem)) {
                            game.player.junkBag.push(newItem);
                        }
                    }
                }
            }
        }

        function getItemType(itemName) {
            if (treasures.some(t => t.name === itemName)) return 'treasure';
            if (rings.some(r => r.name === itemName)) return 'ring';
            if (amulets.some(a => a.name === itemName)) return 'amulet';
            if (equipment.weapons.some(w => w.name === itemName)) return 'equipment';
            if (equipment.armor.some(a => a.name === itemName)) return 'equipment';
            if (equipment.shields && equipment.shields.some(s => s.name === itemName)) return 'equipment';
            if (equipment.helmets.some(h => h.name === itemName)) return 'equipment';
            if (equipment.gloves.some(g => g.name === itemName)) return 'equipment';
            if (equipment.boots.some(b => b.name === itemName)) return 'equipment';
            if (equipment.bracelets.some(b => b.name === itemName)) return 'equipment';
            if (equipment.shoulderItems && equipment.shoulderItems.some(s => s.name === itemName)) return 'equipment';
            return 'other';
        }

        function getEquipmentSlot(itemName) {
            if (equipment.weapons.some(w => w.name === itemName)) return 'weapon';
            if (equipment.armor.some(a => a.name === itemName)) return 'armor';
            if (equipment.shields && equipment.shields.some(s => s.name === itemName)) return 'shield';
            if (equipment.helmets.some(h => h.name === itemName)) return 'helmet';
            if (equipment.gloves.some(g => g.name === itemName)) return 'gloves';
            if (equipment.boots.some(b => b.name === itemName)) return 'boots';
            if (equipment.shoulderItems && equipment.shoulderItems.some(s => s.name === itemName)) return 'equippedShoulderItem';
            return null;
        }
        function processCommand(command) {
            if (command.includes('save game') || command.includes('save')) { 
                saveGame(); 
                return; 
            }
            
            if (command.includes('load game') || command.includes('load')) {
                speak('Please say your save PIN after the word "code".');
                game.phase = 'loading';
                return;
            }
            
            if (command.includes('code ') && game.phase === 'loading') {
                const pin = command.split('code ')[1].trim().replace(/\s/g, '');
                loadGame(pin);
                return;
            }

            if (game.inspectMode) {
                if (command.includes('equip')) {
                    equipInspectedItem();
                } else if (command.includes('junk')) {
                    junkInspectedItem();
                } else if (command.includes('keep')) {
                    keepInspectedItem();
                } else {
                    speak('Say equip, junk, or keep.');
                }
                return;
            }

            if (game.merchantOpen) {
                if (command.includes('leave') || command.includes('exit') || command.includes('close')) {
                    game.merchantOpen = false;
                    speak('You leave the merchant.');
                } else if (command.includes('buy') || command.includes('purchase')) {
                    buyFromMerchant(command);
                } else if (command.includes('sell junk') || command.includes('sell all junk')) {
                    sellAllJunk();
                } else if (command.includes('what') || command.includes('wares') || command.includes('stock')) {
                    listMerchantWares();
                } else {
                    speak('Say buy, sell junk, what do you have, or leave.');
                }
                return;
            }

            if (game.needsClass) {
                if (command.includes('warrior') || command.includes('fighter')) selectClass('warrior');
                else if (command.includes('mage') || command.includes('wizard')) selectClass('mage'); 
                else if (command.includes('rogue') || command.includes('thief')) selectClass('rogue');
                else speak('Please say warrior, mage, or rogue.');
                return;
            }

            if (game.combat) {
                if (command.includes('attack') || command.includes('fight')) playerAttack();
                else if (command.includes('defend') || command.includes('block') || command.includes('guard')) playerDefend();
                else if (command.includes('special') || command.includes('ability')) playerSpecial();
                else if (command.includes('cast') || command.includes('spell')) castSpell(command);
                else if (command.includes('potion') || command.includes('use') || command.includes('drink') || command.includes('heal')) processPotionCommand(command); 
                else if (command.includes('flee') || command.includes('run') || command.includes('escape')) attemptFlee();
                else speak('Say attack, defend, special, cast spell, use potion, or flee.');
                return;
            }

            if (command.includes('status') || command.includes('stats') || command.includes('check')) characterStatus();
            else if (command.includes('inventory') || command.includes('items') || command.includes('bag')) listInventory();
            else if (command.includes('commands') || command.includes('what can i')) listCommands();
            else if (command.includes('hint') || command.includes('help me')) giveHint();
            else if (command.includes('inspect')) inspectItem(command);
            else if (command.includes('remove ring') || command.includes('unequip ring')) removeRing(command);
            else if (command.includes('remove bracelet') || command.includes('unequip bracelet')) removeBracelet(command);
            else if (command.includes('potion') || command.includes('use') || command.includes('drink') || command.includes('heal')) processPotionCommand(command); 
            else if (command.includes('north') || command.includes('forward')) move('north');
            else if (command.includes('south') || command.includes('back')) move('south');
            else if (command.includes('east') || command.includes('right')) move('east');
            else if (command.includes('west') || command.includes('left')) move('west');
            else if (command.includes('meditate') || command.includes('rest')) meditate(); 
            else if (command.includes('look') || command.includes('around') || command.includes('where')) describeRoom();
            else if (command.includes('search') || command.includes('examine')) searchRoom();
            else if (command.includes('open chest') || command.includes('chest') || command.includes('loot')) openChest();
            else if (command.includes('fountain') || command.includes('drink water')) useFountain();
            else if (command.includes('stairs') || command.includes('go down') || command.includes('descend')) useStairs();
            else if (command.includes('merchant') || command.includes('shop') || command.includes('trade')) talkToMerchant();
            else if (command.includes('wear ring') || command.includes('equip ring') || command.includes('put on ring')) equipRing(command);
            else if (command.includes('equip amulet') || command.includes('wear amulet')) equipAmulet(command);
            else if (command.includes('equip bracelet') || command.includes('wear bracelet')) equipBracelet(command);
            else if (command.includes('equip shoulder') || command.includes('wear shoulder')) equipShoulderItem(command);
            else if (command.includes('equip') || command.includes('wear')) equipItem(command);
            else if (command.includes('read book') || command.includes('read') || command.includes('learn')) readBook(command);
            else if (command.includes('unlearn') || command.includes('forget')) unlearnAbility(command);
            else if (command.includes('use lockpicks') || command.includes('lockpick')) useLockpicks();
            else if (command.includes('help')) showHelp();
            else if (command.includes('junk') && (command.includes('add') || command.includes('mark'))) addToJunk(command);
            else if (command.includes('junk') && (command.includes('remove') || command.includes('unmark'))) removeFromJunk(command);
            else if (command.includes('view junk') || command.includes('check junk') || command.includes('list junk')) viewJunk();
            else speak('Unknown command. Say help for options.');
        }

        function inspectItem(command) {
            let itemToInspect = null;
            
            for (let item of game.player.inventory) {
                if (command.includes(item.toLowerCase())) {
                    itemToInspect = item;
                    break;
                }
            }
            
            if (!itemToInspect) {
                speak('Item not found in inventory. Say inspect followed by the item name.');
                return;
            }
            
            game.inspectMode = true;
            game.inspectItem = itemToInspect;
            
            let itemData = null;
            let messages = [`Inspecting ${itemToInspect}.`];
            
            const weaponData = equipment.weapons.find(w => w.name === itemToInspect);
            const armorData = equipment.armor.find(a => a.name === itemToInspect);
            const shieldData = equipment.shields && equipment.shields.find(s => s.name === itemToInspect);
            const helmetData = equipment.helmets.find(h => h.name === itemToInspect);
            const glovesData = equipment.gloves.find(g => g.name === itemToInspect);
            const bootsData = equipment.boots.find(b => b.name === itemToInspect);
            const braceletData = equipment.bracelets.find(b => b.name === itemToInspect);
            const shoulderData = equipment.shoulderItems && equipment.shoulderItems.find(s => s.name === itemToInspect);
            const ringData = rings.find(r => r.name === itemToInspect);
            const amuletData = amulets.find(a => a.name === itemToInspect);
            const abilityData = abilities.find(ab => ab.name === itemToInspect);
            const potionData = merchantItems.find(p => p.name === itemToInspect);
            
            if (weaponData) {
                messages.push(`Weapon. Attack ${weaponData.attack}.`);
                if (weaponData.mana) messages.push(`Mana bonus ${weaponData.mana}.`);
                if (weaponData.class) messages.push(`Class: ${weaponData.class}.`);
                messages.push(`Value: ${weaponData.value} gold.`);
            } else if (armorData) {
                messages.push(`Armor. Defense ${armorData.defense}.`);
                if (armorData.mana) messages.push(`Mana bonus ${armorData.mana}.`);
                if (armorData.class) messages.push(`Class: ${armorData.class}.`);
                messages.push(`Value: ${armorData.value} gold.`);
            } else if (shieldData) {
                messages.push(`Shield. Defense ${shieldData.defense}.`);
                messages.push(`Value: ${shieldData.value} gold.`);
            } else if (helmetData) {
                messages.push(`Helmet.`);
                if (helmetData.defense) messages.push(`Defense ${helmetData.defense}.`);
                if (helmetData.mana) messages.push(`Mana bonus ${helmetData.mana}.`);
                messages.push(`Value: ${helmetData.value} gold.`);
            } else if (glovesData) {
                messages.push(`Gloves.`);
                if (glovesData.attack) messages.push(`Attack ${glovesData.attack}.`);
                if (glovesData.mana) messages.push(`Mana bonus ${glovesData.mana}.`);
                if (glovesData.health) messages.push(`Health bonus ${glovesData.health}.`);
                messages.push(`Value: ${glovesData.value} gold.`);
            } else if (bootsData) {
                messages.push(`Boots.`);
                if (bootsData.defense) messages.push(`Defense ${bootsData.defense}.`);
                if (bootsData.mana) messages.push(`Mana bonus ${bootsData.mana}.`);
                if (bootsData.health) messages.push(`Health bonus ${bootsData.health}.`);
                messages.push(`Value: ${bootsData.value} gold.`);
            } else if (braceletData) {
                messages.push(`Bracelet. Attack ${braceletData.attack}. Mana ${braceletData.mana}.`);
                messages.push(`Value: ${braceletData.value} gold.`);
            } else if (shoulderData) {
                messages.push(`Shoulder item. ${shoulderData.description}.`);
                messages.push(`Value: ${shoulderData.value} gold.`);
            } else if (ringData) {
                messages.push(`Ring. ${ringData.effect}.`);
            } else if (amuletData) {
                messages.push(`Amulet. ${amuletData.effect}.`);
            } else if (abilityData) {
                messages.push(`Ability book. ${abilityData.description}.`);
                messages.push(`Damage: ${abilityData.damage}. Cost: ${abilityData.cost} mana.`);
            } else if (potionData) {
                messages.push(`Potion.`);
                if (potionData.healing) messages.push(`Restores ${potionData.healing} health.`);
                if (potionData.mana) messages.push(`Restores ${potionData.mana} mana.`);
                if (potionData.description) messages.push(potionData.description);
            }
            
            messages.push('Say equip to use it, junk to mark for sale, or keep to leave in inventory.');
            speakSequence(messages);
        }

        function equipInspectedItem() {
            const item = game.inspectItem;
            game.inspectMode = false;
            game.inspectItem = null;
            
            const itemType = getItemType(item);
            
            if (itemType === 'ring') {
                const index = game.player.inventory.indexOf(item);
                if (index !== -1) {
                    game.player.inventory.splice(index, 1);
                    equipRingDirect(item);
                }
            } else if (itemType === 'amulet') {
                const index = game.player.inventory.indexOf(item);
                if (index !== -1) {
                    game.player.inventory.splice(index, 1);
                    equipAmuletDirect(item);
                }
            } else if (itemType === 'equipment') {
                equipItemDirect(item);
            } else if (abilities.some(a => a.name === item)) {
                readBookDirect(item);
            } else {
                speak('This item cannot be equipped.');
            }
        }

        function junkInspectedItem() {
            const item = game.inspectItem;
            game.inspectMode = false;
            game.inspectItem = null;
            
            if (!game.player.junkBag.includes(item)) {
                game.player.junkBag.push(item);
            }
            speak(`${item} marked as junk.`);
        }

        function keepInspectedItem() {
            game.inspectMode = false;
            game.inspectItem = null;
            speak('Item kept in inventory.');
        }

        function addToJunk(command) {
            const sellableItems = game.player.inventory.filter(item => {
                return equipment.weapons.some(w => w.name === item) ||
                       equipment.armor.some(a => a.name === item) ||
                       (equipment.shields && equipment.shields.some(s => s.name === item)) ||
                       equipment.helmets.some(h => h.name === item) ||
                       equipment.gloves.some(g => g.name === item) ||
                       equipment.boots.some(b => b.name === item) ||
                       equipment.bracelets.some(br => br.name === item) ||
                       (equipment.shoulderItems && equipment.shoulderItems.some(s => s.name === item)) ||
                       treasures.some(t => t.name === item);
            });

            if (sellableItems.length === 0) {
                speak('You have no equipment or treasures to mark as junk.');
                return;
            }

            let itemToAdd = null;
            for (let i = 0; i < sellableItems.length; i++) {
                const item = sellableItems[i];
                if (command.includes(item.toLowerCase())) {
                    itemToAdd = item;
                    break;
                }
            }

            if (!itemToAdd) {
                speak(`Available items: ${sellableItems.join(', ')}. Say which to mark as junk.`);
                return;
            }

            if (game.player.junkBag.includes(itemToAdd)) {
                speak(`${itemToAdd} is already marked as junk.`);
                return;
            }

            game.player.junkBag.push(itemToAdd);
            speak(`Marked ${itemToAdd} as junk. Say "sell junk" at a merchant to sell all junk.`);
        }

        function removeFromJunk(command) {
            if (game.player.junkBag.length === 0) {
                speak('Your junk bag is empty.');
                return;
            }

            let itemToRemove = null;
            for (let item of game.player.junkBag) {
                if (command.includes(item.toLowerCase())) {
                    itemToRemove = item;
                    break;
                }
            }

            if (!itemToRemove) {
                speak(`Junk bag: ${game.player.junkBag.join(', ')}. Say which to unmark.`);
                return;
            }

            const index = game.player.junkBag.indexOf(itemToRemove);
            game.player.junkBag.splice(index, 1);
            speak(`Unmarked ${itemToRemove} from junk.`);
        }

        function viewJunk() {
            if (game.player.junkBag.length === 0) {
                speak('Your junk bag is empty.');
            } else {
                speak(`Junk bag contains: ${game.player.junkBag.join(', ')}. ${game.player.junkBag.length} items marked for sale.`);
            }
        }

        function sellAllJunk() {
            if (!game.merchantOpen) {
                speak('You need to be at a merchant to sell junk.');
                return;
            }

            if (game.player.junkBag.length === 0) {
                speak('Your junk bag is empty. Say "mark junk" followed by item names to mark items for sale.');
                return;
            }

            let totalGold = 0;
            const soldItems = [];

            for (let itemName of [...game.player.junkBag]) {
                const itemIndex = game.player.inventory.indexOf(itemName);
                if (itemIndex === -1) {
                    const junkIndex = game.player.junkBag.indexOf(itemName);
                    game.player.junkBag.splice(junkIndex, 1);
                    continue;
                }

                let itemValue = 0;
                const weaponData = equipment.weapons.find(w => w.name === itemName);
                const armorData = equipment.armor.find(a => a.name === itemName);
                const shieldData = equipment.shields && equipment.shields.find(s => s.name === itemName);
                const helmetData = equipment.helmets.find(h => h.name === itemName);
                const glovesData = equipment.gloves.find(g => g.name === itemName);
                const bootsData = equipment.boots.find(b => b.name === itemName);
                const braceletData = equipment.bracelets.find(b => b.name === itemName);
                const shoulderData = equipment.shoulderItems && equipment.shoulderItems.find(s => s.name === itemName);
                const treasureData = treasures.find(t => t.name === itemName);

                if (weaponData) itemValue = Math.floor(weaponData.value * 0.6);
                else if (armorData) itemValue = Math.floor(armorData.value * 0.6);
                else if (shieldData) itemValue = Math.floor(shieldData.value * 0.6);
                else if (helmetData) itemValue = Math.floor(helmetData.value * 0.6);
                else if (glovesData) itemValue = Math.floor(glovesData.value * 0.6);
                else if (bootsData) itemValue = Math.floor(bootsData.value * 0.6);
                else if (braceletData) itemValue = Math.floor(braceletData.value * 0.6);
                else if (shoulderData) itemValue = Math.floor(shoulderData.value * 0.6);
                else if (treasureData) itemValue = treasureData.value;
                else itemValue = 20;

                game.player.inventory.splice(itemIndex, 1);
                totalGold += itemValue;
                soldItems.push(itemName);
            }

            game.player.gold += totalGold;
            game.player.junkBag = [];

            speak(`Sold ${soldItems.length} items for ${totalGold} gold! Total gold: ${game.player.gold}.`);
        }
        function equipRing(command) {
            const ringsInInventory = game.player.inventory.filter(item => rings.some(r => r.name === item));
            
            if (ringsInInventory.length === 0) {
                speak('You have no rings in your inventory.');
                return;
            }
            
            let ringToEquip = null;
            for (let ring of ringsInInventory) {
                if (command.includes(ring.toLowerCase())) {
                    ringToEquip = ring;
                    break;
                }
            }
            
            if (!ringToEquip) {
                speak(`Available rings: ${ringsInInventory.join(', ')}. Say which ring to equip.`);
                return;
            }
            
            const index = game.player.inventory.indexOf(ringToEquip);
            game.player.inventory.splice(index, 1);
            equipRingDirect(ringToEquip);
        }

        function equipRingDirect(ringName) {
            const ringData = rings.find(r => r.name === ringName);
            
            if (game.player.equippedRings.length >= 10) {
                speak('You already have 10 rings equipped. Say "remove ring" to make space.');
                game.player.inventory.push(ringName);
                return;
            }
            
            game.player.equippedRings.push(ringName);
            
            if (ringData.stat === 'maxHealth') {
                game.player.maxHealth += ringData.value;
                game.player.health += ringData.value;
                speak(`You equip ${ringName}. Max health increased by ${ringData.value}!`);
            } else if (ringData.stat === 'maxMana') {
                game.player.maxMana += ringData.value;
                game.player.mana += ringData.value;
                speak(`You equip ${ringName}. Max mana increased by ${ringData.value}!`);
            } else if (ringData.stat === 'attack') {
                speak(`You equip ${ringName}. Attack damage increased by ${ringData.value}!`);
            } else if (ringData.stat === 'regen') {
                speak(`You equip ${ringName}. You will regenerate ${ringData.value} health per turn in combat!`);
            }
            
            autoManageInventory(ringName);
        }

        function removeRing(command) {
            if (game.player.equippedRings.length === 0) {
                speak('You have no rings equipped.');
                return;
            }
            
            let ringToRemove = null;
            for (let ring of game.player.equippedRings) {
                if (command.includes(ring.toLowerCase())) {
                    ringToRemove = ring;
                    break;
                }
            }
            
            if (!ringToRemove) {
                const uniqueRings = [...new Set(game.player.equippedRings)];
                speak(`Equipped rings: ${uniqueRings.join(', ')}. Say which ring to remove.`);
                return;
            }
            
            const index = game.player.equippedRings.indexOf(ringToRemove);
            game.player.equippedRings.splice(index, 1);
            
            const ringData = rings.find(r => r.name === ringToRemove);
            
            if (ringData.stat === 'maxHealth') {
                game.player.maxHealth -= ringData.value;
                game.player.health = Math.min(game.player.health, game.player.maxHealth);
            } else if (ringData.stat === 'maxMana') {
                game.player.maxMana -= ringData.value;
                game.player.mana = Math.min(game.player.mana, game.player.maxMana);
            }
            
            game.player.inventory.push(ringToRemove);
            speak(`You remove ${ringToRemove}.`);
        }

        function equipAmulet(command) {
            const amuletsInInventory = game.player.inventory.filter(item => amulets.some(a => a.name === item));
            
            if (amuletsInInventory.length === 0) {
                speak('You have no amulets in your inventory.');
                return;
            }
            
            let amuletToEquip = null;
            for (let amulet of amuletsInInventory) {
                if (command.includes(amulet.toLowerCase())) {
                    amuletToEquip = amulet;
                    break;
                }
            }
            
            if (!amuletToEquip) {
                speak(`Available amulets: ${amuletsInInventory.join(', ')}. Say which amulet to equip.`);
                return;
            }
            
            const index = game.player.inventory.indexOf(amuletToEquip);
            game.player.inventory.splice(index, 1);
            equipAmuletDirect(amuletToEquip);
        }

        function equipAmuletDirect(amuletName) {
            const amuletData = amulets.find(a => a.name === amuletName);
            
            if (game.player.equippedAmulet) {
                const oldAmuletData = amulets.find(a => a.name === game.player.equippedAmulet);
                if (oldAmuletData) {
                    if (oldAmuletData.stat === 'maxHealth') {
                        game.player.maxHealth -= oldAmuletData.value;
                        game.player.health = Math.min(game.player.health, game.player.maxHealth);
                    } else if (oldAmuletData.stat === 'maxMana') {
                        game.player.maxMana -= oldAmuletData.value;
                        game.player.mana = Math.min(game.player.mana, game.player.maxMana);
                    }
                }
                game.player.inventory.push(game.player.equippedAmulet);
            }
            
            game.player.equippedAmulet = amuletName;
            
            if (amuletData.stat === 'maxHealth') {
                game.player.maxHealth += amuletData.value;
                game.player.health += amuletData.value;
                speak(`You equip ${amuletName}. Max health increased by ${amuletData.value}!`);
            } else if (amuletData.stat === 'maxMana') {
                game.player.maxMana += amuletData.value;
                game.player.mana += amuletData.value;
                speak(`You equip ${amuletName}. Max mana increased by ${amuletData.value}!`);
            } else if (amuletData.stat === 'attack') {
                speak(`You equip ${amuletName}. Attack damage increased by ${amuletData.value}!`);
            } else if (amuletData.stat === 'expGain') {
                speak(`You equip ${amuletName}. Experience gain increased by 20%!`);
            }
            
            autoManageInventory(amuletName);
        }

        function equipBracelet(command) {
            const braceletsInInventory = game.player.inventory.filter(item => 
                equipment.bracelets.some(b => b.name === item) ||
                merchantItems.some(m => m.name === item && m.type === 'bracelet')
            );
            
            if (braceletsInInventory.length === 0) {
                speak('You have no bracelets in your inventory.');
                return;
            }
            
            let braceletToEquip = null;
            for (let bracelet of braceletsInInventory) {
                if (command.includes(bracelet.toLowerCase())) {
                    braceletToEquip = bracelet;
                    break;
                }
            }
            
            if (!braceletToEquip) {
                speak(`Available bracelets: ${braceletsInInventory.join(', ')}. Say which bracelet to equip.`);
                return;
            }
            
            if (game.player.equippedBracelets.length >= 2) {
                speak('You already have 2 bracelets equipped. Say "remove bracelet" to make space.');
                return;
            }
            
            const index = game.player.inventory.indexOf(braceletToEquip);
            game.player.inventory.splice(index, 1);
            
            const braceletData = equipment.bracelets.find(b => b.name === braceletToEquip) ||
                                 merchantItems.find(m => m.name === braceletToEquip && m.type === 'bracelet');
            
            game.player.equippedBracelets.push(braceletToEquip);
            
            if (braceletData.mana) {
                game.player.maxMana += braceletData.mana;
                game.player.mana += braceletData.mana;
            }
            
            speak(`You equip ${braceletToEquip}. Attack +${braceletData.attack}, Mana +${braceletData.mana}!`);
        }

        function removeBracelet(command) {
            if (game.player.equippedBracelets.length === 0) {
                speak('You have no bracelets equipped.');
                return;
            }
            
            let braceletToRemove = null;
            for (let bracelet of game.player.equippedBracelets) {
                if (command.includes(bracelet.toLowerCase())) {
                    braceletToRemove = bracelet;
                    break;
                }
            }
            
            if (!braceletToRemove) {
                speak(`Equipped bracelets: ${game.player.equippedBracelets.join(', ')}. Say which bracelet to remove.`);
                return;
            }
            
            const index = game.player.equippedBracelets.indexOf(braceletToRemove);
            game.player.equippedBracelets.splice(index, 1);
            
            const braceletData = equipment.bracelets.find(b => b.name === braceletToRemove) ||
                                 merchantItems.find(m => m.name === braceletToRemove && m.type === 'bracelet');
            
            if (braceletData && braceletData.mana) {
                game.player.maxMana -= braceletData.mana;
                game.player.mana = Math.min(game.player.mana, game.player.maxMana);
            }
            
            game.player.inventory.push(braceletToRemove);
            speak(`You remove ${braceletToRemove}.`);
        }

        function equipShoulderItem(command) {
            if (!equipment.shoulderItems) {
                speak('Shoulder items are not available yet.');
                return;
            }
            
            const shoulderItemsInInventory = game.player.inventory.filter(item => 
                equipment.shoulderItems.some(s => s.name === item)
            );
            
            if (shoulderItemsInInventory.length === 0) {
                speak('You have no shoulder items in your inventory.');
                return;
            }
            
            let itemToEquip = null;
            for (let item of shoulderItemsInInventory) {
                if (command.includes(item.toLowerCase())) {
                    itemToEquip = item;
                    break;
                }
            }
            
            if (!itemToEquip) {
                speak(`Available shoulder items: ${shoulderItemsInInventory.join(', ')}. Say which to equip.`);
                return;
            }
            
            const itemData = equipment.shoulderItems.find(s => s.name === itemToEquip);
            
            if (itemData.class && itemData.class !== game.player.class) {
                speak(`${itemToEquip} is not for your class.`);
                return;
            }
            
            if (game.player.equippedShoulderItem) {
                game.player.inventory.push(game.player.equippedShoulderItem);
            }
            
            const index = game.player.inventory.indexOf(itemToEquip);
            game.player.inventory.splice(index, 1);
            
            game.player.equippedShoulderItem = itemToEquip;
            speak(`You equip ${itemToEquip}. ${itemData.description}!`);
        }

        function equipItem(command) {
            const equipmentItems = game.player.inventory.filter(item => {
                return equipment.weapons.some(w => w.name === item) ||
                       equipment.armor.some(a => a.name === item) ||
                       (equipment.shields && equipment.shields.some(s => s.name === item)) ||
                       equipment.helmets.some(h => h.name === item) ||
                       equipment.gloves.some(g => g.name === item) ||
                       equipment.boots.some(b => b.name === item) ||
                       merchantItems.some(m => (m.type === 'weapon' || m.type === 'armor' || m.type === 'shield' || 
                                                m.type === 'helmet' || m.type === 'gloves' || m.type === 'boots') && m.name === item);
            });
            
            if (equipmentItems.length === 0) {
                speak('You have no equipment to equip.');
                return;
            }
            
            let itemToEquip = null;
            for (let item of equipmentItems) {
                if (command.includes(item.toLowerCase())) {
                    itemToEquip = item;
                    break;
                }
            }
            
            if (!itemToEquip) {
                speak(`Available equipment: ${equipmentItems.join(', ')}. Say which to equip.`);
                return;
            }
            
            equipItemDirect(itemToEquip);
        }

        function equipItemDirect(itemName) {
            const weaponData = equipment.weapons.find(w => w.name === itemName) ||
                              merchantItems.find(m => m.name === itemName && m.type === 'weapon');
            const armorData = equipment.armor.find(a => a.name === itemName) ||
                             merchantItems.find(m => m.name === itemName && m.type === 'armor');
            const shieldData = (equipment.shields && equipment.shields.find(s => s.name === itemName)) ||
                              merchantItems.find(m => m.name === itemName && m.type === 'shield');
            const helmetData = equipment.helmets.find(h => h.name === itemName) ||
                              merchantItems.find(m => m.name === itemName && m.type === 'helmet');
            const glovesData = equipment.gloves.find(g => g.name === itemName) ||
                              merchantItems.find(m => m.name === itemName && m.type === 'gloves');
            const bootsData = equipment.boots.find(b => b.name === itemName) ||
                             merchantItems.find(m => m.name === itemName && m.type === 'boots');
            
            if (weaponData) {
                if (weaponData.class && weaponData.class !== game.player.class) {
                    speak(`${itemName} is not for your class.`);
                    return;
                }
                
                if (game.player.weapon) {
                    game.player.inventory.push(game.player.weapon);
                    const oldWeaponData = equipment.weapons.find(w => w.name === game.player.weapon) ||
                                         merchantItems.find(m => m.name === game.player.weapon && m.type === 'weapon');
                    if (oldWeaponData && oldWeaponData.mana) {
                        game.player.maxMana -= oldWeaponData.mana;
                        game.player.mana = Math.min(game.player.mana, game.player.maxMana);
                    }
                }
                
                const index = game.player.inventory.indexOf(itemName);
                if (index !== -1) game.player.inventory.splice(index, 1);
                
                game.player.weapon = itemName;
                game.player.baseAttack = weaponData.attack;
                
                if (weaponData.mana) {
                    game.player.maxMana += weaponData.mana;
                    game.player.mana += weaponData.mana;
                    speak(`You equip ${itemName}. Attack ${weaponData.attack}, Mana +${weaponData.mana}!`);
                } else {
                    speak(`You equip ${itemName}. Attack ${weaponData.attack}!`);
                }
            } else if (armorData) {
                if (armorData.class && armorData.class !== game.player.class) {
                    speak(`${itemName} is not for your class.`);
                    return;
                }
                
                if (game.player.armor) {
                    game.player.inventory.push(game.player.armor);
                    const oldArmorData = equipment.armor.find(a => a.name === game.player.armor) ||
                                        merchantItems.find(m => m.name === game.player.armor && m.type === 'armor');
                    if (oldArmorData && oldArmorData.mana) {
                        game.player.maxMana -= oldArmorData.mana;
                        game.player.mana = Math.min(game.player.mana, game.player.maxMana);
                    }
                }
                
                const index = game.player.inventory.indexOf(itemName);
                if (index !== -1) game.player.inventory.splice(index, 1);
                
                game.player.armor = itemName;
                recalculateDefense();
                
                if (armorData.mana) {
                    game.player.maxMana += armorData.mana;
                    game.player.mana += armorData.mana;
                    speak(`You equip ${itemName}. Defense ${armorData.defense}, Mana +${armorData.mana}!`);
                } else {
                    speak(`You equip ${itemName}. Defense ${armorData.defense}!`);
                }
            } else if (shieldData) {
                if (shieldData.class && shieldData.class !== game.player.class) {
                    speak(`${itemName} is not for your class.`);
                    return;
                }
                
                if (game.player.shield) {
                    game.player.inventory.push(game.player.shield);
                }
                
                const index = game.player.inventory.indexOf(itemName);
                if (index !== -1) game.player.inventory.splice(index, 1);
                
                game.player.shield = itemName;
                recalculateDefense();
                speak(`You equip ${itemName}. Defense ${shieldData.defense}!`);
            } else if (helmetData) {
                if (helmetData.class && helmetData.class !== game.player.class) {
                    speak(`${itemName} is not for your class.`);
                    return;
                }
                
                if (game.player.helmet) {
                    game.player.inventory.push(game.player.helmet);
                    const oldHelmetData = equipment.helmets.find(h => h.name === game.player.helmet) ||
                                         merchantItems.find(m => m.name === game.player.helmet && m.type === 'helmet');
                    if (oldHelmetData && oldHelmetData.mana) {
                        game.player.maxMana -= oldHelmetData.mana;
                        game.player.mana = Math.min(game.player.mana, game.player.maxMana);
                    }
                }
                
                const index = game.player.inventory.indexOf(itemName);
                if (index !== -1) game.player.inventory.splice(index, 1);
                
                game.player.helmet = itemName;
                
                if (helmetData.defense) {
                    recalculateDefense();
                    speak(`You equip ${itemName}. Defense ${helmetData.defense}!`);
                } else if (helmetData.mana) {
                    game.player.maxMana += helmetData.mana;
                    game.player.mana += helmetData.mana;
                    speak(`You equip ${itemName}. Mana +${helmetData.mana}!`);
                }
            } else if (glovesData) {
                if (glovesData.class && glovesData.class !== game.player.class) {
                    speak(`${itemName} is not for your class.`);
                    return;
                }
                
                if (game.player.gloves) {
                    game.player.inventory.push(game.player.gloves);
                    const oldGlovesData = equipment.gloves.find(g => g.name === game.player.gloves) ||
                                         merchantItems.find(m => m.name === game.player.gloves && m.type === 'gloves');
                    if (oldGlovesData && oldGlovesData.mana) {
                        game.player.maxMana -= oldGlovesData.mana;
                        game.player.mana = Math.min(game.player.mana, game.player.maxMana);
                    }
                }
                
                const index = game.player.inventory.indexOf(itemName);
                if (index !== -1) game.player.inventory.splice(index, 1);
                
                game.player.gloves = itemName;
                
                if (glovesData.mana) {
                    game.player.maxMana += glovesData.mana;
                    game.player.mana += glovesData.mana;
                    speak(`You equip ${itemName}. Mana +${glovesData.mana}!`);
                } else {
                    speak(`You equip ${itemName}. Attack +${glovesData.attack}!`);
                }
            } else if (bootsData) {
                if (bootsData.class && bootsData.class !== game.player.class) {
                    speak(`${itemName} is not for your class.`);
                    return;
                }
                
                if (game.player.boots) {
                    game.player.inventory.push(game.player.boots);
                    const oldBootsData = equipment.boots.find(b => b.name === game.player.boots) ||
                                        merchantItems.find(m => m.name === game.player.boots && m.type === 'boots');
                    if (oldBootsData && oldBootsData.mana) {
                        game.player.maxMana -= oldBootsData.mana;
                        game.player.mana = Math.min(game.player.mana, game.player.maxMana);
                    }
                }
                
                const index = game.player.inventory.indexOf(itemName);
                if (index !== -1) game.player.inventory.splice(index, 1);
                
                game.player.boots = itemName;
                
                if (bootsData.defense) {
                    recalculateDefense();
                    speak(`You equip ${itemName}. Defense ${bootsData.defense}!`);
                } else if (bootsData.mana) {
                    game.player.maxMana += bootsData.mana;
                    game.player.mana += bootsData.mana;
                    speak(`You equip ${itemName}. Mana +${bootsData.mana}!`);
                }
            }
        }

        function talkToMerchant() {
            if (game.currentRoom.type !== 'merchant') {
                speak('There is no merchant here.');
                return;
            }
            game.merchantOpen = true;
            speak('A mysterious merchant greets you. Say "what do you have" to see wares, "buy" to purchase, "sell junk" to sell marked items, or "leave" to exit.');
        }

        function buyFromMerchant(command) {
            let itemToBuy = null;
            
            for (let item of merchantItems) {
                if (command.includes(item.name.toLowerCase())) {
                    if (item.minLevel && game.dungeon.currentLevel < item.minLevel) {
                        speak(`${item.name} requires dungeon level ${item.minLevel}. Come back later.`);
                        return;
                    }
                    if (item.type === 'weapon' || item.type === 'armor' || item.type === 'helmet' || 
                        item.type === 'gloves' || item.type === 'boots' || item.type === 'shield' || item.type === 'bracelet') {
                        if (item.class === game.player.class || !item.class) {
                            itemToBuy = item;
                            break;
                        }
                    } else {
                        itemToBuy = item;
                        break;
                    }
                }
            }

            if (!itemToBuy) {
                speak('Item not recognized or not for your class. Say "what do you have" to see available items.');
                return;
            }

            if (game.player.gold < itemToBuy.price) {
                speak(`Not enough gold. You need ${itemToBuy.price} gold but only have ${game.player.gold}.`);
                return;
            }

            game.player.gold -= itemToBuy.price;
            game.player.inventory.push(itemToBuy.name);
            speak(`You bought ${itemToBuy.name} for ${itemToBuy.price} gold. Remaining gold: ${game.player.gold}.`);
        }

        function listMerchantWares() {
            const messages = ['The merchant offers:'];
            const level = game.dungeon.currentLevel;
            
            merchantItems.forEach(item => {
                if (item.minLevel && level < item.minLevel) return;
                
                if (item.type === 'weapon' && item.class === game.player.class) {
                    let itemDesc = `${item.name} for ${item.price} gold. Attack ${item.attack}.`;
                    if (item.description) itemDesc += ` ${item.description}.`;
                    messages.push(itemDesc);
                } else if (item.type === 'armor' && item.class === game.player.class) {
                    let itemDesc = `${item.name} for ${item.price} gold. Defense ${item.defense}.`;
                    if (item.description) itemDesc += ` ${item.description}.`;
                    messages.push(itemDesc);
                } else if (item.type === 'shield' && (!item.class || item.class === game.player.class)) {
                    let itemDesc = `${item.name} for ${item.price} gold. Defense ${item.defense}.`;
                    if (item.description) itemDesc += ` ${item.description}.`;
                    messages.push(itemDesc);
                } else if (item.type === 'helmet' && (!item.class || item.class === game.player.class)) {
                    let itemDesc = `${item.name} for ${item.price} gold.`;
                    if (item.defense) itemDesc += ` Defense ${item.defense}.`;
                    if (item.mana) itemDesc += ` Mana ${item.mana}.`;
                    if (item.description) itemDesc += ` ${item.description}.`;
                    messages.push(itemDesc);
                } else if (item.type === 'gloves' && (!item.class || item.class === game.player.class)) {
                    let itemDesc = `${item.name} for ${item.price} gold.`;
                    if (item.attack) itemDesc += ` Attack ${item.attack}.`;
                    if (item.mana) itemDesc += ` Mana ${item.mana}.`;
                    if (item.description) itemDesc += ` ${item.description}.`;
                    messages.push(itemDesc);
                } else if (item.type === 'boots' && (!item.class || item.class === game.player.class)) {
                    let itemDesc = `${item.name} for ${item.price} gold.`;
                    if (item.defense) itemDesc += ` Defense ${item.defense}.`;
                    if (item.mana) itemDesc += ` Mana ${item.mana}.`;
                    if (item.health) itemDesc += ` Health ${item.health}.`;
                    if (item.description) itemDesc += ` ${item.description}.`;
                    messages.push(itemDesc);
                } else if (item.type === 'bracelet') {
                    let itemDesc = `${item.name} for ${item.price} gold. Attack ${item.attack}, Mana ${item.mana}.`;
                    if (item.description) itemDesc += ` ${item.description}.`;
                    messages.push(itemDesc);
                } else if (item.type === 'potion') {
                    messages.push(`${item.name} for ${item.price} gold.`);
                } else if (item.type === 'special_potion') {
                    messages.push(`${item.name} for ${item.price} gold. ${item.description}.`);
                }
            });
            messages.push('Say "buy" followed by the item name to purchase.');
            speakSequence(messages);
        }
        function processPotionCommand(command) {
            const potionTypes = ['Large Health Potion', 'Greater Health Potion', 'Supreme Health Potion', 'Ultimate Health Potion', 'Godly Health Elixir',
                                'Large Mana Potion', 'Greater Mana Potion', 'Supreme Mana Potion', 'Ultimate Mana Potion', 'Godly Mana Elixir',
                                'Elixir of Immortality', 'Potion of Giant Strength', 'Elixir of Clarity'];
            
            let potionType = null;
            for (let potion of potionTypes) {
                if (command.includes(potion.toLowerCase()) || 
                    (potion.includes('Health') && (command.includes('health') || command.includes('heal'))) ||
                    (potion.includes('Mana') && command.includes('mana'))) {
                    if (game.player.inventory.includes(potion)) {
                        potionType = potion;
                        break;
                    }
                }
            }
            
            if (!potionType) {
                const availablePotions = game.player.inventory.filter(item => potionTypes.includes(item));
                if (availablePotions.length === 0) {
                    speak('You have no potions.');
                } else {
                    speak(`Available potions: ${availablePotions.join(', ')}. Say which potion to use.`);
                }
                return;
            }
            
            const index = game.player.inventory.indexOf(potionType);
            game.player.inventory.splice(index, 1);
            
            if (potionType === 'Large Health Potion') {
                const heal = 50;
                const oldHealth = game.player.health;
                game.player.health = Math.min(game.player.maxHealth, game.player.health + heal);
                const actualHeal = game.player.health - oldHealth;
                speak(`You drink a large health potion and restore ${actualHeal} health. Health: ${game.player.health}.`, () => {
                    if (game.combat) {
                        setTimeout(() => enemyTurn(), 1000);
                    }
                });
            } else if (potionType === 'Greater Health Potion') {
                const heal = 100;
                const oldHealth = game.player.health;
                game.player.health = Math.min(game.player.maxHealth, game.player.health + heal);
                const actualHeal = game.player.health - oldHealth;
                speak(`You drink a greater health potion and restore ${actualHeal} health. Health: ${game.player.health}.`, () => {
                    if (game.combat) {
                        setTimeout(() => enemyTurn(), 1000);
                    }
                });
            } else if (potionType === 'Supreme Health Potion') {
                const heal = 300;
                const oldHealth = game.player.health;
                game.player.health = Math.min(game.player.maxHealth, game.player.health + heal);
                const actualHeal = game.player.health - oldHealth;
                speak(`You drink a supreme health potion and restore ${actualHeal} health. Health: ${game.player.health}.`, () => {
                    if (game.combat) {
                        setTimeout(() => enemyTurn(), 1000);
                    }
                });
            } else if (potionType === 'Ultimate Health Potion') {
                const heal = 800;
                const oldHealth = game.player.health;
                game.player.health = Math.min(game.player.maxHealth, game.player.health + heal);
                const actualHeal = game.player.health - oldHealth;
                speak(`You drink an ultimate health potion and restore ${actualHeal} health. Health: ${game.player.health}.`, () => {
                    if (game.combat) {
                        setTimeout(() => enemyTurn(), 1000);
                    }
                });
            } else if (potionType === 'Godly Health Elixir') {
                const heal = 2000;
                const oldHealth = game.player.health;
                game.player.health = Math.min(game.player.maxHealth, game.player.health + heal);
                const actualHeal = game.player.health - oldHealth;
                speak(`You drink a godly health elixir and restore ${actualHeal} health. Health: ${game.player.health}.`, () => {
                    if (game.combat) {
                        setTimeout(() => enemyTurn(), 1000);
                    }
                });
            } else if (potionType === 'Large Mana Potion') {
                const restore = 30;
                const oldMana = game.player.mana;
                game.player.mana = Math.min(game.player.maxMana, game.player.mana + restore);
                const actualRestore = game.player.mana - oldMana;
                speak(`You drink a large mana potion and restore ${actualRestore} mana. Mana: ${game.player.mana}.`, () => {
                    if (game.combat) {
                        setTimeout(() => enemyTurn(), 1000);
                    }
                });
            } else if (potionType === 'Greater Mana Potion') {
                const restore = 75;
                const oldMana = game.player.mana;
                game.player.mana = Math.min(game.player.maxMana, game.player.mana + restore);
                const actualRestore = game.player.mana - oldMana;
                speak(`You drink a greater mana potion and restore ${actualRestore} mana. Mana: ${game.player.mana}.`, () => {
                    if (game.combat) {
                        setTimeout(() => enemyTurn(), 1000);
                    }
                });
            } else if (potionType === 'Supreme Mana Potion') {
                const restore = 200;
                const oldMana = game.player.mana;
                game.player.mana = Math.min(game.player.maxMana, game.player.mana + restore);
                const actualRestore = game.player.mana - oldMana;
                speak(`You drink a supreme mana potion and restore ${actualRestore} mana. Mana: ${game.player.mana}.`, () => {
                    if (game.combat) {
                        setTimeout(() => enemyTurn(), 1000);
                    }
                });
            } else if (potionType === 'Ultimate Mana Potion') {
                const restore = 500;
                const oldMana = game.player.mana;
                game.player.mana = Math.min(game.player.maxMana, game.player.mana + restore);
                const actualRestore = game.player.mana - oldMana;
                speak(`You drink an ultimate mana potion and restore ${actualRestore} mana. Mana: ${game.player.mana}.`, () => {
                    if (game.combat) {
                        setTimeout(() => enemyTurn(), 1000);
                    }
                });
            } else if (potionType === 'Godly Mana Elixir') {
                const restore = 1500;
                const oldMana = game.player.mana;
                game.player.mana = Math.min(game.player.maxMana, game.player.mana + restore);
                const actualRestore = game.player.mana - oldMana;
                speak(`You drink a godly mana elixir and restore ${actualRestore} mana. Mana: ${game.player.mana}.`, () => {
                    if (game.combat) {
                        setTimeout(() => enemyTurn(), 1000);
                    }
                });
            } else if (potionType === 'Elixir of Immortality') {
                game.player.activeEffects.push({ type: 'revive', uses: 1 });
                speak(`You drink the Elixir of Immortality! You will revive once if you die.`, () => {
                    if (game.combat) {
                        setTimeout(() => enemyTurn(), 1000);
                    }
                });
            } else if (potionType === 'Potion of Giant Strength') {
                game.player.activeEffects.push({ type: 'strength', battles: 3 });
                speak(`You drink the Potion of Giant Strength! Your attacks deal double damage for 3 battles!`, () => {
                    if (game.combat) {
                        setTimeout(() => enemyTurn(), 1000);
                    }
                });
            } else if (potionType === 'Elixir of Clarity') {
                game.player.activeEffects.push({ type: 'clarity', battles: 3 });
                speak(`You drink the Elixir of Clarity! All spells cost 50% less mana for 3 battles!`, () => {
                    if (game.combat) {
                        setTimeout(() => enemyTurn(), 1000);
                    }
                });
            }
        }

        function readBook(command) {
            const abilityBooks = game.player.inventory.filter(item => abilities.some(a => a.name === item));
            
            if (abilityBooks.length === 0) {
                speak('You have no ability books to read.');
                return;
            }
            
            let bookToRead = null;
            for (let book of abilityBooks) {
                if (command.includes(book.toLowerCase())) {
                    bookToRead = book;
                    break;
                }
            }
            
            if (!bookToRead) {
                speak(`Available books: ${abilityBooks.join(', ')}. Say which book to read.`);
                return;
            }
            
            readBookDirect(bookToRead);
        }

        function readBookDirect(bookName) {
            const abilityData = abilities.find(a => a.name === bookName);
            
            if (!abilityData) {
                speak('This is not an ability book.');
                return;
            }
            
            if (abilityData.class !== game.player.class) {
                speak(`${bookName} is not for your class.`);
                return;
            }
            
            if (game.player.learnedAbilities.includes(bookName)) {
                speak(`You already know ${bookName}.`);
                return;
            }
            
            if (abilityData.minLevel && game.dungeon.currentLevel < abilityData.minLevel) {
                speak(`${bookName} requires dungeon level ${abilityData.minLevel}. You are on level ${game.dungeon.currentLevel}.`);
                return;
            }
            
            const index = game.player.inventory.indexOf(bookName);
            if (index !== -1) game.player.inventory.splice(index, 1);
            
            game.player.learnedAbilities.push(bookName);
            speak(`You learned ${bookName}! ${abilityData.description}. Damage: ${abilityData.damage}. Cost: ${abilityData.cost} mana.`);
        }

        function unlearnAbility(command) {
            if (game.player.learnedAbilities.length === 0) {
                speak('You have not learned any abilities.');
                return;
            }
            
            let abilityToUnlearn = null;
            for (let ability of game.player.learnedAbilities) {
                if (command.includes(ability.toLowerCase())) {
                    abilityToUnlearn = ability;
                    break;
                }
            }
            
            if (!abilityToUnlearn) {
                speak(`Learned abilities: ${game.player.learnedAbilities.join(', ')}. Say which to unlearn.`);
                return;
            }
            
            const index = game.player.learnedAbilities.indexOf(abilityToUnlearn);
            game.player.learnedAbilities.splice(index, 1);
            game.player.inventory.push(abilityToUnlearn);
            speak(`You forgot ${abilityToUnlearn}. The book has been returned to your inventory.`);
        }

        function useLockpicks() {
            if (!game.player.inventory.includes('Lockpicks')) {
                speak('You do not have lockpicks.');
                return;
            }
            
            if (game.currentRoom.type === 'treasure' && !game.currentRoom.searched) {
                speak('You use your lockpicks on a locked chest...');
                setTimeout(() => openChest(), 2000);
            } else {
                speak('There is nothing here to pick.');
            }
        }

        function meditate() {
            if (game.combat) {
                speak('You cannot meditate during combat!');
                return;
            }
            
            if (game.player.mana === game.player.maxMana) {
                speak('You are already at full mana.');
                return;
            }
            
            const tier = Math.floor(game.dungeon.currentLevel / 10);
            const baseRestore = 25;
            const manaRestored = baseRestore * Math.pow(2, tier);
            const previousMana = game.player.mana;
            
            game.player.mana = Math.min(game.player.maxMana, game.player.mana + manaRestored);
            const actualRestored = game.player.mana - previousMana;

            speak(`You meditate and restore ${actualRestored} mana. Current mana: ${game.player.mana}.`);
        }
        function selectClass(className) {
            const classData = classes[className];
            game.player.class = className;
            game.player.health = classData.health;
            game.player.maxHealth = classData.maxHealth;
            game.player.mana = classData.mana;
            game.player.maxMana = classData.maxMana;
            game.player.gold = classData.gold;
            game.player.inventory = [...classData.items];
            game.player.equippedRings = [];
            game.player.equippedBracelets = [];
            game.player.learnedAbilities = [];
            game.player.equippedAmulet = '';
            game.player.equippedShoulderItem = '';
            
            game.player.weapon = classData.items.find(item => equipment.weapons.some(w => w.name === item)) || '';
            game.player.armor = classData.items.find(item => equipment.armor.some(a => a.name === item)) || '';
            game.player.shield = '';
            game.player.helmet = '';
            game.player.gloves = '';
            game.player.boots = '';
            
            if (equipment.shields) {
                const foundShield = classData.items.find(item => equipment.shields.some(s => s.name === item));
                if (foundShield) {
                    game.player.shield = foundShield;
                }
            }
            
            const weaponData = equipment.weapons.find(w => w.name === game.player.weapon);
            game.player.baseAttack = weaponData ? weaponData.attack : 15;
            
            const armorData = equipment.armor.find(a => a.name === game.player.armor);
            game.player.defense = armorData ? armorData.defense : 0;
            
            if (game.player.shield && equipment.shields) {
                const shieldData = equipment.shields.find(s => s.name === game.player.shield);
                if (shieldData) {
                    game.player.defense += shieldData.defense;
                }
            }
            
            game.needsClass = false;
            game.started = true;
            game.phase = 'exploration';
            
            generateDungeon();
            
            let messages = [
                `You are now a ${classData.name}.`,
                `Health: ${classData.health}.`,
                `Mana: ${classData.mana}.`,
                `Starting gold: ${classData.gold}.`
            ];

            if (game.player.weapon && game.player.armor) {
                messages.push(`Equipped: ${game.player.weapon} and ${game.player.armor}.`);
            }

            if (game.player.shield) {
                messages.push(`Shield: ${game.player.shield}.`);
            }

            messages.push(`Your adventure begins!`);
            
            speakSequence(messages, () => {
                setTimeout(() => describeRoom(), 1000);
            });
        }

        function generateDungeon() {
            const size = game.dungeon.size;
            const currentLevel = game.dungeon.currentLevel;
            game.dungeon.grid = {};
            
            const centerX = 6; 
            const centerY = 6;
            
            for (let x = 0; x < size; x++) {
                for (let y = 0; y < size; y++) {
                    const key = `${x},${y}`;
                    const distanceX = Math.abs(x - centerX);
                    const distanceY = Math.abs(y - centerY);
                    const distanceFromCenter = distanceX + distanceY;
                    
                    let roomData = { visited: false, searched: false, hasChest: false, fountainUsed: false };

                    if (x === centerX && y === centerY) {
                        game.dungeon.grid[key] = { 
                            type: 'entrance', 
                            description: getRandomDescription('entrance'),
                            ...roomData
                        };
                    } else if (x === size - 1 && y === size - 1) { 
                        let bossEnemy = null;
                        
                        if (currentLevel >= 30) {
                            bossEnemy = scaleEnemyForLevel(enemies.genesisLord, currentLevel);
                        } else if (currentLevel >= 20) {
                            bossEnemy = scaleEnemyForLevel(enemies.apocalypseTitan, currentLevel);
                        } else if (currentLevel >= 10) {
                            bossEnemy = scaleEnemyForLevel(enemies.voidEmperor, currentLevel);
                        } else {
                            bossEnemy = scaleEnemyForLevel(enemies.dragon, currentLevel);
                        }
                        
                        game.dungeon.grid[key] = {
                            type: 'boss',
                            description: getRandomDescription('boss'),
                            ...roomData,
                            hasChest: true,
                            enemy: bossEnemy
                        };
                    } else if (x === size - 1 && y === size - 2) { 
                        game.dungeon.grid[key] = { 
                            type: 'stairs', 
                            description: getRandomDescription('stairs'),
                            ...roomData 
                        };
                    } else {
                        let roomType = null;
                        let enemyType = null;
                        
                        const roll = Math.random();
                        const isElite = currentLevel >= 2 && Math.random() < 0.15;
                        
                        if (Math.random() < 0.1) {
                            game.dungeon.grid[key] = {
                                type: 'merchant',
                                description: getRandomDescription('merchant'),
                                ...roomData
                            };
                            continue;
                        }
                        
                        if (distanceFromCenter >= 7) {
                            if (roll < 0.5) {
                                roomType = 'enemy';
                                if (currentLevel >= 30) {
                                    if (Math.random() < 0.4) {
                                        enemyType = 'genesisLord';
                                    } else {
                                        enemyType = Math.random() < 0.5 ? 'realityBender' : 'worldEater';
                                    }
                                } else if (currentLevel >= 20) {
                                    if (Math.random() < 0.4) {
                                        enemyType = 'harbingerOfRagnarok';
                                    } else {
                                        enemyType = Math.random() < 0.5 ? 'voidBeast' : 'titanLord';
                                    }
                                } else if (currentLevel >= 10) {
                                    if (Math.random() < 0.4) {
                                        enemyType = Math.random() < 0.5 ? 'cosmicHorror' : 'titanLord';
                                    } else if (isElite) {
                                        enemyType = 'demonLord';
                                    } else {
                                        enemyType = Math.random() < 0.5 ? 'ancientDragon' : 'voidBeast';
                                    }
                                } else if (currentLevel >= 5) {
                                    if (Math.random() < 0.4) {
                                        enemyType = Math.random() < 0.5 ? 'hydra' : 'phoenixGuardian';
                                    } else if (isElite) {
                                        enemyType = 'archDemon';
                                    } else {
                                        enemyType = Math.random() < 0.5 ? 'demon' : 'vampire';
                                    }
                                } else if (isElite) {
                                    enemyType = currentLevel >= 3 ? 'archDemon' : 'elderTroll';
                                } else if (currentLevel >= 3) {
                                    enemyType = Math.random() < 0.5 ? 'demon' : 'vampire';
                                } else {
                                    enemyType = Math.random() < 0.5 ? 'troll' : 'wraith';
                                }
                            } else if (roll < 0.7) {
                                roomType = 'treasure';
                                roomData.hasChest = true;
                            } else if (roll < 0.8) {
                                roomType = 'fountain';
                            } else {
                                roomType = 'crypt';
                                roomData.hasChest = Math.random() < 0.3;
                            }
                        } else if (distanceFromCenter >= 4) {
                            if (roll < 0.45) {
                                roomType = 'enemy';
                                if (currentLevel >= 30) {
                                    if (Math.random() < 0.3) {
                                        enemyType = 'worldEater';
                                    } else if (isElite) {
                                        enemyType = 'realityBender';
                                    } else {
                                        enemyType = Math.random() < 0.5 ? 'harbingerOfRagnarok' : 'apocalypseTitan';
                                    }
                                } else if (currentLevel >= 20) {
                                    if (Math.random() < 0.3) {
                                        enemyType = 'cosmicHorror';
                                    } else if (isElite) {
                                        enemyType = 'voidBeast';
                                    } else {
                                        enemyType = Math.random() < 0.5 ? 'demonLord' : 'ancientDragon';
                                    }
                                } else if (currentLevel >= 10) {
                                    if (Math.random() < 0.3) {
                                        enemyType = 'voidBeast';
                                    } else if (isElite) {
                                        enemyType = 'ancientDragon';
                                    } else {
                                        enemyType = Math.random() < 0.5 ? 'demonLord' : 'lichKing';
                                    }
                                } else if (currentLevel >= 5) {
                                    if (Math.random() < 0.3) {
                                        enemyType = 'lichKing';
                                    } else if (isElite) {
                                        enemyType = 'elderTroll';
                                    } else {
                                        enemyType = Math.random() < 0.5 ? 'wraith' : 'troll';
                                    }
                                } else if (isElite) {
                                    enemyType = currentLevel >= 2 ? 'ancientWraith' : 'orcChieftain';
                                } else if (currentLevel >= 2) {
                                    enemyType = Math.random() < 0.5 ? 'wraith' : 'troll';
                                } else {
                                    enemyType = Math.random() < 0.6 ? 'orc' : 'skeleton';
                                }
                            } else if (roll < 0.65) {
                                roomType = 'treasure';
                                roomData.hasChest = true;
                            } else if (roll < 0.75) {
                                roomType = 'trap';
                            } else if (roll < 0.8) {
                                roomType = 'fountain';
                            } else {
                                roomType = 'empty';
                                roomData.hasChest = Math.random() < 0.2;
                            }
                        } else {
                            if (roll < 0.35) {
                                roomType = 'enemy';
                                if (isElite) {
                                    enemyType = 'orcChieftain';
                                } else if (currentLevel >= 2) {
                                    enemyType = Math.random() < 0.5 ? 'orc' : 'skeleton';
                                } else {
                                    enemyType = 'goblin';
                                }
                            } else if (roll < 0.55) {
                                roomType = 'treasure';
                                roomData.hasChest = true;
                            } else if (roll < 0.6) {
                                roomType = 'fountain';
                            } else {
                                roomType = 'empty';
                                roomData.hasChest = Math.random() < 0.15;
                            }
                        }
                        
                        if (roomType === 'enemy') {
                            let scaledEnemy = scaleEnemyForLevel(enemies[enemyType], currentLevel);
                            
                            if (currentLevel >= 3 && Math.random() < 0.2) {
                                game.dungeon.grid[key] = {
                                    type: 'enemy',
                                    description: getRandomDescription('enemy') + ' Two creatures lurk here!',
                                    ...roomData,
                                    enemy: scaledEnemy,
                                    secondEnemy: scaleEnemyForLevel(enemies[enemyType], currentLevel)
                                };
                            } else {
                                game.dungeon.grid[key] = {
                                    type: 'enemy',
                                    description: getRandomDescription('enemy'),
                                    ...roomData,
                                    enemy: scaledEnemy
                                };
                            }
                        } else {
                            game.dungeon.grid[key] = {
                                type: roomType,
                                description: getRandomDescription(roomType),
                                ...roomData
                            };
                        }
                    }
                }
            }
            
            if (Math.random() < 0.3) {
                game.dungeon.hasSecretRoom = true;
            }
            
            game.player.position = { x: 6, y: 6 };
            const key = `${game.player.position.x},${game.player.position.y}`;
            game.currentRoom = game.dungeon.grid[key];
        }

        function move(direction) {
            const { x, y } = game.player.position;
            let newX = x, newY = y;
            
            if (direction === 'north') newY--;
            else if (direction === 'south') newY++;
            else if (direction === 'east') newX++;
            else if (direction === 'west') newX--;
            
            if (newX < 0 || newX >= game.dungeon.size || newY < 0 || newY >= game.dungeon.size) {
                speak('You cannot go that way. A solid wall blocks your path.');
                return;
            }
            
            game.player.position = { x: newX, y: newY };
            const key = `${newX},${newY}`;
            game.currentRoom = game.dungeon.grid[key];
            
            if (game.currentRoom.type === 'trap') {
                if (!game.currentRoom.visited) {
                    const trapDamage = 15 + (game.dungeon.currentLevel * 5);
                    game.player.health -= trapDamage;
                    speak(`A trap springs! You take ${trapDamage} damage! Health: ${game.player.health}.`);
                    if (game.player.health <= 0) {
                        setTimeout(() => gameOver(), 1000);
                        return;
                    }
                }
            }

            game.currentRoom.visited = true;
            describeRoom();
        }

        function describeRoom() {
            const room = game.currentRoom;
            const messages = [`You are on Level ${game.dungeon.currentLevel} in ${room.description}`];
            
            if (room.type === 'stairs') {
                messages.push('Dark stairs descend deeper. Say "go down stairs" to descend.');
            } else if (room.type === 'merchant') {
                messages.push('A traveling merchant is here. Say "merchant" to trade.');
            } else if (room.type === 'fountain' && !room.fountainUsed) {
                messages.push('A magical fountain bubbles here. Say "drink fountain" to be healed.');
            } else if (room.enemy && room.enemy.health > 0) {
                if (room.secondEnemy && room.secondEnemy.health > 0) {
                    messages.push(`A ${room.enemy.name} and a ${room.secondEnemy.name} block your path!`);
                } else {
                    messages.push(`A ${room.enemy.name} blocks your path!`);
                }
                speakSequence(messages, () => {
                    setTimeout(() => startCombat(room.enemy, room.secondEnemy), 1000);
                });
                return;
            } else {
                if (room.hasChest && !room.searched) {
                    messages.push('A treasure chest glimmers in the shadows. Say "open chest" to loot it.');
                }
                if (!room.searched && room.type !== 'stairs') {
                    messages.push('You could search this room.');
                }
            }
            messages.push('Which direction will you go?');
            speakSequence(messages);
        }

        function determineLoot() {
            const level = game.dungeon.currentLevel;
            const roll = Math.random();
            const playerClass = game.player.class;
            
            if (level >= 30 && roll < 0.25) {
                const allGodly = [
                    ...equipment.weapons.filter(w => w.minLevel >= 30 && w.class === playerClass),
                    ...equipment.armor.filter(a => a.minLevel >= 30 && a.class === playerClass),
                    ...equipment.helmets.filter(h => h.minLevel >= 30 && (!h.class || h.class === playerClass)),
                    ...equipment.gloves.filter(g => g.minLevel >= 30 && (!g.class || g.class === playerClass)),
                    ...equipment.boots.filter(b => b.minLevel >= 30 && (!b.class || b.class === playerClass)),
                    ...equipment.bracelets.filter(br => br.minLevel >= 30)
                ];
                if (allGodly.length > 0) {
                    return { type: 'item', item: allGodly[Math.floor(Math.random() * allGodly.length)].name };
                }
            }
            
            if (level >= 20 && roll < 0.2) {
                const allMythic = [
                    ...equipment.weapons.filter(w => w.minLevel >= 20 && w.class === playerClass),
                    ...equipment.armor.filter(a => a.minLevel >= 20 && a.class === playerClass),
                    ...equipment.helmets.filter(h => h.minLevel >= 20 && (!h.class || h.class === playerClass)),
                    ...equipment.gloves.filter(g => g.minLevel >= 20 && (!g.class || g.class === playerClass)),
                    ...equipment.boots.filter(b => b.minLevel >= 20 && (!b.class || b.class === playerClass)),
                    ...equipment.bracelets.filter(br => br.minLevel >= 20)
                ];
                if (allMythic.length > 0) {
                    return { type: 'item', item: allMythic[Math.floor(Math.random() * allMythic.length)].name };
                }
            }
            
            if (level >= 10 && roll < 0.2) {
                const allLegendary = [
                    ...equipment.weapons.filter(w => w.minLevel >= 10 && w.class === playerClass),
                    ...equipment.armor.filter(a => a.minLevel >= 10 && a.class === playerClass),
                    ...equipment.helmets.filter(h => h.minLevel >= 10 && (!h.class || h.class === playerClass)),
                    ...equipment.gloves.filter(g => g.minLevel >= 10 && (!g.class || g.class === playerClass)),
                    ...equipment.boots.filter(b => b.minLevel >= 10 && (!b.class || b.class === playerClass)),
                    ...equipment.bracelets.filter(br => br.minLevel >= 10)
                ];
                if (allLegendary.length > 0) {
                    return { type: 'item', item: allLegendary[Math.floor(Math.random() * allLegendary.length)].name };
                }
            }
            
            if (level >= 5 && roll < 0.15) {
                const allEpic = [
                    ...equipment.weapons.filter(w => w.value > 400 && w.class === playerClass),
                    ...equipment.armor.filter(a => a.value > 400 && a.class === playerClass),
                    ...equipment.helmets.filter(h => h.minLevel >= 5 && (!h.class || h.class === playerClass)),
                    ...equipment.gloves.filter(g => g.minLevel >= 4 && (!g.class || g.class === playerClass)),
                    ...equipment.boots.filter(b => b.minLevel >= 5 && (!b.class || b.class === playerClass)),
                    ...equipment.bracelets.filter(br => br.minLevel >= 8)
                ];
                if (allEpic.length > 0) {
                    return { type: 'item', item: allEpic[Math.floor(Math.random() * allEpic.length)].name };
                }
            }
            
            if (level >= 3 && roll < 0.25) {
                const allRare = [
                    ...equipment.weapons.filter(w => w.value > 200 && w.class === playerClass),
                    ...equipment.armor.filter(a => a.value > 200 && a.class === playerClass),
                    ...equipment.helmets.filter(h => !h.minLevel || h.minLevel <= 5),
                    ...equipment.gloves.filter(g => !g.minLevel || g.minLevel <= 4),
                    ...equipment.boots.filter(b => !b.minLevel || b.minLevel <= 5),
                    ...equipment.bracelets.filter(br => !br.minLevel || br.minLevel <= 5)
                ];
                if (allRare.length > 0) {
                    return { type: 'item', item: allRare[Math.floor(Math.random() * allRare.length)].name };
                }
            }
            
            if (roll < 0.60) {
                if (level >= 30 && Math.random() < 0.5) {
                    return { type: 'item', item: Math.random() < 0.5 ? 'Godly Health Elixir' : 'Godly Mana Elixir' };
                } else if (level >= 20 && Math.random() < 0.5) {
                    return { type: 'item', item: Math.random() < 0.5 ? 'Ultimate Health Potion' : 'Ultimate Mana Potion' };
                } else if (level >= 10 && Math.random() < 0.5) {
                    return { type: 'item', item: Math.random() < 0.5 ? 'Supreme Health Potion' : 'Supreme Mana Potion' };
                } else if (level >= 5 && Math.random() < 0.6) {
                    return { type: 'item', item: Math.random() < 0.5 ? 'Greater Health Potion' : 'Greater Mana Potion' };
                } else {
                    return { type: 'item', item: Math.random() < 0.5 ? 'Large Health Potion' : 'Large Mana Potion' };
                }
            }
            if (roll < 0.70) {
                const levelRings = rings.filter(r => !r.minLevel || r.minLevel <= level);
                return { type: 'ring', item: levelRings[Math.floor(Math.random() * levelRings.length)].name };
            }
            if (roll < 0.80) {
                const levelAmulets = amulets.filter(a => !a.minLevel || a.minLevel <= level);
                return { type: 'amulet', item: levelAmulets[Math.floor(Math.random() * levelAmulets.length)].name };
            }
            
            return { type: 'gold', amount: Math.floor(Math.random() * 15) + (5 * level) };
        }

        function determineTreasure() {
            const treasure = treasures[Math.floor(Math.random() * treasures.length)];
            const level = game.dungeon.currentLevel;
            return { ...treasure, value: treasure.value * level };
        }

        function searchRoom() {
            const room = game.currentRoom;
            
            if (room.searched) {
                speak('You already searched this room thoroughly.');
                return;
            }
            
            room.searched = true;
            
            if (game.dungeon.hasSecretRoom && !game.dungeon.secretRoom && Math.random() < 0.15) {
                game.dungeon.secretRoom = true;
                speakSequence([
                    'You found a hidden passage behind a loose stone!',
                    'Inside, ancient treasures await!'
                ]);
                game.player.inventory.push('Ring of Minor Mana', 'Large Health Potion', 'Amulet of Vitality');
                game.player.gold += 30 * game.dungeon.currentLevel;
            } else {
                const loot = determineLoot();
                if (loot.type === 'gold') {
                    game.player.gold += loot.amount;
                    speak(`You found ${loot.amount} gold hidden in the shadows.`);
                } else if (loot.type === 'item') {
                    game.player.inventory.push(loot.item);
                    autoManageInventory(loot.item);
                    speak(`You found a hidden ${loot.item}!`);
                } else if (loot.type === 'ring') {
                    game.player.inventory.push(loot.item);
                    autoManageInventory(loot.item);
                    speak(`You found a mystical ${loot.item}! Say 'wear ring' to equip it.`);
                } else if (loot.type === 'amulet') {
                    game.player.inventory.push(loot.item);
                    autoManageInventory(loot.item);
                    speak(`You found a powerful ${loot.item}! Say 'equip amulet' to wear it.`);
                } else {
                    speak('You search carefully but find nothing of value.');
                }
            }
        }

        function openChest() {
            const room = game.currentRoom;
            
            if (!room.hasChest) {
                speak('There is no chest here.');
                return;
            }
            
            if (room.searched) {
                speak('The chest is empty. You already looted it.');
                return;
            }
            
            room.searched = true;
            
            if (Math.random() < 0.08) {
                const mimicDamage = 30 + (game.dungeon.currentLevel * 10);
                game.player.health -= mimicDamage;
                
                speak(`The chest springs to life! It's a mimic! You take ${mimicDamage} damage! Health: ${game.player.health}.`, () => {
                    if (game.player.health <= 0) {
                        setTimeout(() => gameOver(), 1000);
                    } else {
                        const mimic = scaleEnemyForLevel({ name: 'Mimic', health: 45, damage: 12, gold: 15, exp: 25, fleeChance: 0.5 }, game.dungeon.currentLevel);
                        setTimeout(() => startCombat(mimic), 1000);
                    }
                });
            } else {
                let messages = ['You open the ornate chest and discover:'];
                
                if (room.type === 'treasure') {
                    const treasure1 = determineTreasure();
                    const treasure2 = determineTreasure();
                    game.player.gold += treasure1.value;
                    game.player.gold += treasure2.value;
                    game.player.inventory.push(treasure1.name, treasure2.name);
                    autoManageInventory(treasure1.name);
                    autoManageInventory(treasure2.name);
                    messages.push(`${treasure1.name} worth ${treasure1.value} gold!`);
                    messages.push(`${treasure2.name} worth ${treasure2.value} gold!`);
                    
                    if (Math.random() < 0.4) {
                        const potion = Math.random() < 0.5 ? 'Large Health Potion' : 'Large Mana Potion';
                        game.player.inventory.push(potion);
                        messages.push(`A ${potion}!`);
                    }
                } else {
                    const loot1 = determineLoot();
                    const loot2 = determineLoot();
                    
                    if (loot1.type === 'gold') {
                        game.player.gold += loot1.amount;
                        messages.push(`${loot1.amount} gold.`);
                    } else if (loot1.type === 'item') {
                        game.player.inventory.push(loot1.item);
                        autoManageInventory(loot1.item);
                        messages.push(`A ${loot1.item}.`);
                    } else if (loot1.type === 'ring') {
                        game.player.inventory.push(loot1.item);
                        autoManageInventory(loot1.item);
                        messages.push(`A ${loot1.item}.`);
                    } else if (loot1.type === 'amulet') {
                        game.player.inventory.push(loot1.item);
                        autoManageInventory(loot1.item);
                        messages.push(`A ${loot1.item}.`);
                    }
                    
                    if (loot2.type === 'gold') {
                        game.player.gold += loot2.amount;
                        messages.push(`${loot2.amount} gold.`);
                    } else if (loot2.type === 'item') {
                        game.player.inventory.push(loot2.item);
                        autoManageInventory(loot2.item);
                        messages.push(`A ${loot2.item}.`);
                    } else if (loot2.type === 'ring') {
                        game.player.inventory.push(loot2.item);
                        autoManageInventory(loot2.item);
                        messages.push(`A ${loot2.item}.`);
                    } else if (loot2.type === 'amulet') {
                        game.player.inventory.push(loot2.item);
                        autoManageInventory(loot2.item);
                        messages.push(`A ${loot2.item}.`);
                    }
                }
                
                if (Math.random() < 0.25) {
                    const availableAbilities = abilities.filter(a => 
                        a.class === game.player.class && 
                        !game.player.learnedAbilities.includes(a.name) &&
                        !game.player.inventory.includes(a.name) &&
                        (!a.minLevel || a.minLevel <= game.dungeon.currentLevel)
                    );
                    
                    if (availableAbilities.length > 0) {
                        const ability = availableAbilities[Math.floor(Math.random() * availableAbilities.length)];
                        game.player.inventory.push(ability.name);
                        messages.push(`A ${ability.name} book! Say "read book" to learn it.`);
                    }
                }
                
                if (messages.length === 1) { messages.push('Nothing of value.'); }

                speakSequence(messages);
            }
        }

        function useFountain() {
            if (game.currentRoom.type !== 'fountain') {
                speak('There is no fountain here.');
                return;
            }
            if (game.currentRoom.fountainUsed) {
                speak('The fountain has run dry. Its magic is spent.');
                return;
            }
            
            game.currentRoom.fountainUsed = true;
            game.player.health = game.player.maxHealth;
            game.player.mana = game.player.maxMana;
            
            speak('You drink from the magical fountain. You are fully healed and restored!');
        }

        function useStairs() {
            if (game.currentRoom.type !== 'stairs') {
                speak('There are no stairs here.');
                return;
            }
            
            const bossKey = `${game.dungeon.size - 1},${game.dungeon.size - 1}`;
            const bossRoom = game.dungeon.grid[bossKey];
            if (bossRoom.enemy && bossRoom.enemy.health > 0) {
                speak('You must defeat the boss in the boss room first.');
                return;
            }
            
            game.dungeon.currentLevel++;
            generateDungeon(); 

            speak(`You descend to Dungeon Level ${game.dungeon.currentLevel}. The air grows colder and more dangerous.`, () => {
                describeRoom();
            });
        }
        function startCombat(enemy, secondEnemy = null) {
            game.combat = { 
                enemy: { ...enemy }, 
                secondEnemy: secondEnemy ? { ...secondEnemy } : null,
                playerDefending: false,
                twoEnemyFight: secondEnemy ? true : false,
                playerShadowmelded: false
            };
            game.phase = 'combat';
            
            let messages = [`Combat begins!`, `${enemy.name} has ${enemy.health} health.`];
            
            if (secondEnemy) {
                messages.push(`${secondEnemy.name} has ${secondEnemy.health} health.`);
                messages.push(`You face two enemies!`);
            }
            
            if (enemy.regenerate) {
                messages.push(`Warning: ${enemy.name} regenerates ${enemy.regenerate} health per turn!`);
            }
            if (secondEnemy && secondEnemy.regenerate) {
                messages.push(`Warning: ${secondEnemy.name} regenerates ${secondEnemy.regenerate} health per turn!`);
            }
            
            messages.push(`What will you do? Attack, defend, special, cast spell, use potion, or flee.`);
            
            speakSequence(messages);
        }

        function playerAttack() {
            const weaponData = equipment.weapons.find(w => w.name === game.player.weapon) ||
                               merchantItems.find(i => i.name === game.player.weapon && i.type === 'weapon');
            const weaponAttack = weaponData ? weaponData.attack : 0;
            
            let amuletBonus = 0;
            if (game.player.equippedAmulet) {
                const amuletData = amulets.find(a => a.name === game.player.equippedAmulet);
                if (amuletData && amuletData.stat === 'attack') {
                    amuletBonus = amuletData.value;
                }
            }
            
            let glovesBonus = 0;
            if (game.player.gloves) {
                const glovesData = equipment.gloves.find(g => g.name === game.player.gloves) ||
                                   merchantItems.find(i => i.name === game.player.gloves && i.type === 'gloves');
                if (glovesData && glovesData.attack) {
                    glovesBonus = glovesData.attack;
                }
            }
            
            let braceletBonus = 0;
            for (let bracelet of game.player.equippedBracelets) {
                const braceletData = equipment.bracelets.find(b => b.name === bracelet) ||
                                     merchantItems.find(i => i.name === bracelet && i.type === 'bracelet');
                if (braceletData && braceletData.attack) {
                    braceletBonus += braceletData.attack;
                }
            }
            
            let baseDamage = game.player.baseAttack + weaponAttack + amuletBonus + glovesBonus + braceletBonus;
            
            if (game.player.class === 'warrior' || game.player.class === 'rogue') {
                baseDamage += (game.player.level - 1) * 5;
            }
            
            const ringBonus = game.player.equippedRings.reduce((total, ring) => {
                const ringData = rings.find(r => r.name === ring);
                return total + (ringData && ringData.stat === 'attack' ? ringData.value : 0);
            }, 0);
            
            let damage = baseDamage + ringBonus + Math.floor(Math.random() * 10);
            
            // Shoulder item bonus
            if (game.player.equippedShoulderItem) {
                const shoulderData = equipment.shoulderItems && equipment.shoulderItems.find(s => s.name === game.player.equippedShoulderItem);
                if (shoulderData && shoulderData.effect === 'warrior_damage') {
                    damage = Math.floor(damage * (1 + shoulderData.bonus));
                }
            }
            
            const strengthEffect = game.player.activeEffects.find(e => e.type === 'strength');
            if (strengthEffect) {
                damage = Math.floor(damage * 2);
            }
            
            if (game.combat.playerShadowmelded) {
                damage = Math.floor(damage * 2);
                game.combat.playerShadowmelded = false;
            }
            
            if (game.combat.enemy.deathMarked) {
                damage = Math.floor(damage * 1.5);
            }
            
            game.combat.enemy.health -= damage;
            
            let messages = [`You attack for ${damage} damage!`];
            if (strengthEffect) {
                messages.push(`Giant Strength doubles your damage!`);
            }
            if (game.combat.enemy.deathMarked) {
                messages.push(`Death Mark amplifies your strike!`);
            }
            messages.push(`${game.combat.enemy.name} has ${Math.max(0, game.combat.enemy.health)} health left.`);
            
            speakSequence(messages, () => {
                if (game.combat.enemy.health <= 0) {
                    if (game.combat.secondEnemy && game.combat.secondEnemy.health > 0) {
                        game.combat.enemy = game.combat.secondEnemy;
                        game.combat.secondEnemy = null;
                        speak(`${game.combat.enemy.name} remains! Health: ${game.combat.enemy.health}.`, () => {
                            setTimeout(() => enemyTurn(), 1000);
                        });
                    } else {
                        setTimeout(() => combatVictory(), 1000);
                    }
                } else {
                    setTimeout(() => enemyTurn(), 1000);
                }
            });
        }

        function playerDefend() {
            game.combat.playerDefending = true;
            speak('You brace for impact.', () => {
                setTimeout(() => enemyTurn(), 1000);
            });
        }

        function playerSpecial() {
            const classData = classes[game.player.class];
            const special = classData.special;
            
            const scaledCost = getScaledAbilityCost(special.cost, game.dungeon.currentLevel);
            
            if (game.player.mana < scaledCost) {
                speak(`Not enough mana. You need ${scaledCost}.`);
                return;
            }
            
            game.player.mana -= scaledCost;
            
            if (special.type === 'damage') {
                let damage = getScaledAbilityDamage(special.damage, game.dungeon.currentLevel);
                
                if (game.player.class === 'warrior' || game.player.class === 'rogue') {
                    damage += (game.player.level - 1) * 5;
                } else if (game.player.class === 'mage') {
                    damage += (game.player.level - 1) * 6;
                }
                
                game.combat.enemy.health -= damage;
                
                speakSequence([
                    `You unleash ${special.name}!`,
                    `${damage} damage!`,
                    `${game.combat.enemy.name} has ${Math.max(0, game.combat.enemy.health)} health left.`
                ], () => {
                    if (game.combat.enemy.health <= 0) {
                        if (game.combat.secondEnemy && game.combat.secondEnemy.health > 0) {
                            game.combat.enemy = game.combat.secondEnemy;
                            game.combat.secondEnemy = null;
                            speak(`${game.combat.enemy.name} remains! Health: ${game.combat.enemy.health}.`, () => {
                                setTimeout(() => enemyTurn(), 1000);
                            });
                        } else {
                            setTimeout(() => combatVictory(), 1000);
                        }
                    } else {
                        setTimeout(() => enemyTurn(), 1000);
                    }
                });
            }
        }

        function attemptFlee() {
            const chance = game.combat.enemy.fleeChance;
            const roll = Math.random();
            
            speak(`Attempting to flee...`, () => {
                setTimeout(() => {
                    if (roll < chance) {
                        speak('You successfully escape!', () => {
                            game.combat = null;
                            game.phase = 'exploration';
                            setTimeout(() => {
                                const centerX = 6;
                                const centerY = 6;
                                game.player.position = { x: centerX, y: centerY };
                                const key = `${centerX},${centerY}`;
                                game.currentRoom = game.dungeon.grid[key];
                                speak('You flee back to the entrance.');
                            }, 1000);
                        });
                    } else {
                        speak('You fail to escape!', () => {
                            setTimeout(() => enemyTurn(), 1000);
                        });
                    }
                }, 1000);
            });
        }
        function enemyTurn() {
            let messages = [];
            
            const regenRingCount = game.player.equippedRings.filter(r => r === 'Ring of Regeneration').length;
            if (regenRingCount > 0) {
                const regenAmount = 50 * regenRingCount;
                const oldHealth = game.player.health;
                game.player.health = Math.min(game.player.maxHealth, game.player.health + regenAmount);
                const actualHeal = game.player.health - oldHealth;
                if (actualHeal > 0) {
                    messages.push(`Your Ring${regenRingCount > 1 ? 's' : ''} of Regeneration heal${regenRingCount === 1 ? 's' : ''} you for ${actualHeal} health!`);
                }
            }
            
            if (game.combat.enemy.frozen) {
                if (game.combat.enemy.timestopTurns) {
                    game.combat.enemy.timestopTurns--;
                    if (game.combat.enemy.timestopTurns <= 0) {
                        game.combat.enemy.frozen = false;
                        game.combat.enemy.timestopTurns = 0;
                    }
                } else {
                    game.combat.enemy.frozen = false;
                }
                messages.push(`${game.combat.enemy.name} is frozen and cannot act!`);
            } else if (game.combat.enemy.stunned) {
                messages.push(`${game.combat.enemy.name} is stunned and cannot act!`);
                game.combat.enemy.stunned = false;
            } else {
                if (game.combat.enemy.regenerate) {
                    game.combat.enemy.health += game.combat.enemy.regenerate;
                    messages.push(`${game.combat.enemy.name} regenerates ${game.combat.enemy.regenerate} health!`);
                }
                
                if (game.combat.enemy.poisoned) {
                    game.combat.enemy.health -= game.combat.enemy.poisoned.damage;
                    messages.push(`${game.combat.enemy.name} takes ${game.combat.enemy.poisoned.damage} poison damage!`);
                    game.combat.enemy.poisoned.duration--;
                    if (game.combat.enemy.poisoned.duration <= 0) {
                        game.combat.enemy.poisoned = null;
                    }
                    if (game.combat.enemy.health <= 0) {
                        speakSequence(messages, () => {
                            setTimeout(() => {
                                if (game.combat.secondEnemy && game.combat.secondEnemy.health > 0) {
                                    game.combat.enemy = game.combat.secondEnemy;
                                    game.combat.secondEnemy = null;
                                    speak(`${game.combat.enemy.name} remains! Health: ${game.combat.enemy.health}.`);
                                } else {
                                    combatVictory();
                                }
                            }, 1000);
                        });
                        return;
                    }
                }
                
                let damage = game.combat.enemy.damage;
                
                if (game.combat.playerDefending) {
                    damage = Math.floor(damage * 0.5);
                    game.combat.playerDefending = false;
                }
                
                const reducedDamage = Math.max(1, damage - game.player.defense);
                game.player.health -= reducedDamage;
                
                messages.push(`${game.combat.enemy.name} attacks for ${reducedDamage} damage!`);
            }
            
            if (game.combat.secondEnemy && game.combat.secondEnemy.health > 0) {
                if (game.combat.secondEnemy.frozen) {
                    if (game.combat.secondEnemy.timestopTurns) {
                        game.combat.secondEnemy.timestopTurns--;
                        if (game.combat.secondEnemy.timestopTurns <= 0) {
                            game.combat.secondEnemy.frozen = false;
                            game.combat.secondEnemy.timestopTurns = 0;
                        }
                    } else {
                        game.combat.secondEnemy.frozen = false;
                    }
                    messages.push(`${game.combat.secondEnemy.name} is frozen and cannot act!`);
                } else {
                    if (game.combat.secondEnemy.regenerate) {
                        game.combat.secondEnemy.health += game.combat.secondEnemy.regenerate;
                        messages.push(`${game.combat.secondEnemy.name} regenerates ${game.combat.secondEnemy.regenerate} health!`);
                    }
                    
                    let damage2 = game.combat.secondEnemy.damage;
                    const reducedDamage2 = Math.max(1, damage2 - game.player.defense);
                    game.player.health -= reducedDamage2;
                    messages.push(`${game.combat.secondEnemy.name} attacks for ${reducedDamage2} damage!`);
                }
            }
            
            messages.push(`Your health: ${Math.max(0, game.player.health)}.`);
            
            speakSequence(messages, () => {
                if (game.player.health <= 0) {
                    setTimeout(() => gameOver(), 1000);
                } else {
                    setTimeout(() => speak('What will you do?'), 500);
                }
            });
        }

        function combatVictory() {
            let gold = game.combat.enemy.gold;
            let exp = game.combat.enemy.exp;
            
            if (game.player.specialItems.includes('Golden Fortune Coin')) {
                gold = Math.floor(gold * 1.5);
            }
            
            const wasTwoEnemyFight = game.combat.twoEnemyFight || false;
            
            if (wasTwoEnemyFight) {
                exp = exp * 2;
            }
            
            game.player.gold += gold;
            
            if (game.currentRoom.enemy) {
                game.currentRoom.enemy.health = 0;
            }
            if (game.currentRoom.secondEnemy) {
                game.currentRoom.secondEnemy.health = 0;
            }
            
            const messages = [
                `${game.combat.enemy.name} defeated!`,
                `You gain ${gold} gold and ${exp} experience!`
            ];
            if (wasTwoEnemyFight) {
                messages.push(`Double experience for defeating 2 enemies!`);
            }
            
            const strengthEffect = game.player.activeEffects.find(e => e.type === 'strength');
            if (strengthEffect) {
                strengthEffect.battles--;
                if (strengthEffect.battles <= 0) {
                    game.player.activeEffects = game.player.activeEffects.filter(e => e.type !== 'strength');
                    messages.push(`Giant Strength effect has worn off.`);
                }
            }
            
            const clarityEffect = game.player.activeEffects.find(e => e.type === 'clarity');
            if (clarityEffect) {
                clarityEffect.battles--;
                if (clarityEffect.battles <= 0) {
                    game.player.activeEffects = game.player.activeEffects.filter(e => e.type !== 'clarity');
                    messages.push(`Clarity effect has worn off.`);
                }
            }
            
            speakSequence(messages, () => {
                game.combat = null;
                game.phase = 'exploration';
                gainExperience(exp);
                
                if (game.currentRoom.type === 'boss') {
                    setTimeout(() => dungeonComplete(), 1500);
                } else {
                    setTimeout(() => speak('What will you do next?'), 1000);
                }
            });
        }

        function castSpell(command) {
            if (!game.combat) {
                speak('You can only cast spells in combat.');
                return;
            }

            let spellToCast = null;

            for (let ability of abilities) {
                if (command.includes(ability.name.toLowerCase()) && game.player.learnedAbilities.includes(ability.name)) {
                    spellToCast = ability;
                    break;
                }
            }

            if (!spellToCast) {
                const learned = game.player.learnedAbilities.join(', ');
                if (learned) {
                    speak(`You know: ${learned}. Say which spell to cast.`);
                } else {
                    speak('You have not learned any spells yet. Find ability books in chests.');
                }
                return;
            }

            let spellCost = getScaledAbilityCost(spellToCast.cost, game.dungeon.currentLevel);
            const clarityEffect = game.player.activeEffects.find(e => e.type === 'clarity');
            
            if (clarityEffect) {
                spellCost = Math.floor(spellCost * 0.5);
            }

            if (game.player.mana < spellCost) {
                speak(`Not enough mana. You need ${spellCost} mana.`);
                return;
            }

            game.player.mana -= spellCost;

            if (spellToCast.type === 'freeze') {
                let baseDamage = getScaledAbilityDamage(spellToCast.damage, game.dungeon.currentLevel);
                const levelBonus = game.player.level * 5;
                let totalDamage = baseDamage + levelBonus;
                
                // Mage shoulder item bonus
                if (game.player.equippedShoulderItem) {
                    const shoulderData = equipment.shoulderItems && equipment.shoulderItems.find(s => s.name === game.player.equippedShoulderItem);
                    if (shoulderData && shoulderData.effect === 'mage_spell') {
                        totalDamage = Math.floor(totalDamage * (1 + shoulderData.bonus));
                    }
                }
                
                game.combat.enemy.health -= totalDamage;
                game.combat.enemy.frozen = true;

                speakSequence([
                    `You cast ${spellToCast.name}!`,
                    `Icy shards pierce the ${game.combat.enemy.name} for ${totalDamage} damage!`,
                    `The enemy is frozen solid for 1 turn!`,
                    `${game.combat.enemy.name} has ${Math.max(0, game.combat.enemy.health)} health left.`
                ], () => {
                    if (game.combat.enemy.health <= 0) {
                        setTimeout(() => combatVictory(), 1000);
                    } else {
                        setTimeout(() => enemyTurn(), 1000);
                    }
                });
            } else if (spellToCast.type === 'stun') {
                let baseDamage = getScaledAbilityDamage(spellToCast.damage, game.dungeon.currentLevel);
                const levelBonus = (game.player.class === 'warrior' || game.player.class === 'rogue') ? game.player.level * 5 : 0;
                
                let shieldBonus = 0;
                if (game.player.shield && equipment.shields) {
                    const shieldData = equipment.shields.find(s => s.name === game.player.shield) ||
                                       merchantItems.find(i => i.name === game.player.shield && i.type === 'shield');
                    if (shieldData) {
                        shieldBonus = shieldData.defense * 3;
                    }
                }
                
                const totalDamage = baseDamage + levelBonus + shieldBonus;
                
                game.combat.enemy.health -= totalDamage;
                game.combat.enemy.stunned = true;

                let messages = [`You bash with your shield!`];
                if (shieldBonus > 0) {
                    messages.push(`Your ${game.player.shield} adds ${shieldBonus} crushing damage!`);
                }
                messages.push(`${totalDamage} total damage!`);
                messages.push(`${game.combat.enemy.name} is stunned!`);
                messages.push(`${game.combat.enemy.name} has ${Math.max(0, game.combat.enemy.health)} health left.`);

                speakSequence(messages, () => {
                    if (game.combat.enemy.health <= 0) {
                        setTimeout(() => combatVictory(), 1000);
                    } else {
                        setTimeout(() => enemyTurn(), 1000);
                    }
                });
            } else if (spellToCast.type === 'poison') {
                let baseDamage = getScaledAbilityDamage(spellToCast.damage, game.dungeon.currentLevel);
                const levelBonus = (game.player.class === 'warrior' || game.player.class === 'rogue') ? game.player.level * 5 : 0;
                const totalDamage = baseDamage + levelBonus;
                const poisonDamage = 15 + Math.floor(game.player.level * 1.5);
                
                game.combat.enemy.health -= totalDamage;
                game.combat.enemy.poisoned = { damage: poisonDamage, duration: spellToCast.duration };

                speakSequence([
                    `You coat your blade in deadly poison!`,
                    `${totalDamage} initial damage!`,
                    `Poison will damage ${poisonDamage} per turn for ${spellToCast.duration} turns!`,
                    `${game.combat.enemy.name} has ${Math.max(0, game.combat.enemy.health)} health left.`
                ], () => {
                    if (game.combat.enemy.health <= 0) {
                        setTimeout(() => combatVictory(), 1000);
                    } else {
                        setTimeout(() => enemyTurn(), 1000);
                    }
                });
            } else if (spellToCast.type === 'aoe') {
                let levelBonus = game.player.class === 'mage' ? game.player.level * 6 : game.player.level * 5;
                let totalDamage = getScaledAbilityDamage(spellToCast.damage, game.dungeon.currentLevel) + levelBonus;
                
                // Mage shoulder item bonus
                if (game.player.equippedShoulderItem) {
                    const shoulderData = equipment.shoulderItems && equipment.shoulderItems.find(s => s.name === game.player.equippedShoulderItem);
                    if (shoulderData && shoulderData.effect === 'mage_spell') {
                        totalDamage = Math.floor(totalDamage * (1 + shoulderData.bonus));
                    }
                }
                
                game.combat.enemy.health -= totalDamage;
                
                let messages = [
                    `You cast ${spellToCast.name}!`,
                    `${totalDamage} damage to ${game.combat.enemy.name}!`
                ];
                
                if (game.combat.secondEnemy && game.combat.secondEnemy.health > 0) {
                    game.combat.secondEnemy.health -= totalDamage;
                    messages.push(`${totalDamage} damage to ${game.combat.secondEnemy.name}!`);
                }
                
                messages.push(`${game.combat.enemy.name} has ${Math.max(0, game.combat.enemy.health)} health left.`);
                if (game.combat.secondEnemy && game.combat.secondEnemy.health > 0) {
                    messages.push(`${game.combat.secondEnemy.name} has ${Math.max(0, game.combat.secondEnemy.health)} health left.`);
                }
                
                speakSequence(messages, () => {
                    if (game.combat.enemy.health <= 0 && (!game.combat.secondEnemy || game.combat.secondEnemy.health <= 0)) {
                        setTimeout(() => combatVictory(), 1000);
                    } else if (game.combat.enemy.health <= 0 && game.combat.secondEnemy && game.combat.secondEnemy.health > 0) {
                        game.combat.enemy = game.combat.secondEnemy;
                        game.combat.secondEnemy = null;
                        speak(`${game.combat.enemy.name} remains!`, () => {
                            setTimeout(() => enemyTurn(), 1000);
                        });
                    } else {
                        setTimeout(() => enemyTurn(), 1000);
                    }
                });
            } else if (spellToCast.type === 'sneak') {
                let levelBonus = game.player.level * 5;
                let totalDamage = getScaledAbilityDamage(spellToCast.damage, game.dungeon.currentLevel) + levelBonus;
                
                // Rogue shoulder item bonus
                if (game.player.equippedShoulderItem) {
                    const shoulderData = equipment.shoulderItems && equipment.shoulderItems.find(s => s.name === game.player.equippedShoulderItem);
                    if (shoulderData && shoulderData.effect === 'rogue_stealth') {
                        totalDamage = Math.floor(totalDamage * (1 + shoulderData.bonus));
                    }
                }
                
                game.combat.enemy.health -= totalDamage;
                
                let messages = [`You strike from the shadows!`, `${totalDamage} damage!`];
                
                messages.push(`The enemy doesn't see you coming!`);
                messages.push(`${game.combat.enemy.name} has ${Math.max(0, game.combat.enemy.health)} health left.`);
                messages.push(`You vanish before they can counter!`);
                
                speakSequence(messages, () => {
                    if (game.combat.enemy.health <= 0) {
                        if (game.combat.secondEnemy && game.combat.secondEnemy.health > 0) {
                            game.combat.enemy = game.combat.secondEnemy;
                            game.combat.secondEnemy = null;
                            setTimeout(() => speak(`${game.combat.enemy.name} remains! Health: ${game.combat.enemy.health}. What will you do?`), 500);
                        } else {
                            setTimeout(() => combatVictory(), 1000);
                        }
                    } else {
                        setTimeout(() => speak('What will you do?'), 500);
                    }
                });
            } else if (spellToCast.type === 'timestop') {
                game.combat.enemy.frozen = true;
                game.combat.enemy.timestopTurns = 2;
                if (game.combat.secondEnemy && game.combat.secondEnemy.health > 0) {
                    game.combat.secondEnemy.frozen = true;
                    game.combat.secondEnemy.timestopTurns = 2;
                }
                speakSequence([
                    `You cast Time Stop!`,
                    `Time freezes around you!`,
                    `All enemies are frozen for 2 turns!`
                ], () => {
                    setTimeout(() => speak('What will you do?'), 500);
                });
            } else if (spellToCast.type === 'rage') {
                const weaponData = equipment.weapons.find(w => w.name === game.player.weapon) ||
                                   merchantItems.find(i => i.name === game.player.weapon && i.type === 'weapon');
                const weaponAttack = weaponData ? weaponData.attack : 0;
                let baseDamage = game.player.baseAttack + weaponAttack;
                baseDamage += (game.player.level - 1) * 5;
                const totalDamage = baseDamage * 3;
                
                game.combat.enemy.health -= totalDamage;
                
                speakSequence([
                    `You enter a berserker rage!`,
                    `You strike three times for ${totalDamage} total damage!`,
                    `${game.combat.enemy.name} has ${Math.max(0, game.combat.enemy.health)} health left.`
                ], () => {
                    if (game.combat.enemy.health <= 0) {
                        setTimeout(() => combatVictory(), 1000);
                    } else {
                        setTimeout(() => enemyTurn(), 1000);
                    }
                });
            } else if (spellToCast.type === 'vanish') {
                game.combat.playerShadowmelded = true;
                speakSequence([
                    `You cast ${spellToCast.name}!`,
                    `You meld into the shadows!`,
                    `You become invisible!`,
                    `Your next attack will deal 200% damage!`
                ], () => {
                    setTimeout(() => speak('What will you do?'), 500);
                });
            } else if (spellToCast.type === 'mark') {
                let baseDamage = getScaledAbilityDamage(spellToCast.damage, game.dungeon.currentLevel);
                const levelBonus = game.player.level * 5;
                const totalDamage = baseDamage + levelBonus;
                
                game.combat.enemy.health -= totalDamage;
                game.combat.enemy.deathMarked = true;
                
                speakSequence([
                    `You cast Death Mark!`,
                    `${totalDamage} damage!`,
                    `The enemy is marked! They take 50% more damage!`,
                    `${game.combat.enemy.name} has ${Math.max(0, game.combat.enemy.health)} health left.`
                ], () => {
                    if (game.combat.enemy.health <= 0) {
                        setTimeout(() => combatVictory(), 1000);
                    } else {
                        setTimeout(() => enemyTurn(), 1000);
                    }
                });
            } else if (spellToCast.type === 'damage') {
                let levelBonus = 0;
                if (game.player.class === 'warrior' || game.player.class === 'rogue') {
                    levelBonus = game.player.level * 5;
                } else if (game.player.class === 'mage') {
                    levelBonus = game.player.level * 6;
                }
                
                let totalDamage = getScaledAbilityDamage(spellToCast.damage, game.dungeon.currentLevel) + levelBonus;
                
                // Mage shoulder item bonus
                if (game.player.equippedShoulderItem && game.player.class === 'mage') {
                    const shoulderData = equipment.shoulderItems && equipment.shoulderItems.find(s => s.name === game.player.equippedShoulderItem);
                    if (shoulderData && shoulderData.effect === 'mage_spell') {
                        totalDamage = Math.floor(totalDamage * (1 + shoulderData.bonus));
                    }
                }
                
                game.combat.enemy.health -= totalDamage;

                speakSequence([
                    `You cast ${spellToCast.name}!`,
                    `${totalDamage} damage!`,
                    `${game.combat.enemy.name} has ${Math.max(0, game.combat.enemy.health)} health left.`
                ], () => {
                    if (game.combat.enemy.health <= 0) {
                        setTimeout(() => combatVictory(), 1000);
                    } else {
                        setTimeout(() => enemyTurn(), 1000);
                    }
                });
            }
        }

        function dungeonComplete() {
            speakSequence([
                'You defeated the boss!',
                'The dungeon level is cleared!',
                'Seek the stairs to descend deeper!',
                `You are now level ${game.player.level} with ${game.player.gold} gold.`
            ]);
        }

        function gameOver() {
            const reviveEffect = game.player.activeEffects.find(e => e.type === 'revive');
            if (reviveEffect && reviveEffect.uses > 0) {
                reviveEffect.uses--;
                game.player.activeEffects = game.player.activeEffects.filter(e => e.type !== 'revive');
                game.player.health = Math.floor(game.player.maxHealth * 0.5);
                
                speakSequence([
                    'You have fallen!',
                    'But the Elixir of Immortality revives you!',
                    `You return with ${game.player.health} health!`,
                    'What will you do?'
                ]);
                return;
            }
            
            speakSequence([
                'You have been defeated.',
                'Your adventure ends here.',
                `You reached level ${game.player.level} and collected ${game.player.gold} gold.`,
                'Game over. Refresh to play again.'
            ]);
        }

        function characterStatus() {
            const classData = classes[game.player.class];
            const special = classData.special;
            const specialInfo = special.type === 'damage' ? `Deals ${special.damage} damage.` : `Restores ${special.heal} health.`;
            const expNeeded = game.player.experienceToNext - game.player.experience;

            let messages = [
                `Level ${game.player.level} ${classData.name}.`,
                `Health: ${game.player.health} of ${game.player.maxHealth}.`,
                `Mana: ${game.player.mana} of ${game.player.maxMana}.`,
                `Attack: ${game.player.baseAttack}. Defense: ${game.player.defense}.`
            ];

            if (game.player.weapon) messages.push(`Weapon: ${game.player.weapon}.`);
            if (game.player.armor) messages.push(`Armor: ${game.player.armor}.`);
            if (game.player.shield) messages.push(`Shield: ${game.player.shield}.`);
            if (game.player.helmet) messages.push(`Helmet: ${game.player.helmet}.`);
            if (game.player.gloves) messages.push(`Gloves: ${game.player.gloves}.`);
            if (game.player.boots) messages.push(`Boots: ${game.player.boots}.`);
            if (game.player.equippedShoulderItem) messages.push(`Shoulder: ${game.player.equippedShoulderItem}.`);
            
            if (game.player.equippedBracelets.length > 0) {
                messages.push(`Bracelets: ${game.player.equippedBracelets.join(', ')}.`);
            }

            messages.push(`Experience: ${game.player.experience}. Need ${expNeeded} for next level.`);
            messages.push(`Special ability: ${special.name}. Costs ${special.cost} mana. ${specialInfo}`);
            messages.push(`Gold: ${game.player.gold}.`);

            if (game.player.learnedAbilities.length > 0) {
                messages.push(`Learned abilities: ${game.player.learnedAbilities.join(', ')}.`);
            }

            if (game.player.equippedRings.length > 0) {
                const equippedCounts = {};
                game.player.equippedRings.forEach(ring => equippedCounts[ring] = (equippedCounts[ring] || 0) + 1);
                const equippedList = Object.entries(equippedCounts).map(([ring, count]) => 
                    count > 1 ? `${ring} x${count}` : ring
                );
                messages.push(`Equipped rings: ${equippedList.join(', ')}.`);
            } else {
                messages.push(`No rings equipped.`);
            }

            if (game.player.equippedAmulet) {
                messages.push(`Equipped amulet: ${game.player.equippedAmulet}.`);
            } else {
                messages.push(`No amulet equipped.`);
            }

            speakSequence(messages);
        }

        function listInventory() {
            if (game.player.inventory.length === 0 && game.player.equippedRings.length === 0) {
                speak(`Empty inventory. Gold: ${game.player.gold}.`);
            } else {
                const itemCounts = {};
                game.player.inventory.forEach(item => {
                    itemCounts[item] = (itemCounts[item] || 0) + 1;
                });
                
                const ringsList = game.player.inventory.filter(i => rings.some(r => r.name === i));
                const amuletsList = game.player.inventory.filter(i => amulets.some(a => a.name === i));
                const abilityBooks = game.player.inventory.filter(i => abilities.some(a => a.name === i));
                
                const messages = ['Inventory:'];
                
                const potionTypes = ['Large Health Potion', 'Greater Health Potion', 'Supreme Health Potion', 'Ultimate Health Potion', 'Godly Health Elixir',
                                     'Large Mana Potion', 'Greater Mana Potion', 'Supreme Mana Potion', 'Ultimate Mana Potion', 'Godly Mana Elixir'];
                potionTypes.forEach(potion => {
                    if (itemCounts[potion]) {
                        messages.push(`${itemCounts[potion]} ${potion}${itemCounts[potion] > 1 ? 's' : ''}.`);
                    }
                });
                
                if (abilityBooks.length > 0) {
                    const bookCounts = {};
                    abilityBooks.forEach(book => bookCounts[book] = (bookCounts[book] || 0) + 1);
                    const bookList = Object.entries(bookCounts).map(([book, count]) => 
                        count > 1 ? `${book} x${count}` : book
                    );
                    messages.push(`Books: ${bookList.join(', ')}.`);
                }
                
                if (ringsList.length > 0) {
                    const ringCounts = {};
                    ringsList.forEach(ring => ringCounts[ring] = (ringCounts[ring] || 0) + 1);
                    const ringList = Object.entries(ringCounts).map(([ring, count]) => 
                        count > 1 ? `${ring} x${count}` : ring
                    );
                    messages.push(`Unequipped rings: ${ringList.join(', ')}.`);
                }
                
                if (game.player.equippedRings.length > 0) {
                    const equippedCounts = {};
                    game.player.equippedRings.forEach(ring => equippedCounts[ring] = (equippedCounts[ring] || 0) + 1);
                    const equippedList = Object.entries(equippedCounts).map(([ring, count]) => 
                        count > 1 ? `${ring} x${count}` : ring
                    );
                    messages.push(`Equipped rings: ${equippedList.join(', ')}.`);
                }
                
                if (amuletsList.length > 0) {
                    const amuletCounts = {};
                    amuletsList.forEach(amulet => amuletCounts[amulet] = (amuletCounts[amulet] || 0) + 1);const amuletList = Object.entries(amuletCounts).map(([amulet, count]) => 
                        count > 1 ? `${amulet} x${count}` : amulet
                    );
                    messages.push(`Unequipped amulets: ${amuletList.join(', ')}.`);
                }
                
                if (game.player.equippedAmulet) messages.push(`Equipped amulet: ${game.player.equippedAmulet}.`);
                
                const otherItems = game.player.inventory.filter(i => 
                    !potionTypes.includes(i) &&
                    !ringsList.includes(i) && 
                    !amuletsList.includes(i) &&
                    !abilityBooks.includes(i)
                );
                if (otherItems.length > 0) {
                    const equipCounts = {};
                    otherItems.forEach(item => equipCounts[item] = (equipCounts[item] || 0) + 1);
                    const equipList = Object.entries(equipCounts).map(([item, count]) => 
                        count > 1 ? `${item} x${count}` : item
                    );
                    messages.push(`Equipment: ${equipList.join(', ')}.`);
                }
                
                messages.push(`Gold: ${game.player.gold}.`);
                
                speakSequence(messages);
            }
        }

        function showHelp() {
            if (game.phase === 'combat') {
                speak('Combat commands: attack, defend, special, cast spell, use potion, or flee.');
            } else {
                speak('Exploration commands: north, south, east, west, look around, search, open chest, drink fountain, merchant, meditate, wear ring, remove ring, equip bracelet, remove bracelet, equip amulet, equip shoulder, inspect item, read book, unlearn ability, use potion, status, inventory, mark junk, view junk, save game, or load game.');
            }
        }

        function listCommands() {
            if (game.phase === 'combat') {
                speakSequence([
                    'Combat commands:',
                    'Attack. Deal damage.',
                    'Defend. Reduce incoming damage.',
                    'Special. Use your class ability.',
                    'Cast spell. Use a learned ability.',
                    'Use potion. Heal or restore mana.',
                    'Flee. Try to escape.'
                ]);
            } else {
                speakSequence([
                    'Movement: north, south, east, west, go down stairs.',
                    'Actions: look around, search, open chest, drink fountain, merchant, meditate, wear ring, remove ring, equip bracelet, remove bracelet, equip amulet, equip shoulder, inspect item, read book, unlearn ability, use potion.',
                    'Junk: mark junk, view junk, sell junk at merchant.',
                    'Info: status, inventory, hint.',
                    'System: save game, load game, commands, help.'
                ]);
            }
        }

        function giveHint() {
            if (game.phase === 'combat') {
                if (game.player.health < 30) {
                    speak('Your health is low. Consider using a health potion or defending.');
                } else if (game.player.mana >= classes[game.player.class].special.cost) {
                    speak(`You have enough mana for ${classes[game.player.class].special.name}.`);
                } else {
                    speak('Try attacking or defending based on your health.');
                }
            } else {
                const room = game.currentRoom;
                if (room.type === 'stairs') {
                    speak('A staircase is here. Say "go down stairs" to descend to the next level.');
                } else if (room.type === 'merchant') {
                    speak('A merchant is here. Say "merchant" to trade goods.');
                } else if (room.type === 'fountain' && !room.fountainUsed) {
                    speak('There is a magical fountain here. Say "drink fountain" for full healing.');
                } else if (room.hasChest && !room.searched) {
                    speak('There is a chest here. Say open chest.');
                } else if (!room.searched) {
                    speak('You have not searched this room yet. Try searching.');
                } else if (game.player.mana < game.player.maxMana * 0.5) {
                    speak('Your mana is low. Consider saying meditate to recover.');
                } else if (room.type === 'boss') {
                    speak('This is a boss room. Be prepared for a tough fight.');
                } else {
                    speak('Explore in different directions. The boss is at the far south east corner. Look for merchants to buy potions and sell loot.');
                }
            }
        }

        document.addEventListener('DOMContentLoaded', () => {
            checkBrowserSupport();
            setTimeout(() => {
                speak('Echo Dungeon V11 is ready. Tap the screen to begin.');
            }, 1000);
        });

        micButton.addEventListener('contextmenu', (e) => e.preventDefault());
    </script>
</body>
</html>