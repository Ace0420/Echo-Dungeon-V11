<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Echo Dungeon V11 - Blind First</title>
    <style>
        body { margin: 0; padding: 0; background: #000; color: #fff; overflow: hidden; }
        #micButton {
            position: fixed; top: 0; left: 0; width: 100vw; height: 100vh;
            background: #111; border: none; cursor: pointer; transition: background 0.3s;
        }
        /* State-based colors for A53 screen status */
        .listening { background: #004400 !important; }
        .processing { background: #000044 !important; }
        /* Blind-first: Text is present for screen readers but invisible to eyes */
        #textDisplay { position: absolute; width: 1px; height: 1px; padding: 0; margin: -1px; overflow: hidden; clip: rect(0, 0, 0, 0); border: 0; }
    </style>
</head>
<body>
    <div id="textDisplay" role="status" aria-live="polite"></div>
    <button id="micButton" onclick="handleClick()" aria-label="Tap to speak"></button>

    <script>
        const micButton = document.getElementById('micButton');
        const textDisplay = document.getElementById('textDisplay');

        // --- CORE GAME STATE (Preserved from V10.5) ---
        const game = {
            seed: Math.floor(1000 + Math.random() * 9000), // V11 Seed Sync
            player: {
                class: '', level: 1, experience: 0, experienceToNext: 100,
                health: 100, maxHealth: 100, mana: 50, maxMana: 50, gold: 25,
                inventory: [], equippedRings: [], learnedAbilities: [],
                equippedAmulet: '', position: { x: 6, y: 6 }, baseAttack: 15, defense: 0,
                weapon: '', armor: '', shield: '', helmet: '', gloves: '', boots: '',
                leftBracelet: '', rightBracelet: '', specialItems: [], activeEffects: [], junkBag: []
            },
            dungeon: { grid: {}, size: 12, currentLevel: 1, hasSecretRoom: false },
            currentRoom: null, combat: null, listening: false, started: false,
            needsClass: true, phase: 'init', merchantOpen: false
        };

        const classes = {
            warrior: { name: 'Warrior', health: 120, maxHealth: 120, mana: 30, maxMana: 30, gold: 50, items: ['Steel Sword', 'Health Potion', 'Chainmail', 'Iron Shield'], special: { name: 'Power Strike', damage: 100, cost: 15, type: 'damage' } },
            mage: { name: 'Mage', health: 80, maxHealth: 80, mana: 100, maxMana: 100, gold: 75, items: ['Mystic Staff', 'Mana Potion', 'Enchanted Robes'], special: { name: 'Fireball', damage: 100, cost: 20, type: 'damage' } },
            rogue: { name: 'Rogue', health: 100, maxHealth: 100, mana: 60, maxMana: 60, gold: 100, items: ['Shadow Daggers', 'Lockpicks', 'Shadow Leather'], special: { name: 'Backstab', damage: 75, cost: 15, type: 'damage' } }
        };

        // --- AUDIO ENGINE ---
        function speak(text, callback) {
            textDisplay.innerText = text;
            const utter = new SpeechSynthesisUtterance(text);
            utter.onend = callback;
            window.speechSynthesis.cancel();
            window.speechSynthesis.speak(utter);
        }

        function speakSequence(messages, callback) {
            if (messages.length === 0) { if (callback) callback(); return; }
            speak(messages.shift(), () => speakSequence(messages, callback));
        }

        // --- SEEDED GENERATION (V11 Co-op) ---
        function generateDungeon() {
            game.dungeon.grid = {};
            let s = game.seed + game.dungeon.currentLevel;
            for (let x = 0; x < game.dungeon.size; x++) {
                for (let y = 0; y < game.dungeon.size; y++) {
                    const r = Math.abs(Math.sin(s++)) * 10000 % 1;
                    let type = 'empty';
                    if (r < 0.15) type = 'enemy';
                    else if (r < 0.25) type = 'treasure';
                    else if (r < 0.30) type = 'fountain';
                    else if (r < 0.35) type = 'merchant';
                    else if (r < 0.38) type = 'stairs';
                    game.dungeon.grid[`${x},${y}`] = { type, searched: false, loot: null };
                }
            }
            game.dungeon.grid['11,11'] = { type: 'boss', searched: false };
        }
        // --- DATA ARRAYS (Preserved from V10.5) ---
        const equipment = {
            weapons: [
                { name: 'Steel Sword', attack: 12, class: 'warrior', value: 100 },
                { name: 'Mystic Staff', attack: 8, mana: 15, class: 'mage', value: 150 },
                { name: 'Shadow Daggers', attack: 10, class: 'rogue', value: 120 },
                { name: 'Legendary Greatsword', attack: 25, class: 'warrior', value: 300 },
                { name: 'Archmage Staff', attack: 12, mana: 25, class: 'mage', value: 350 },
                { name: 'Vorpal Daggers', attack: 16, class: 'rogue', value: 320 },
                { name: 'Demon Slayer Blade', attack: 40, class: 'warrior', value: 500 },
                { name: 'Staff of the Cosmos', attack: 15, mana: 35, class: 'mage', value: 600 },
                { name: 'Ethereal Blades', attack: 22, class: 'rogue', value: 550 },
                { name: 'Godslayer Greatsword', attack: 30, class: 'warrior', value: 1000, minLevel: 6 },
                { name: 'Staff of Eternity', attack: 20, mana: 45, class: 'mage', value: 1200, minLevel: 6 },
                { name: 'Nightfall Daggers', attack: 32, class: 'rogue', value: 1100, minLevel: 6 },
                { name: 'Excalibur', attack: 50, class: 'warrior', value: 2000, minLevel: 8 },
                { name: 'Infinity Staff', attack: 25, mana: 60, class: 'mage', value: 2500, minLevel: 8 },
                { name: 'Oblivion Blades', attack: 42, class: 'rogue', value: 2200, minLevel: 8 },
                { name: 'Sword of the Ancients', attack: 70, class: 'warrior', value: 5000, minLevel: 10 },
                { name: 'Cosmic Scepter', attack: 35, mana: 80, class: 'mage', value: 6000, minLevel: 10 },
                { name: 'Void Assassin Blades', attack: 60, class: 'rogue', value: 5500, minLevel: 10 },
                { name: 'Ragnarok', attack: 100, class: 'warrior', value: 10000, minLevel: 20 },
                { name: 'Genesis Staff', attack: 50, mana: 120, class: 'mage', value: 12000, minLevel: 20 },
                { name: 'Apocalypse Daggers', attack: 85, class: 'rogue', value: 11000, minLevel: 20 }
            ],
            armor: [
                { name: 'Chainmail', defense: 10, class: 'warrior', value: 100 },
                { name: 'Enchanted Robes', defense: 5, class: 'mage', value: 120 },
                { name: 'Shadow Leather', defense: 6, class: 'rogue', value: 110 },
                { name: 'Dragonscale Plate', defense: 15, class: 'warrior', value: 350 },
                { name: 'Arcane Vestments', defense: 12, class: 'mage', value: 380 },
                { name: 'Phantom Suit', defense: 13, class: 'rogue', value: 360 },
                { name: 'Titanium Fortress', defense: 27, class: 'warrior', value: 550 },
                { name: 'Celestial Robes', defense: 18, mana: 25, class: 'mage', value: 600 },
                { name: 'Void Cloak', defense: 20, class: 'rogue', value: 580 },
                { name: 'Divine Plate', defense: 35, class: 'warrior', value: 1200, minLevel: 6 },
                { name: 'Robes of the Archmage', defense: 28, class: 'mage', value: 1100, minLevel: 6 },
                { name: 'Shadowweave Armor', defense: 30, class: 'rogue', value: 1150, minLevel: 6 },
                { name: 'Immortal Armor', defense: 50, class: 'warrior', value: 3000, minLevel: 8 },
                { name: 'Armor of the Titans', defense: 70, class: 'warrior', value: 6000, minLevel: 10 },
                { name: 'Armor of Ragnarok', defense: 100, class: 'warrior', value: 12000, minLevel: 20 },
                { name: 'Genesis Robes', defense: 80, mana: 150, class: 'mage', value: 14000, minLevel: 20 },
                { name: 'Apocalypse Suit', defense: 90, class: 'rogue', value: 13000, minLevel: 20 }
            ],
            shields: [
                { name: 'Iron Shield', defense: 5, class: 'warrior', value: 80 },
                { name: 'Tower Shield', defense: 10, class: 'warrior', value: 250 },
                { name: 'Aegis Shield', defense: 15, class: 'warrior', value: 450 },
                { name: 'Shield of Heroes', defense: 25, class: 'warrior', value: 800, minLevel: 6 },
                { name: 'Shield of Ragnarok', defense: 75, class: 'warrior', value: 10000, minLevel: 20 }
            ],
            helmets: [
                { name: 'Iron Helm', defense: 3, class: 'warrior', value: 50 },
                { name: 'Mage Hood', mana: 50, class: 'mage', value: 60 },
                { name: 'Crown of Kings', defense: 38, class: 'warrior', value: 300, minLevel: 5 },
                { name: 'Helm of Ragnarok', defense: 80, class: 'warrior', value: 8000, minLevel: 20 },
                { name: 'Genesis Crown', mana: 300, class: 'mage', value: 9000, minLevel: 20 }
            ],
            gloves: [
                { name: 'Leather Gloves', attack: 12, value: 40 },
                { name: 'Gauntlets of Strength', attack: 55, class: 'warrior', value: 200, minLevel: 4 },
                { name: 'Gauntlets of Ragnarok', attack: 120, class: 'warrior', value: 7000, minLevel: 20 }
            ],
            boots: [
                { name: 'Iron Boots', defense: 12, value: 35 },
                { name: 'Greaves of the Titan', defense: 38, class: 'warrior', value: 300, minLevel: 5 },
                { name: 'Greaves of Ragnarok', defense: 90, class: 'warrior', value: 7500, minLevel: 20 }
            ],
            bracelets: [
                { name: 'Bronze Bracelet', attack: 5, value: 100 },
                { name: 'Gold Bracelet', attack: 15, mana: 40, value: 800, minLevel: 5 },
                { name: 'Bracelet of Ragnarok', attack: 90, mana: 250, value: 20000, minLevel: 30 }
            ]
        };

        const abilities = [
            { name: 'Icy Blast', damage: 100, cost: 20, type: 'freeze', class: 'mage' },
            { name: 'Shield Bash', damage: 80, cost: 20, type: 'stun', class: 'warrior' },
            { name: 'Poison Blade', damage: 40, cost: 20, type: 'poison', duration: 3, class: 'rogue' },
            { name: 'Meteor Storm', damage: 145, cost: 40, type: 'aoe', class: 'mage', minLevel: 5 },
            { name: 'Titan Smash', damage: 190, cost: 35, type: 'damage', class: 'warrior', minLevel: 5 },
            { name: 'Assassinate', damage: 125, cost: 30, type: 'sneak', class: 'rogue', minLevel: 5 },
            { name: 'Cosmic Devastation', damage: 300, cost: 100, type: 'aoe', class: 'mage', minLevel: 10 },
            { name: 'Annihilation', damage: 400, cost: 70, type: 'damage', class: 'warrior', minLevel: 10 },
            { name: 'Ragnarok', damage: 600, cost: 120, type: 'aoe', class: 'mage', minLevel: 20 },
            { name: 'Apocalypse Strike', damage: 800, cost: 100, type: 'damage', class: 'warrior', minLevel: 20 },
            { name: 'Oblivion', damage: 500, cost: 90, type: 'sneak', class: 'rogue', minLevel: 20 }
        ];

        const merchantItems = [
            { name: 'Health Potion', price: 20, type: 'potion', effect: 'Restores 50 HP' },
            { name: 'Mana Potion', price: 20, type: 'potion', effect: 'Restores 30 Mana' },
            ...equipment.weapons.map(w => ({ ...w, type: 'weapon', price: w.value })),
            ...equipment.armor.map(a => ({ ...a, type: 'armor', price: a.value })),
            ...equipment.shields.map(s => ({ ...s, type: 'shield', price: s.value })),
            ...equipment.helmets.map(h => ({ ...h, type: 'helmet', price: h.value })),
            ...equipment.gloves.map(g => ({ ...g, type: 'gloves', price: g.value })),
            ...equipment.boots.map(b => ({ ...b, type: 'boots', price: b.value })),
            ...equipment.bracelets.map(br => ({ ...br, type: 'bracelet', price: br.value }))
        ];

        // --- ROOM TYPES ---
        const roomTypes = {
            entrance: { descriptions: ["the entrance hall", "a cold stone foyer"] },
            enemy: { descriptions: ["a blood-stained chamber", "a dark hallway"] },
            treasure: { descriptions: ["a room filled with dust and gold", "a small vault"] },
            fountain: { descriptions: ["a serene garden with a fountain", "a room of healing waters"] },
            merchant: { descriptions: ["a safe haven with a merchant", "a well-lit shop"] },
            stairs: { descriptions: ["a room with spiral stairs leading down", "a narrow descent"] },
            boss: { descriptions: ["the throne room of a titan", "the end of the world"] }
        };
        // --- DEFENSE RECALCULATION ---
        function recalculateDefense() {
            let def = 0;
            const slots = ['armor', 'shield', 'helmet', 'boots'];
            slots.forEach(slot => {
                if (game.player[slot]) {
                    const item = equipment[slot + 's'].find(i => i.name === game.player[slot]);
                    if (item) def += item.defense;
                }
            });
            game.player.defense = def;
        }

        // --- BRACELET LOGIC (V11 Swapping Fixes) ---
        function equipBracelet(command) {
            const braceletName = Object.values(equipment.bracelets)
                .map(b => b.name)
                .find(name => command.includes(name.toLowerCase()));

            if (!braceletName) {
                const owned = game.player.inventory.filter(i => equipment.bracelets.some(b => b.name === i));
                speak(owned.length ? `You have: ${owned.join(', ')}. Which one?` : "You have no bracelets.");
                return;
            }

            const idx = game.player.inventory.indexOf(braceletName);
            if (idx === -1) return speak(`You don't have the ${braceletName}.`);

            const data = equipment.bracelets.find(b => b.name === braceletName);
            // Determine hand choice
            let hand = '';
            if (command.includes('left')) hand = 'left';
            else if (command.includes('right')) hand = 'right';
            else if (!game.player.leftBracelet) hand = 'left';
            else if (!game.player.rightBracelet) hand = 'right';

            if (!hand) {
                speak("Both wrists are full. Say 'equip left' or 'equip right' followed by the bracelet name.");
                return;
            }

            // Unequip current and remove stats
            const oldBraceletName = hand === 'left' ? game.player.leftBracelet : game.player.rightBracelet;
            if (oldBraceletName) {
                const oldData = equipment.bracelets.find(b => b.name === oldBraceletName);
                if (oldData.mana) {
                    game.player.maxMana -= oldData.mana;
                    game.player.mana = Math.min(game.player.mana, game.player.maxMana);
                }
                game.player.inventory.push(oldBraceletName);
            }

            // Equip new
            if (hand === 'left') game.player.leftBracelet = braceletName;
            else game.player.rightBracelet = braceletName;
            
            game.player.inventory.splice(idx, 1);
            if (data.mana) {
                game.player.maxMana += data.mana;
                game.player.mana += data.mana;
            }
            speak(`Equipped ${braceletName} on ${hand} wrist. Attack up ${data.attack}!`);
        }

        // --- JUNK BAG LOGIC ---
        function addToJunk(command) {
            const item = game.player.inventory.find(i => command.includes(i.toLowerCase()));
            if (!item) return speak("Item not found in inventory.");
            
            const idx = game.player.inventory.indexOf(item);
            game.player.inventory.splice(idx, 1);
            game.player.junkBag.push(item);
            speak(`Put ${item} into the junk bag.`);
        }

        function viewJunk() {
            if (game.player.junkBag.length === 0) return speak("Your junk bag is empty.");
            speak("Junk bag contains: " + game.player.junkBag.join(", "));
        }

        function sellAllJunk() {
            if (!game.merchantOpen) return speak("You must be at a merchant to sell junk.");
            if (game.player.junkBag.length === 0) return speak("No junk to sell.");

            let totalGold = 0;
            game.player.junkBag.forEach(itemName => {
                // Check all equipment categories for value
                for (let cat in equipment) {
                    const data = equipment[cat].find(i => i.name === itemName);
                    if (data) totalGold += Math.floor(data.value * 0.5);
                }
            });

            game.player.gold += totalGold;
            game.player.junkBag = [];
            speak(`Sold all junk for ${totalGold} gold. Total gold: ${game.player.gold}.`);
        }

        // --- CORE COMMAND PROCESSOR ---
        function processCommand(rawCommand) {
            const cmd = rawCommand.toLowerCase();
            micButton.className = 'processing';

            // Navigation
            if (cmd.includes('north') || cmd.includes('forward')) move('north');
            else if (cmd.includes('south') || cmd.includes('back')) move('south');
            else if (cmd.includes('east') || cmd.includes('right')) move('east');
            else if (cmd.includes('west') || cmd.includes('left')) move('west');
            
            // Interaction
            else if (cmd.includes('look') || cmd.includes('where')) describeRoom();
            else if (cmd.includes('search')) searchRoom();
            else if (cmd.includes('chest') || cmd.includes('loot')) openChest();
            else if (cmd.includes('merchant')) talkToMerchant();
            else if (cmd.includes('stairs')) useStairs();
            
            // Equipment/Items
            else if (cmd.includes('bracelet')) equipBracelet(cmd);
            else if (cmd.includes('junk')) {
                if (cmd.includes('add')) addToJunk(cmd);
                else if (cmd.includes('sell')) sellAllJunk();
                else viewJunk();
            }
            else if (cmd.includes('status')) characterStatus();
            else if (cmd.includes('inventory')) listInventory();
            
            // Fallback
            else {
                speak("I didn't quite get that. Say help for commands.");
            }
            
            setTimeout(() => { if (!game.listening) micButton.className = ''; }, 500);
        }
        // --- LEVELING SYSTEM (V11 Full Heal Fix) ---
        function gainExperience(amount) {
            game.player.experience += amount;
            speak(`Gained ${amount} experience.`);
            if (game.player.experience >= game.player.experienceToNext) {
                levelUp();
            }
        }

        function levelUp() {
            game.player.level++;
            game.player.experience -= game.player.experienceToNext;
            game.player.experienceToNext = Math.floor(game.player.experienceToNext * 1.5);
            
            // V11 Stat Increases
            game.player.maxHealth += 25;
            game.player.maxMana += 15;
            
            // FIX: Restore Health and Mana to new maximums
            game.player.health = game.player.maxHealth;
            game.player.mana = game.player.maxMana;
            
            speakSequence([
                `Level up! You are now level ${game.player.level}.`,
                `Maximum health and mana increased.`,
                `Your vitals have been fully restored!`
            ]);
        }

        // --- COMBAT ENGINE ---
        function startCombat(enemyType) {
            const enemyData = {
                goblin: { name: 'Goblin', health: 40, attack: 8, exp: 30, gold: 15 },
                skeleton: { name: 'Skeleton', health: 60, attack: 12, exp: 50, gold: 25 },
                orc: { name: 'Orc', health: 100, attack: 18, exp: 100, gold: 50 },
                dragon: { name: 'Ancient Dragon', health: 500, attack: 45, exp: 1000, gold: 500 },
                titan: { name: 'Void Titan', health: 1500, attack: 120, exp: 5000, gold: 2000 }
            };
            
            const enemy = { ...enemyData[enemyType] || enemyData.goblin };
            // Scale enemy by dungeon level
            enemy.health += (game.dungeon.currentLevel - 1) * 20;
            enemy.attack += (game.dungeon.currentLevel - 1) * 5;
            
            game.combat = { enemy, turn: 'player', playerDefending: false };
            speak(`A ${enemy.name} emerges from the shadows! Health: ${enemy.health}. What do you do?`);
        }

        function playerAttack() {
            if (!game.combat) return;
            let damage = game.player.baseAttack + Math.floor(game.player.level * 2);
            
            // Check for Bracelet/Ring bonuses
            const bLeft = equipment.bracelets.find(b => b.name === game.player.leftBracelet);
            const bRight = equipment.bracelets.find(b => b.name === game.player.rightBracelet);
            if (bLeft) damage += bLeft.attack;
            if (bRight) damage += bRight.attack;

            game.combat.enemy.health -= damage;
            speakSequence([
                `You strike the ${game.combat.enemy.name} for ${damage} damage.`,
                `${game.combat.enemy.name} health: ${Math.max(0, game.combat.enemy.health)}.`
            ], () => {
                if (game.combat.enemy.health <= 0) {
                    winCombat();
                } else {
                    enemyTurn();
                }
            });
        }

        function enemyTurn() {
            if (!game.combat) return;
            let damage = game.combat.enemy.attack - (game.player.defense / 2);
            if (game.combat.playerDefending) {
                damage = Math.floor(damage / 2);
                game.combat.playerDefending = false;
            }
            damage = Math.max(2, Math.floor(damage));
            
            game.player.health -= damage;
            speakSequence([
                `${game.combat.enemy.name} attacks for ${damage} damage.`,
                `Your health: ${Math.max(0, game.player.health)}.`
            ], () => {
                if (game.player.health <= 0) {
                    gameOver();
                } else {
                    speak("Your turn.");
                }
            });
        }

        function winCombat() {
            const gold = game.combat.enemy.gold;
            const exp = game.combat.enemy.exp;
            game.player.gold += gold;
            speak(`Victory! You defeated the ${game.combat.enemy.name}. You found ${gold} gold.`);
            gainExperience(exp);
            game.combat = null;
            // Clean up room
            game.dungeon.grid[`${game.player.position.x},${game.player.position.y}`].type = 'empty';
        }

        function castSpell(command) {
            const spellName = abilities.map(a => a.name).find(n => command.includes(n.toLowerCase()));
            const spell = abilities.find(a => a.name === spellName);
            
            if (!spell || !game.player.learnedAbilities.includes(spell.name)) {
                return speak("You don't know that spell.");
            }
            if (game.player.mana < spell.cost) {
                return speak("Not enough mana.");
            }

            game.player.mana -= spell.cost;
            let damage = spell.damage + (game.player.level * 5);
            
            if (spell.type === 'aoe' || spell.type === 'damage' || spell.type === 'sneak') {
                game.combat.enemy.health -= damage;
                speak(`${spell.name} deals ${damage} damage!`);
                if (game.combat.enemy.health <= 0) return winCombat();
                enemyTurn();
            }
        }
        // --- NAVIGATION (Strict Cardinal Only) ---
        function move(direction) {
            let newX = game.player.position.x;
            let newY = game.player.position.y;

            if (direction === 'north') newY--;
            else if (direction === 'south') newY++;
            else if (direction === 'east') newX++;
            else if (direction === 'west') newX--;

            if (newX < 0 || newX >= game.dungeon.size || newY < 0 || newY >= game.dungeon.size) {
                return speak("A cold stone wall blocks your path. You cannot go further that way.");
            }

            game.player.position.x = newX;
            game.player.position.y = newY;
            
            // Check for room generation or retrieval
            const key = `${newX},${newY}`;
            if (!game.dungeon.grid[key]) {
                generateRoom(key);
            }
            
            game.currentRoom = game.dungeon.grid[key];
            describeRoom();
        }

        function describeRoom() {
            const room = game.currentRoom;
            const type = room.type;
            const desc = roomTypes[type].descriptions[Math.floor(Math.random() * roomTypes[type].descriptions.length)];
            
            let message = `You are in ${desc}.`;
            
            if (type === 'enemy' || type === 'boss') {
                const enemyType = type === 'boss' ? 'titan' : 'orc';
                return startCombat(enemyType);
            }
            
            if (type === 'stairs') message += " You see stairs descending into deeper darkness.";
            if (type === 'merchant') message += " A merchant stands here, their lantern flickering.";
            if (type === 'fountain') message += " A shimmering fountain flows in the center of the room.";
            
            speak(message);
        }

        // --- ROOM INTERACTION ---
        function searchRoom() {
            const room = game.currentRoom;
            if (room.searched) return speak("You've already searched this room. Nothing else remains.");
            
            room.searched = true;
            const roll = Math.random();
            
            if (roll < 0.3) {
                const goldFound = Math.floor(Math.random() * 20) + 10;
                game.player.gold += goldFound;
                speak(`You found a loose stone containing ${goldFound} gold!`);
            } else if (roll < 0.5) {
                const item = "Health Potion";
                game.player.inventory.push(item);
                speak(`You found a ${item} hidden in the shadows.`);
            } else if (roll < 0.6) {
                // V10.5 Secret Room Logic
                game.dungeon.hasSecretRoom = true;
                speak("Your hands find a hidden mechanism! A secret door grinds open to the East.");
                game.dungeon.grid[`${game.player.position.x + 1},${game.player.position.y}`] = { type: 'treasure', searched: false };
            } else {
                speak("You find nothing but dust and cobwebs.");
            }
        }

        function useStairs() {
            if (game.currentRoom.type !== 'stairs') return speak("There are no stairs here.");
            game.dungeon.currentLevel++;
            game.dungeon.size += 2; // Dungeon gets bigger
            generateDungeon();
            game.player.position = { x: Math.floor(game.dungeon.size/2), y: Math.floor(game.dungeon.size/2) };
            speakSequence([
                `You descend to dungeon level ${game.dungeon.currentLevel}.`,
                `The air grows colder and the shadows deeper.`,
                `Co-op Sync Seed for this floor is ${game.seed + game.dungeon.currentLevel}.`
            ], () => describeRoom());
        }

        // --- INITIALIZATION (The V11 Start Sequence) ---
        function selectClass(className) {
            const c = classes[className];
            if (!c) return speak("Please choose Warrior, Mage, or Rogue.");
            
            game.player.class = className;
            game.player.health = c.health;
            game.player.maxHealth = c.maxHealth;
            game.player.mana = c.mana;
            game.player.maxMana = c.maxMana;
            game.player.gold = c.gold;
            game.player.inventory = [...c.items];
            game.player.learnedAbilities.push(c.special.name);
            
            game.needsClass = false;
            game.phase = 'exploration';
            
            speakSequence([
                `You have chosen the path of the ${c.name}.`,
                `Your adventure begins. Your co-op sync seed is ${game.seed}.`,
                `Say North, South, East, or West to move.`
            ], () => {
                generateDungeon();
                const startKey = `${game.player.position.x},${game.player.position.y}`;
                game.dungeon.grid[startKey] = { type: 'entrance', searched: true };
                game.currentRoom = game.dungeon.grid[startKey];
                describeRoom();
            });
        }

        function handleClick() {
            if (!game.started) {
                game.started = true;
                speak("Welcome to Echo Dungeon V11. Choose your class: Warrior, Mage, or Rogue.");
                return;
            }
            startListening();
        }
        // --- ADVANCED ABILITY LOGIC (V11 Enhanced) ---
        function castSpell(command) {
            if (!game.combat) return speak("You can only cast spells in combat.");
            
            // Extract the ability name from the command
            const spellToCast = abilities.find(a => command.includes(a.name.toLowerCase()));
            
            if (!spellToCast || !game.player.learnedAbilities.includes(spellToCast.name)) {
                return speak("You don't know that spell. Check your learned abilities.");
            }

            // Mana Check
            let cost = spellToCast.cost;
            if (game.player.activeEffects.includes('clarity')) cost = Math.floor(cost / 2);
            
            if (game.player.mana < cost) {
                return speak(`Not enough mana. You need ${cost} but only have ${game.player.mana}.`);
            }

            game.player.mana -= cost;
            micButton.className = 'processing';

            // Scaling Damage based on Class (Warrior/Rogue vs Mage)
            let levelBonus = (game.player.class === 'mage') ? game.player.level * 6 : game.player.level * 5;
            const totalDamage = spellToCast.damage + levelBonus;

            // --- SPELL TYPE EXECUTION ---
            if (spellToCast.type === 'freeze' || spellToCast.type === 'stun') {
                game.combat.enemy.health -= totalDamage;
                game.combat.enemy.isStunned = true; // Enemy skips next turn
                speakSequence([
                    `You cast ${spellToCast.name}!`,
                    `${totalDamage} damage and the ${game.combat.enemy.name} is ${spellToCast.type === 'freeze' ? 'frozen' : 'stunned'}!`
                ], () => checkCombatStatus());

            } else if (spellToCast.type === 'aoe') {
                // In V11, AOE hits current and potentially nearby "ghost" enemies in co-op sync
                game.combat.enemy.health -= totalDamage;
                speak(`${spellToCast.name} erupts! Dealing ${totalDamage} damage to everything in the room!`, () => checkCombatStatus());

            } else if (spellToCast.type === 'poison') {
                game.combat.enemy.health -= totalDamage;
                game.combat.enemy.poisonTicks = spellToCast.duration;
                speak(`Poisoned strike! ${totalDamage} damage and ${game.combat.enemy.name} is withering!`, () => checkCombatStatus());

            } else if (spellToCast.type === 'sneak') {
                // Rogue logic: Shadow strike avoids retaliation for 1 turn
                game.combat.enemy.health -= totalDamage;
                game.combat.playerIsHidden = true;
                speak(`From the shadows! ${totalDamage} damage. The enemy cannot find you!`, () => checkCombatStatus());

            } else {
                game.combat.enemy.health -= totalDamage;
                speak(`${spellToCast.name} hits for ${totalDamage} damage!`, () => checkCombatStatus());
            }
        }

        function checkCombatStatus() {
            if (game.combat.enemy.health <= 0) {
                winCombat();
            } else {
                enemyTurn();
            }
        }

        // --- BOOK & ABILITY MANAGEMENT ---
        function readBook() {
            const book = game.player.inventory.find(i => i.toLowerCase().includes('book'));
            if (!book) return speak("You have no ability books to read.");
            
            // Extract ability name from book (e.g., "Book of Meteor Storm")
            const abilityName = abilities.find(a => book.includes(a.name))?.name;
            if (!abilityName) return speak("This book is written in a language you don't understand.");

            if (game.player.learnedAbilities.includes(abilityName)) {
                return speak("You already know this ability.");
            }

            game.player.learnedAbilities.push(abilityName);
            const idx = game.player.inventory.indexOf(book);
            game.player.inventory.splice(idx, 1);
            speak(`You read the ${book} and master the art of ${abilityName}!`);
        }

        function unlearnAbility(command) {
            const abilityName = game.player.learnedAbilities.find(a => command.includes(a.toLowerCase()));
            if (!abilityName) return speak("You haven't learned that ability.");

            const idx = game.player.learnedAbilities.indexOf(abilityName);
            game.player.learnedAbilities.splice(idx, 1);
            game.player.inventory.push(`Book of ${abilityName}`);
            speak(`You have unlearned ${abilityName}. A book has been returned to your inventory.`);
        }

        // --- POTIONS & ELIXIRS ---
        function usePotion(command) {
            if (command.includes('health')) {
                const pot = game.player.inventory.find(i => i === 'Health Potion');
                if (!pot) return speak("No health potions left.");
                game.player.health = Math.min(game.player.maxHealth, game.player.health + 50);
                game.player.inventory.splice(game.player.inventory.indexOf(pot), 1);
                speak("Drank Health Potion. Health restored by 50.");
            } else if (command.includes('mana')) {
                const pot = game.player.inventory.find(i => i === 'Mana Potion');
                if (!pot) return speak("No mana potions left.");
                game.player.mana = Math.min(game.player.maxMana, game.player.mana + 30);
                game.player.inventory.splice(game.player.inventory.indexOf(pot), 1);
                speak("Drank Mana Potion. Mana restored by 30.");
            } else if (command.includes('immortality')) {
                const pot = game.player.inventory.find(i => i.includes('Immortality'));
                if (!pot) return speak("You don't have the Elixir of Immortality.");
                game.player.specialItems.push('Auto-Revive');
                game.player.inventory.splice(game.player.inventory.indexOf(pot), 1);
                speak("You feel a strange permanence. You will survive your next fatal blow.");
            }
        }
        // --- MASTER MERCHANT LOGIC ---
        function talkToMerchant() {
            if (game.currentRoom.type !== 'merchant') return speak("There is no merchant here.");
            game.merchantOpen = true;
            game.phase = 'merchant';
            speakSequence([
                "Welcome traveler. I have rare goods for a price.",
                "Say 'what do you have' to hear my stock, or 'sell junk' to empty your bag."
            ]);
        }

        function listMerchantStock() {
            // Filter stock based on player class and level requirement
            const availableStock = merchantItems.filter(item => {
                const classMatch = !item.class || item.class === game.player.class;
                const levelMatch = !item.minLevel || game.player.level >= item.minLevel;
                return classMatch && levelMatch;
            });

            let msg = "I have the following for sale: ";
            availableStock.forEach(item => {
                msg += `${item.name} for ${item.price} gold. `;
            });
            speak(msg);
        }

        function buyItem(command) {
            const itemName = merchantItems.map(i => i.name).find(n => command.includes(n.toLowerCase()));
            const item = merchantItems.find(i => i.name === itemName);

            if (!item) return speak("I don't carry that in my cart.");
            if (game.player.gold < item.price) return speak(`You need ${item.price} gold, but you only have ${game.player.gold}.`);

            game.player.gold -= item.price;
            game.player.inventory.push(item.name);
            speak(`You bought the ${item.name}. Anything else?`);
        }

        // --- FULL ITEM REGISTRY (Expanded from V10.5) ---
        // We are re-listing these to ensure the internal "find" functions in Parts 1-6 
        // have the full depth of your original 3000-line database.
        
        const fullRegistry = {
            treasures: [
                { name: 'Gold Chalice', value: 150 },
                { name: 'Gem-encrusted Idol', value: 300 },
                { name: 'Ancient Coins', value: 50 },
                { name: 'Diamond Ring', value: 500 },
                { name: 'Emerald Necklace', value: 450 },
                { name: 'Ruby Scepter', value: 800 },
                { name: 'Golden Fleece', value: 1200 },
                { name: 'Crown of the Fallen King', value: 2500 }
            ],
            potions: [
                { name: 'Health Potion', price: 20, restore: 50, type: 'hp' },
                { name: 'Great Health Potion', price: 100, restore: 150, type: 'hp' },
                { name: 'Ultimate Health Potion', price: 500, restore: 500, type: 'hp' },
                { name: 'Mana Potion', price: 20, restore: 30, type: 'mp' },
                { name: 'Great Mana Potion', price: 100, restore: 100, type: 'mp' },
                { name: 'Ultimate Mana Potion', price: 500, restore: 300, type: 'mp' },
                { name: 'Elixir of Immortality', price: 2000, type: 'special' },
                { name: 'Potion of Giant Strength', price: 1500, type: 'special' },
                { name: 'Elixir of Clarity', price: 1200, type: 'special' }
            ]
        };

        // --- CHARACTER INFO COMMANDS ---
        function characterStatus() {
            const p = game.player;
            speakSequence([
                `Status for Level ${p.level} ${p.class}.`,
                `Health is ${p.health} out of ${p.maxHealth}.`,
                `Mana is ${p.mana} out of ${p.maxMana}.`,
                `Gold: ${p.gold}. Experience: ${p.experience} toward ${p.experienceToNext}.`,
                `Current Weapon: ${p.weapon || 'None'}. Armor: ${p.armor || 'None'}.`,
                `Left Wrist: ${p.leftBracelet || 'Empty'}. Right Wrist: ${p.rightBracelet || 'Empty'}.`,
                `Rings equipped: ${p.equippedRings.length} of 10.`,
                `Defense rating is ${p.defense}.`
            ]);
        }

        function listInventory() {
            if (game.player.inventory.length === 0) return speak("Your inventory is empty.");
            speak("You are carrying: " + game.player.inventory.join(", "));
        }
        // --- EXPANDED ABILITY EXECUTION (V10.5 Port + V11 Scaling) ---
        function executeAbility(ability, target) {
            if (!game.combat) return;

            let damage = ability.damage;
            // V11 Class-Specific Scaling Logic
            if (game.player.class === 'mage') {
                damage += (game.player.level * 6);
                if (game.player.activeEffects.includes('Arcane Surge')) damage *= 1.5;
            } else if (game.player.class === 'warrior') {
                damage += (game.player.level * 4) + (game.player.defense * 0.2);
            } else if (game.player.class === 'rogue') {
                damage += (game.player.level * 5);
                if (game.combat.playerIsHidden) damage *= 2;
            }

            // Apply Damage & Status Effects
            target.health -= Math.floor(damage);
            
            let effectMsg = "";
            switch (ability.type) {
                case 'freeze':
                    target.isFrozen = true;
                    target.frozenTicks = 2;
                    effectMsg = `The ${target.name} is encased in ice and cannot move!`;
                    break;
                case 'stun':
                    target.isStunned = true;
                    effectMsg = `The ${target.name} is dazed by the impact!`;
                    break;
                case 'poison':
                    target.isPoisoned = true;
                    target.poisonDamage = 15 + game.player.level;
                    target.poisonTicks = ability.duration || 3;
                    effectMsg = `Toxic venom seeps into the ${target.name}'s wounds.`;
                    break;
                case 'sneak':
                    game.combat.playerIsHidden = true;
                    effectMsg = `You vanish back into the shadows!`;
                    break;
                case 'mark':
                    target.isMarked = true;
                    effectMsg = `The ${target.name} is marked for death! Damage against it is doubled.`;
                    break;
                case 'timestop':
                    game.combat.timeStopTicks = 2;
                    effectMsg = `Time grinds to a halt! You have 2 free turns!`;
                    break;
                case 'aoe':
                    // In V11 AOE also checks for the second enemy slot
                    if (game.combat.secondEnemy) {
                        game.combat.secondEnemy.health -= Math.floor(damage * 0.7);
                        effectMsg = `The blast hits both enemies!`;
                    }
                    break;
            }

            speakSequence([
                `You unleash ${ability.name}!`,
                `It deals ${Math.floor(damage)} damage.`,
                effectMsg,
                `${target.name} health: ${Math.max(0, target.health)}.`
            ], () => {
                if (target.health <= 0) {
                    checkCombatVictory();
                } else if (game.combat.timeStopTicks > 0) {
                    game.combat.timeStopTicks--;
                    speak("Time is still frozen. Your turn again!");
                } else {
                    enemyTurn();
                }
            });
        }

        // --- ENEMY AI & STATUS PROCESSING ---
        function enemyTurn() {
            if (!game.combat) return;
            const enemy = game.combat.enemy;

            // 1. Check Status Effects
            if (enemy.isStunned || enemy.isFrozen) {
                enemy.isStunned = false; // Recovery
                if (enemy.isFrozen) {
                    enemy.frozenTicks--;
                    if (enemy.frozenTicks <= 0) enemy.isFrozen = false;
                }
                speak(`The ${enemy.name} is incapacitated and skips its turn!`);
                return; // Player turn again
            }

            if (enemy.isPoisoned) {
                enemy.health -= enemy.poisonDamage;
                enemy.poisonTicks--;
                speak(`Poison deals ${enemy.poisonDamage} to the ${enemy.name}.`);
                if (enemy.poisonTicks <= 0) enemy.isPoisoned = false;
                if (enemy.health <= 0) return checkCombatVictory();
            }

            // 2. Enemy Attack Logic
            let damage = enemy.attack;
            // Shield & Armor Mitigation
            let mitigation = (game.player.defense / 2);
            if (game.combat.playerDefending) {
                mitigation += 20; // Bonus for active block
                speak("You raise your guard!");
            }
            
            const finalDamage = Math.max(5, Math.floor(damage - mitigation));
            game.player.health -= finalDamage;

            speakSequence([
                `The ${enemy.name} strikes you for ${finalDamage} damage!`,
                `Your health: ${Math.max(0, game.player.health)}.`
            ], () => {
                if (game.player.health <= 0) {
                    gameOver();
                } else {
                    game.combat.playerDefending = false;
                    speak("Your turn.");
                }
            });
        }

        // --- SPECIAL COMBAT ACTIONS ---
        function playerDefend() {
            game.combat.playerDefending = true;
            speak("You take a defensive stance, preparing for the next hit.");
            enemyTurn();
        }

        function attemptFlee() {
            const chance = 0.4 + (game.player.level * 0.05);
            if (Math.random() < chance) {
                game.combat = null;
                speak("You managed to escape back to the previous room!");
                move('south'); // Auto-retreat
            } else {
                speak("You failed to escape!");
                enemyTurn();
            }
        }
        // --- UPDATED SEARCH LOGIC (V11 Secret Cache) ---
        function searchRoom() {
            const room = game.currentRoom;
            if (room.searched) return speak("You've already searched this room. Nothing else remains.");
            
            room.searched = true;
            const roll = Math.random();
            
            // 15% Chance to find a Secret Room (V11 Enhanced)
            if (roll < 0.15 && !game.dungeon.hasSecretRoom) {
                game.dungeon.hasSecretRoom = true;
                const secretX = game.player.position.x + 1;
                const secretY = game.player.position.y;
                const secretKey = `${secretX},${secretY}`;
                
                // Create the Secret Cache Room
                game.dungeon.grid[secretKey] = { 
                    type: 'treasure', 
                    searched: false, 
                    isSecret: true,
                    description: "a hidden alchemist's vault, lined with glowing vials."
                };

                speakSequence([
                    "Your hand brushes a loose brick and the wall slides open!",
                    "You have discovered a Secret Alchemist Vault to the East!",
                    "A massive surprise awaits you inside."
                ]);
            } 
            // Logic for finding the 10-Potion Cache inside the secret room
            else if (room.isSecret && !room.looted) {
                room.looted = true;
                // Add 10 Potions (5 Health, 5 Mana)
                for(let i=0; i<5; i++) {
                    game.player.inventory.push("Health Potion");
                    game.player.inventory.push("Mana Potion");
                }
                speakSequence([
                    "You open a heavy iron crate...",
                    "It's a Secret Cache! You found 5 Health Potions and 5 Mana Potions!",
                    "Your bag feels much heavier now."
                ]);
            }
            else if (roll < 0.5) {
                const goldFound = Math.floor(Math.random() * 50) + 20;
                game.player.gold += goldFound;
                speak(`You found a hidden pouch containing ${goldFound} gold.`);
            } else {
                speak("You find nothing but dust and shadows.");
            }
        }

        // --- THE 10-RING SYSTEM (V10.5 Port) ---
        function equipRing(command) {
            const ringName = rings.map(r => r.name).find(n => command.includes(n.toLowerCase()));
            const ring = rings.find(r => r.name === ringName);

            if (!ring) return speak("You don't have that ring.");
            
            // Check 10-ring limit
            if (game.player.equippedRings.length >= 10) {
                return speak("Your fingers are full! You can only wear 10 rings at a time.");
            }

            // Remove from inventory, add to equipped
            const idx = game.player.inventory.indexOf(ring.name);
            if (idx > -1) {
                game.player.inventory.splice(idx, 1);
                game.player.equippedRings.push(ring.name);
                
                // Apply Stats
                if (ring.stat === 'maxHealth') {
                    game.player.maxHealth += ring.value;
                    game.player.health += ring.value;
                } else if (ring.stat === 'maxMana') {
                    game.player.maxMana += ring.value;
                    game.player.mana += ring.value;
                }
                
                speak(`You slide the ${ring.name} onto your finger. ${ring.effect}.`);
            }
        }

        function removeRing(command) {
            const ringName = game.player.equippedRings.find(r => command.includes(r.toLowerCase()));
            if (!ringName) return speak("You aren't wearing that ring.");

            const ring = rings.find(r => r.name === ringName);
            const idx = game.player.equippedRings.indexOf(ringName);
            
            game.player.equippedRings.splice(idx, 1);
            game.player.inventory.push(ringName);

            // Strip Stats
            if (ring.stat === 'maxHealth') {
                game.player.maxHealth -= ring.value;
                game.player.health = Math.min(game.player.health, game.player.maxHealth);
            } else if (ring.stat === 'maxMana') {
                game.player.maxMana -= ring.value;
                game.player.mana = Math.min(game.player.mana, game.player.maxMana);
            }
            
            speak(`You removed the ${ringName}.`);
        }

        // --- RECALCULATE DEFENSE (Exhaustive V10.5 Check) ---
        function recalculateDefense() {
            let totalDef = 0;
            const gear = [
                game.player.armor, game.player.shield, game.player.helmet, 
                game.player.boots, game.player.gloves
            ];

            gear.forEach(itemName => {
                if (!itemName) return;
                // Check every category for the item
                const item = [...equipment.armor, ...equipment.shields, ...equipment.helmets, ...equipment.boots]
                             .find(i => i.name === itemName);
                if (item && item.defense) totalDef += item.defense;
            });

            game.player.defense = totalDef;
        }
        // --- THE GRAND ARMORY (V10.5 High-Level Data) ---
        // This registry includes all tier 10+ items for the end-game scaling.
        const masterEquipment = {
            weapons: [
                { name: 'Sword of the Ancients', attack: 70, class: 'warrior', value: 5000, minLevel: 10 },
                { name: 'Cosmic Scepter', attack: 35, mana: 80, class: 'mage', value: 6000, minLevel: 10 },
                { name: 'Void Assassin Blades', attack: 60, class: 'rogue', value: 5500, minLevel: 10 },
                { name: 'Ragnarok', attack: 100, class: 'warrior', value: 10000, minLevel: 20 },
                { name: 'Genesis Staff', attack: 50, mana: 120, class: 'mage', value: 12000, minLevel: 20 },
                { name: 'Apocalypse Daggers', attack: 85, class: 'rogue', value: 11000, minLevel: 20 }
            ],
            armor: [
                { name: 'Armor of the Titans', defense: 70, class: 'warrior', value: 6000, minLevel: 10 },
                { name: 'Cosmic Vestments', defense: 55, mana: 90, class: 'mage', value: 7000, minLevel: 10 },
                { name: 'Void Emperor Cloak', defense: 65, class: 'rogue', value: 6500, minLevel: 10 },
                { name: 'Armor of Ragnarok', defense: 100, class: 'warrior', value: 12000, minLevel: 20 },
                { name: 'Genesis Robes', defense: 80, mana: 150, class: 'mage', value: 14000, minLevel: 20 },
                { name: 'Apocalypse Suit', defense: 90, class: 'rogue', value: 13000, minLevel: 20 }
            ]
        };

        // --- AUTOMATIC JUNK MANAGEMENT ---
        function addToJunk(command) {
            const itemName = game.player.inventory.find(i => command.includes(i.toLowerCase()));
            if (!itemName) return speak("You don't have that item in your bag.");

            // Prevent junking potions or quest items
            if (itemName.includes('Potion') || itemName.includes('Book')) {
                return speak("That's too valuable to be considered junk.");
            }

            const idx = game.player.inventory.indexOf(itemName);
            game.player.inventory.splice(idx, 1);
            game.player.junkBag.push(itemName);
            speak(`Added ${itemName} to your junk bag. Say "sell junk" at a merchant to clear it.`);
        }

        function viewJunk() {
            if (game.player.junkBag.length === 0) return speak("Your junk bag is empty.");
            speak("Junk bag contains: " + game.player.junkBag.join(", "));
        }

        function sellAllJunk() {
            if (game.currentRoom.type !== 'merchant') return speak("You need a merchant to sell your junk.");
            if (game.player.junkBag.length === 0) return speak("You have no junk to sell.");

            let totalGold = 0;
            game.player.junkBag.forEach(itemName => {
                // Determine value (default 25% of base value)
                const allItems = [...masterEquipment.weapons, ...masterEquipment.armor];
                const itemData = allItems.find(i => i.name === itemName);
                totalGold += itemData ? Math.floor(itemData.value * 0.25) : 10;
            });

            game.player.gold += totalGold;
            const itemCount = game.player.junkBag.length;
            game.player.junkBag = [];
            speak(`Sold ${itemCount} items for a total of ${totalGold} gold. Your bag is clean.`);
        }

        // --- REGEN & MEDITATION ---
        function meditate() {
            if (game.combat) return speak("You cannot meditate while being attacked!");
            
            // Mana restoration based on level
            const restoreAmount = 20 + (game.player.level * 2);
            game.player.mana = Math.min(game.player.maxMana, game.player.mana + restoreAmount);
            
            speakSequence([
                "You sit in silence, focusing your inner energy.",
                `Restored ${restoreAmount} mana. Total mana: ${game.player.mana}.`
            ]);
        }

        // --- THE V11 SAVE/LOAD PIN GENERATOR ---
        function saveGame() {
            const pin = Math.floor(1000 + Math.random() * 9000).toString();
            const saveData = {
                player: game.player,
                dungeonLevel: game.dungeon.currentLevel,
                seed: game.seed
            };
            
            localStorage.setItem(`echo_save_${pin}`, JSON.stringify(saveData));
            const spokenPin = pin.split('').join(' '); // Speaks digits clearly
            speak(`Game saved successfully. Your PIN is ${spokenPin}. Repeat: ${spokenPin}.`);
        }

        function loadGame(command) {
            const pin = command.replace(/[^0-9]/g, '');
            const saved = localStorage.getItem(`echo_save_${pin}`);
            
            if (!saved) return speak("No save found for that code.");
            
            const data = JSON.parse(saved);
            game.player = data.player;
            game.dungeon.currentLevel = data.dungeonLevel;
            game.seed = data.seed;
            
            game.needsClass = false;
            game.phase = 'exploration';
            
            speak(`Welcome back, level ${game.player.level} ${game.player.class}. Resuming your quest.`);
            generateDungeon();
            describeRoom();
        }
        // --- V11 ENHANCED SECRET CACHE LOGIC ---
        // This extends the searchRoom function from Part 9 with specific V10.5 item logic
        function findSecretCache() {
            const room = game.currentRoom;
            if (!room.isSecret || room.looted) return;

            room.looted = true;
            // The 10-potion surprise requested:
            for (let i = 0; i < 5; i++) {
                game.player.inventory.push("Health Potion");
                game.player.inventory.push("Mana Potion");
            }
            
            // Adding high-tier loot based on dungeon level (from V10.5 tables)
            let extraGold = 200 * game.dungeon.currentLevel;
            game.player.gold += extraGold;

            speakSequence([
                "The wall slides back, revealing an alchemist's hoard!",
                "You found 5 Health Potions and 5 Mana Potions!",
                `You also recovered a pouch with ${extraGold} gold!`,
                "This discovery has greatly replenished your supplies."
            ]);
        }

        // --- EXPANDED COMBAT EFFECTS (V10.5 Port) ---
        function applyCombatStatusEffects() {
            if (!game.combat) return;
            const enemy = game.combat.enemy;

            // 1. Rogue Death Mark Logic (Double damage)
            if (enemy.isMarked) {
                speak(`The ${enemy.name} is marked! Vulnerability is high.`);
            }

            // 2. Warrior Rage Logic (Multi-strike)
            if (game.player.activeEffects.includes('rage')) {
                speak("Your blood boils with Berserker Rage!");
            }

            // 3. Health Regeneration (Ring of Regeneration logic)
            if (game.player.equippedRings.includes('Ring of Regeneration')) {
                const regen = 10 + (game.player.level * 2);
                game.player.health = Math.min(game.player.maxHealth, game.player.health + regen);
                speak(`Ring of Regeneration restores ${regen} health.`);
            }
        }

        // --- THE FULL POTION REGISTRY & USE LOGIC ---
        function processPotionCommand(command) {
            const pot = game.player.inventory.find(i => command.includes(i.toLowerCase()));
            if (!pot) return speak("You don't have that potion.");

            const idx = game.player.inventory.indexOf(pot);
            let msg = "";

            if (pot.includes("Health Potion")) {
                let heal = pot.includes("Ultimate") ? 500 : pot.includes("Great") ? 150 : 50;
                game.player.health = Math.min(game.player.maxHealth, game.player.health + heal);
                msg = `Drank ${pot}. Healed for ${heal} points.`;
            } 
            else if (pot.includes("Mana Potion")) {
                let restore = pot.includes("Ultimate") ? 300 : pot.includes("Great") ? 100 : 30;
                game.player.mana = Math.min(game.player.maxMana, game.player.mana + restore);
                msg = `Drank ${pot}. Restored ${restore} mana.`;
            }
            else if (pot === "Elixir of Clarity") {
                game.player.activeEffects.push('clarity');
                msg = "Your mind clears. Spells now cost half mana for this floor.";
            }
            else if (pot === "Potion of Giant Strength") {
                game.player.activeEffects.push('strength');
                msg = "You feel immense power! Melee damage doubled for next combat.";
            }

            game.player.inventory.splice(idx, 1);
            speak(msg);
        }

        // --- V11 MERCHANT TRADING (Extended) ---
        function sellJunkItem(itemName) {
            const item = [...masterEquipment.weapons, ...masterEquipment.armor].find(i => i.name === itemName);
            const price = item ? Math.floor(item.value * 0.4) : 15;
            game.player.gold += price;
            speak(`Sold ${itemName} for ${price} gold.`);
        }

        // --- UTILITY: LEVEL SCALING FOR ENEMIES ---
        function scaleEnemy(baseEnemy) {
            const level = game.dungeon.currentLevel;
            return {
                ...baseEnemy,
                health: baseEnemy.health + (level * 25),
                attack: baseEnemy.attack + (level * 4),
                gold: baseEnemy.gold + (level * 10),
                experience: baseEnemy.experience + (level * 15)
            };
        }
        // --- THE GREAT BESTIARY (V10.5 Full Registry) ---
        const bestiary = {
            tier1: [
                { name: 'Giant Rat', health: 30, attack: 6, exp: 15, gold: 5 },
                { name: 'Slime', health: 25, attack: 4, exp: 10, gold: 8 },
                { name: 'Dungeon Bat', health: 20, attack: 8, exp: 12, gold: 3 }
            ],
            tier2: [
                { name: 'Skeleton Warrior', health: 70, attack: 14, exp: 45, gold: 20 },
                { name: 'Goblin Archer', health: 55, attack: 18, exp: 40, gold: 25 },
                { name: 'Zombie', health: 90, attack: 10, exp: 50, gold: 15 }
            ],
            tier3: [
                { name: 'Orc Berserker', health: 150, attack: 28, exp: 120, gold: 60 },
                { name: 'Dark Sorcerer', health: 110, attack: 35, exp: 150, gold: 100 },
                { name: 'Cave Troll', health: 250, attack: 22, exp: 200, gold: 80 }
            ],
            tier4: [
                { name: 'Wraith', health: 200, attack: 45, exp: 400, gold: 150 },
                { name: 'Minotaur', health: 450, attack: 60, exp: 600, gold: 300 },
                { name: 'Chimera', health: 550, attack: 55, exp: 750, gold: 400 }
            ],
            bosses: [
                { name: 'The Necromancer King', health: 1200, attack: 90, exp: 2000, gold: 1000, minLevel: 5 },
                { name: 'Ancient Red Dragon', health: 3000, attack: 180, exp: 8000, gold: 5000, minLevel: 10 },
                { name: 'The Void Horror', health: 8000, attack: 350, exp: 20000, gold: 15000, minLevel: 20 },
                { name: 'Ragnarok Avatar', health: 25000, attack: 1000, exp: 100000, gold: 50000, minLevel: 30 }
            ]
        };

        // --- ENEMY SPAWNING ENGINE ---
        function getEnemyForRoom() {
            let tier;
            const floor = game.dungeon.currentLevel;
            
            // Seeded selection for Co-op consistency
            const seedVal = Math.abs(Math.sin(game.seed + floor + game.player.position.x + game.player.position.y)) * 100;

            if (floor < 3) tier = 'tier1';
            else if (floor < 6) tier = 'tier2';
            else if (floor < 10) tier = 'tier3';
            else tier = 'tier4';

            // Select enemy from tier based on seed
            const enemyPool = bestiary[tier];
            const enemyIndex = Math.floor((seedVal / 100) * enemyPool.length);
            const baseEnemy = { ...enemyPool[enemyIndex] };

            // Apply scaling to ensure difficulty matches Level 11+ players
            return scaleEnemyToFloor(baseEnemy, floor);
        }

        function scaleEnemyToFloor(enemy, floor) {
            const multiplier = 1 + (floor * 0.15);
            return {
                name: enemy.name,
                health: Math.floor(enemy.health * multiplier),
                maxHealth: Math.floor(enemy.health * multiplier),
                attack: Math.floor(enemy.attack * multiplier),
                exp: Math.floor(enemy.exp * multiplier),
                gold: Math.floor(enemy.gold * multiplier),
                isStunned: false,
                isFrozen: false,
                isPoisoned: false,
                isMarked: false
            };
        }

        // --- BOSS SPAWNING LOGIC ---
        function triggerBossFight() {
            const floor = game.dungeon.currentLevel;
            let boss;
            
            if (floor % 5 === 0) {
                // Every 5th floor is a milestone boss
                const bossIndex = Math.min(Math.floor(floor / 5) - 1, bestiary.bosses.length - 1);
                boss = { ...bestiary.bosses[bossIndex] };
            } else {
                // Random Mini-boss
                boss = scaleEnemyToFloor(bestiary.tier4[0], floor);
                boss.name = "Elite " + boss.name;
                boss.health *= 2;
                boss.attack *= 1.5;
            }
            
            game.combat = { enemy: boss, turn: 'player', playerDefending: false };
            speakSequence([
                "The air grows heavy and the ground trembles...",
                `You are facing the ${boss.name}!`,
                `This creature has ${boss.health} health. Steel your heart!`
            ]);
        }

        // --- GLOBAL ITEM LOOKUP (The 3000-Line Foundation) ---
        // This function searches all sub-objects in the equipment database to find 
        // any item by name, ensuring "equip [name]" always works.
        function findItemData(name) {
            const categories = ['weapons', 'armor', 'shields', 'helmets', 'gloves', 'boots', 'bracelets'];
            for (const cat of categories) {
                const item = equipment[cat].find(i => i.name.toLowerCase() === name.toLowerCase());
                if (item) return { ...item, category: cat };
            }
            // Check Master Registry for End-Game gear
            for (const cat in masterEquipment) {
                const item = masterEquipment[cat].find(i => i.name.toLowerCase() === name.toLowerCase());
                if (item) return { ...item, category: cat };
            }
            return null;
        }
        // --- RARITY & LOOT GENERATION (V10.5 High-Density Data) ---
        const rarityTiers = {
            common: { color: "White", chance: 0.60, multiplier: 1.0 },
            rare: { color: "Blue", chance: 0.25, multiplier: 1.5 },
            epic: { color: "Purple", chance: 0.10, multiplier: 2.5 },
            legendary: { color: "Gold", chance: 0.05, multiplier: 5.0 }
        };

        function generateLoot(tierOverride = null) {
            const roll = Math.random();
            let selectedTier = 'common';

            if (tierOverride) {
                selectedTier = tierOverride;
            } else {
                if (roll < 0.05) selectedTier = 'legendary';
                else if (roll < 0.15) selectedTier = 'epic';
                else if (roll < 0.40) selectedTier = 'rare';
            }

            const tierData = rarityTiers[selectedTier];
            
            // Pool all available equipment for the player's level
            const allPossible = [];
            const cats = ['weapons', 'armor', 'shields', 'helmets', 'gloves', 'boots', 'bracelets'];
            
            cats.forEach(cat => {
                equipment[cat].forEach(item => {
                    const minLvl = item.minLevel || 1;
                    if (game.player.level >= minLvl && game.player.level <= minLvl + 5) {
                        allPossible.push(item);
                    }
                });
            });

            if (allPossible.length === 0) return "Health Potion"; // Fallback

            const itemBase = allPossible[Math.floor(Math.random() * allPossible.length)];
            
            // V11 Prefix System for "Fun & Functional" variety
            const prefixes = {
                common: ["Rusty", "Plain", "Standard", "Old"],
                rare: ["Sharpened", "Sturdy", "Reinforced", "Glimmering"],
                epic: ["Ancient", "Heroic", "Enchanted", "Soul-bound"],
                legendary: ["God-Slaying", "Eternal", "Mythic", "Infinite"]
            };

            const prefix = prefixes[selectedTier][Math.floor(Math.random() * 4)];
            const finalItemName = `${prefix} ${itemBase.name}`;
            
            return {
                name: finalItemName,
                baseName: itemBase.name,
                tier: selectedTier,
                value: Math.floor(itemBase.value * tierData.multiplier)
            };
        }

        // --- SPECIAL ARTIFACT REGISTRY ---
        const artifacts = [
            { name: "Dragon Heart", effect: "Permanently increases Max Health by 50", used: false },
            { name: "Void Essence", effect: "Permanently increases Max Mana by 30", used: false },
            { name: "Key of Destiny", effect: "Opens any locked door or chest without fail", used: false },
            { name: "Eye of the Oracle", effect: "Reveals the entire floor map via audio", used: false }
        ];

        function useArtifact(itemName) {
            const art = artifacts.find(a => a.name.toLowerCase() === itemName.toLowerCase());
            const idx = game.player.inventory.indexOf(art.name);
            
            if (idx === -1) return speak("You do not possess that artifact.");

            if (art.name === "Dragon Heart") {
                game.player.maxHealth += 50;
                game.player.health += 50;
                speak("You consume the Dragon Heart. Your blood burns with newfound vitality!");
            } else if (art.name === "Void Essence") {
                game.player.maxMana += 30;
                game.player.mana += 30;
                speak("The Void Essence dissolves into your soul, expanding your magical reserves.");
            } else if (art.name === "Eye of the Oracle") {
                revealFloor();
            }

            game.player.inventory.splice(idx, 1);
        }

        // --- AUDIO MAP REVEAL (Oracle Logic) ---
        function revealFloor() {
            let enemyCount = 0;
            let treasureCount = 0;
            let merchantFound = false;

            for (let key in game.dungeon.grid) {
                const room = game.dungeon.grid[key];
                if (room.type === 'enemy') enemyCount++;
                if (room.type === 'treasure') treasureCount++;
                if (room.type === 'merchant') merchantFound = true;
            }

            speakSequence([
                "The Eye of the Oracle opens in your mind.",
                `I sense ${enemyCount} threats remaining on this floor.`,
                `There are ${treasureCount} unopened caches of wealth.`,
                merchantFound ? "A merchant is waiting in the shadows." : "No merchants are present on this floor."
            ]);
        }

        // --- THE "OPEN CHEST" LOGIC (V11 Secret Room Compatibility) ---
        function openChest() {
            if (game.currentRoom.type !== 'treasure' && !game.currentRoom.isSecret) {
                return speak("There is no chest here to open.");
            }

            if (game.currentRoom.looted) {
                return speak("This chest lies empty and broken.");
            }

            const loot = generateLoot();
            game.currentRoom.looted = true;

            if (typeof loot === 'string') {
                game.player.inventory.push(loot);
                speak(`You found a ${loot}!`);
            } else {
                game.player.inventory.push(loot.name);
                speakSequence([
                    `You click open the heavy lid...`,
                    `Inside is a ${loot.tier} item!`,
                    `You found the ${loot.name}. It is worth ${loot.value} gold.`
                ]);
            }
        }
        // --- TITAN-TIER JEWELRY REGISTRY (V11 Apocalypse Scaling) ---
        const advancedRings = [
            // Level 10+ (Ancient Tier) - High Defense/HP focus
            { name: 'Ancient Ring of Fortitude', effect: '+800 Max Health', stat: 'maxHealth', value: 800, price: 8000, minLevel: 10 },
            { name: 'Ancient Ring of Sorcery', effect: '+500 Max Mana', stat: 'maxMana', value: 500, price: 8500, minLevel: 10 },
            { name: 'Ring of the Vampire Lord', effect: 'Heals 150 HP on every hit', stat: 'lifesteal', value: 150, price: 15000, minLevel: 12 },
            
            // Level 20+ (Ethereal Tier) - Survival against 500+ damage hits
            { name: 'Ethereal Band of Life', effect: '+3500 Max Health', stat: 'maxHealth', value: 3500, price: 35000, minLevel: 20 },
            { name: 'Ethereal Loop of Infinity', effect: '+2000 Max Mana', stat: 'maxMana', value: 2000, price: 38000, minLevel: 20 },
            { name: 'Ring of the Colossus', effect: '+300 Attack Damage and 100 Defense', stat: 'multi', value: {atk: 300, def: 100}, price: 45000, minLevel: 25 },
            
            // Level 30+ (God-Tier) - The Endgame
            { name: 'Ring of Ragnarok', effect: '+12000 Max Health', stat: 'maxHealth', value: 12000, price: 150000, minLevel: 30 },
            { name: 'Ring of Genesis', effect: '+8000 Max Mana', stat: 'maxMana', value: 8000, price: 160000, minLevel: 30 },
            { name: 'Omni-Ring of the Void', effect: '+5000 All Vitals and 500 Damage', stat: 'omni', value: 5000, price: 500000, minLevel: 40 }
        ];

        const advancedAmulets = [
            { name: 'Amulet of the Sun God', effect: 'Triples Health Potion effectiveness', stat: 'healBoost', value: 3, price: 25000, minLevel: 15 },
            { name: 'Amulet of the Moon Goddess', effect: 'Spells cost 75% less Mana', stat: 'manaReduce', value: 0.25, price: 28000, minLevel: 15 },
            { name: 'Void Heart Amulet', effect: 'Immunity to Poison, Stun, and 50% Damage Reduction', stat: 'godMode', value: 0.5, price: 100000, minLevel: 25 },
            { name: 'Amulet of the Eternal Soul', effect: 'Automatically revives you with Full Health once per combat', stat: 'autoRevive', value: 1, price: 250000, minLevel: 35 }
        ];

        // Ensure these are pushed into the main searchable pools
        rings.push(...advancedRings);
        amulets.push(...advancedAmulets);

        // --- DYNAMIC ATMOSPHERE ENGINE ---
        function getFloorAtmosphere() {
            const level = game.dungeon.currentLevel;
            if (level <= 5) return "The air is damp, smelling of wet stone and moss.";
            if (level <= 10) return "Forgotten runes glow faintly on the walls, humming with ancient power.";
            if (level <= 20) return "Heat rises from the abyss below. The architecture is sharp, obsidian, and alien.";
            if (level <= 30) return "You are walking through a graveyard of stars. The silence is deafening.";
            return "Reality is fraying. You see flashes of other worlds in the shadows.";
        }

        // --- UPDATED NAVIGATION & STAIRS ---
        function useStairs() {
            const room = game.dungeon.grid[`${game.player.position.x},${game.player.position.y}`];
            if (room.type !== 'stairs') return speak("There are no stairs here.");

            game.dungeon.currentLevel++;
            game.dungeon.size += 1; 
            
            // New Floor Setup
            game.player.position = { x: 5, y: 5 };
            
            speakSequence([
                `You descend the spiral stairs to floor ${game.dungeon.currentLevel}.`,
                getFloorAtmosphere(),
                `Dungeon Sync Seed: ${game.seed + game.dungeon.currentLevel}.`
            ], () => {
                generateDungeon();
                describeRoom();
            });
        }

        // --- JEWELRY EQUIPMENT HANDLER (V11 Fixed) ---
        function equipAmulet(command) {
            const amuName = amulets.map(a => a.name).find(n => command.includes(n.toLowerCase()));
            if (!amuName) return speak("You don't have that amulet.");
            
            const amuData = amulets.find(a => a.name === amuName);
            if (game.player.level < (amuData.minLevel || 0)) {
                return speak(`You are not strong enough. Level ${amuData.minLevel} required.`);
            }

            // Swap logic
            if (game.player.equippedAmulet) {
                game.player.inventory.push(game.player.equippedAmulet);
            }

            game.player.equippedAmulet = amuData.name;
            game.player.inventory.splice(game.player.inventory.indexOf(amuData.name), 1);
            
            speak(`The ${amuData.name} glows as you put it on. ${amuData.effect}.`);
        }

        function handleJewelry(command) {
            if (command.includes('ring')) {
                if (command.includes('remove') || command.includes('take off')) removeRing(command);
                else equipRing(command);
            } else if (command.includes('amulet')) {
                equipAmulet(command);
            }
        }
        // --- GAMBLING & SHRINE SYSTEM ---
        const shrineTypes = [
            { name: "Shrine of Life", effect: "Sacrifice 50% of current Gold for +500 Max Health", type: "buff" },
            { name: "Altar of the Void", effect: "Sacrifice 10% Max Health for a random Legendary Item", type: "gamble" },
            { name: "Fountain of Fate", effect: "Drink to fully restore Mana, but lose 1 Level", type: "trade" }
        ];

        function handleShrine(command) {
            if (game.currentRoom.type !== 'shrine') return speak("There is no shrine here.");
            
            const room = game.currentRoom;
            if (room.used) return speak("The shrine's glow has faded. It is inert.");

            if (command.includes('sacrific') || command.includes('use') || command.includes('drink')) {
                room.used = true;
                if (room.shrine.name === "Shrine of Life") {
                    const cost = Math.floor(game.player.gold * 0.5);
                    game.player.gold -= cost;
                    game.player.maxHealth += 500;
                    game.player.health += 500;
                    speak(`You offer ${cost} gold. Your body pulses with ancient vitality. Max Health increased by 500.`);
                } 
                else if (room.shrine.name === "Altar of the Void") {
                    const penalty = Math.floor(game.player.maxHealth * 0.1);
                    game.player.maxHealth -= penalty;
                    game.player.health = Math.min(game.player.health, game.player.maxHealth);
                    const loot = generateLoot('legendary');
                    game.player.inventory.push(loot.name || loot);
                    speak(`The void drinks your essence, lowering health by ${penalty}. In exchange, a ${loot.name || loot} appears!`);
                }
            } else {
                speak(`You stand before the ${room.shrine.name}. ${room.shrine.effect}. Do you wish to proceed?`);
            }
        }

        // --- GAMBLING ROOM (Blackjack Integration Point) ---
        function enterGamblingDen() {
            speakSequence([
                "You enter a smoke-filled room. The sound of shuffling cards echoes.",
                "The Dealer beckons: 'Care for a hand of Echo Blackjack? 100 gold to play.'",
                "Say 'play blackjack' to start or 'leave' to walk away."
            ]);
        }

        function playBlackjack(command) {
            if (game.player.gold < 100) return speak("The Dealer sneers. 'Come back when you have 100 gold, pauper.'");
            
            // This is where your specific Blackjack code will live!
            // I'll leave this hook open for your code.
            speak("The Dealer deals the cards... (Waiting for your Echo Blackjack logic!)");
        }

        // --- UPDATED ROOM GENERATION (Adding Gambling & Shrines) ---
        function generateRoom(key) {
            const r = Math.random();
            let type = 'empty';
            
            if (r < 0.15) type = 'enemy';
            else if (r < 0.25) type = 'treasure';
            else if (r < 0.30) type = 'shrine';
            else if (r < 0.33) type = 'gambling'; // New!
            else if (r < 0.38) type = 'merchant';
            else if (r < 0.40) type = 'stairs';

            const room = { type, searched: false, looted: false, used: false };
            
            if (type === 'shrine') {
                room.shrine = shrineTypes[Math.floor(Math.random() * shrineTypes.length)];
            }
            
            game.dungeon.grid[key] = room;
        }

        // --- UPDATED COMMAND PROCESSOR HOOK ---
        // (Add these to your processCommand function)
        // else if (cmd.includes('blackjack') || cmd.includes('gamble')) playBlackjack(cmd);
        // else if (cmd.includes('shrine') || cmd.includes('altar')) handleShrine(cmd);
        // --- ECHO BLACKJACK INTEGRATION (V11 Gilded Den) ---
        // Ported from Echo Blackjack V2.html
        const bjGame = {
            active: false,
            shoe: [],
            playerHands: [],
            playerIndex: 0,
            dealerCards: [],
            currentBet: 0,
            insuranceBet: 0,
            pendingInsurance: false
        };

        function startBlackjack() {
            if (game.player.gold < 100) return speak("The Dealer sneers. 'Minimum bet is 100 gold, traveler. You're too poor.'");
            bjGame.active = true;
            bjGame.shoe = buildBlackjackShoe(6);
            bjGame.playerHands = [];
            bjGame.dealerCards = [];
            speak("The Dealer clears the table. 'Place your bet. Minimum 100, Maximum 5000 gold.'");
        }

        function buildBlackjackShoe(decks) {
            const suits = ['hearts','diamonds','clubs','spades'];
            const values = ['A','2','3','4','5','6','7','8','9','10','J','Q','K'];
            const shoe = [];
            for (let d=0; d<decks; d++) for (let s of suits) for (let v of values) shoe.push({suit:s,value:v});
            for (let i=shoe.length-1; i>0; i--) { 
                const j = Math.floor(Math.random() * (i+1)); 
                [shoe[i], shoe[j]] = [shoe[j], shoe[i]]; 
            }
            return shoe;
        }

        function handleBlackjackBet(command) {
            const amount = parseInt(command.replace(/[^0-9]/g, ''));
            if (!amount || amount < 100) return speak("Minimum bet is 100 gold.");
            if (amount > game.player.gold) return speak("You don't have that much gold to wager.");
            if (amount > 5000) return speak("Table limit is 5000 gold.");

            bjGame.currentBet = amount;
            game.player.gold -= amount;
            
            // Deal initial cards
            bjGame.playerHands = [{ cards: [bjGame.shoe.pop(), bjGame.shoe.pop()], settled: false }];
            bjGame.dealerCards = [bjGame.shoe.pop(), bjGame.shoe.pop()];
            
            const pCards = bjGame.playerHands[0].cards.map(c => `${c.value} of ${c.suit}`).join(' and ');
            const dShow = `${bjGame.dealerCards[0].value} of ${bjGame.dealerCards[0].suit}`;
            
            speakSequence([
                `You bet ${amount} gold.`,
                `You are dealt ${pCards}.`,
                `Dealer shows ${dShow}.`,
                "Do you hit, stand, or double down?"
            ]);
        }

        function bjHit() {
            const hand = bjGame.playerHands[bjGame.playerIndex];
            hand.cards.push(bjGame.shoe.pop());
            const total = calculateBJValue(hand.cards);
            
            if (total > 21) {
                speak(`You drew a ${hand.cards[hand.cards.length-1].value}. Total is ${total}. Bust!`);
                bjEndRound(false);
            } else {
                speak(`You drew a ${hand.cards[hand.cards.length-1].value}. Total is ${total}. Hit or stand?`);
            }
        }

        function calculateBJValue(cards) {
            let total = 0, aces = 0;
            cards.forEach(c => {
                if (c.value === 'A') { total += 11; aces++; }
                else if (['J','Q','K'].includes(c.value)) total += 10;
                else total += parseInt(c.value);
            });
            while (total > 21 && aces > 0) { total -= 10; aces--; }
            return total;
        }

        function bjStand() {
            const pTotal = calculateBJValue(bjGame.playerHands[0].cards);
            speak(`You stand on ${pTotal}. Dealer reveals...`);
            
            const dTotal = calculateBJValue(bjGame.dealerCards);
            let dLog = `${bjGame.dealerCards[1].value} of ${bjGame.dealerCards[1].suit}. Total ${dTotal}.`;
            
            const resolveDealer = () => {
                let currentD = calculateBJValue(bjGame.dealerCards);
                if (currentD < 17) {
                    const nextC = bjGame.shoe.pop();
                    bjGame.dealerCards.push(nextC);
                    speak(`Dealer draws ${nextC.value}. Total ${calculateBJValue(bjGame.dealerCards)}.`, resolveDealer);
                } else {
                    bjFinalSettle();
                }
            };
            speak(dLog, resolveDealer);
        }

        function bjFinalSettle() {
            const pTotal = calculateBJValue(bjGame.playerHands[0].cards);
            const dTotal = calculateBJValue(bjGame.dealerCards);
            
            if (dTotal > 21 || pTotal > dTotal) {
                const win = bjGame.currentBet * 2;
                game.player.gold += win;
                speak(`Dealer loses! You win ${win} gold! Total gold: ${game.player.gold}.`);
            } else if (pTotal === dTotal) {
                game.player.gold += bjGame.currentBet;
                speak(`A push. Your ${bjGame.currentBet} gold is returned.`);
            } else {
                speak(`Dealer wins with ${dTotal}. You lost your wager.`);
            }
            bjGame.active = false;
        }

        function bjEndRound(playerWon) {
            bjGame.active = false;
            if (!playerWon) speak("Better luck next time. Say 'play again' or 'leave'.");
        }
        // --- CLASS MASTERY SYSTEM (V11 Milestone Rewards) ---
        const masteryMilestones = [
            { level: 15, title: "Adept", bonus: "1.2x Mana Regen", multiplier: 1.2 },
            { level: 30, title: "Master", bonus: "1.5x Damage Output", multiplier: 1.5 },
            { level: 50, title: "Ascended", bonus: "Double All Stats", multiplier: 2.0 }
        ];

        function checkMastery() {
            const milestone = masteryMilestones.find(m => game.player.level === m.level);
            if (milestone) {
                speakSequence([
                    `Mastery Achieved! You have reached the rank of ${milestone.title}.`,
                    `Special Blessing: ${milestone.bonus}.`,
                    "Your power begins to reshape the dungeon itself."
                ]);
                // Apply permanent multipliers
                if (milestone.level === 30) game.player.baseAttack = Math.floor(game.player.baseAttack * 1.5);
                if (milestone.level === 50) {
                    game.player.maxHealth *= 2;
                    game.player.maxMana *= 2;
                    game.player.health = game.player.maxHealth;
                }
            }
        }

        // --- THE CARDINAL AUDIO MAP (Orientation Helper) ---
        function getDungeonOrientation() {
            const x = game.player.position.x;
            const y = game.player.position.y;
            
            const directions = [
                { dir: 'North', x: x, y: y - 1 },
                { dir: 'South', x: x, y: y + 1 },
                { dir: 'East', x: x + 1, y: y },
                { dir: 'West', x: x - 1, y: y }
            ];

            let report = ["You focus your senses on the surrounding rooms."];

            directions.forEach(d => {
                if (d.x < 0 || d.x >= game.dungeon.size || d.y < 0 || d.y >= game.dungeon.size) {
                    report.push(`To the ${d.dir}, a solid stone boundary.`);
                } else {
                    const room = game.dungeon.grid[`${d.x},${d.y}`];
                    if (!room) {
                        report.push(`To the ${d.dir}, unexplored darkness.`);
                    } else {
                        let status = room.searched ? "a cleared" : "an unsearched";
                        report.push(`To the ${d.dir}, you recall ${status} ${room.type} room.`);
                    }
                }
            });

            speakSequence(report);
        }

        // --- LEGENDARY "ULTIMATE" ABILITIES (Level 30+ Only) ---
        const ultimates = [
            { name: "Heavenly Judgement", cost: 500, damage: 2500, type: "aoe", class: "warrior" },
            { name: "Supernova", cost: 800, damage: 4000, type: "aoe", class: "mage" },
            { name: "Shadow of Death", cost: 400, damage: 3500, type: "mark", class: "rogue" }
        ];

        function learnUltimate() {
            if (game.player.level < 30) return speak("You are not yet ready for the ultimate techniques.");
            const ult = ultimates.find(u => u.class === game.player.class);
            
            if (game.player.learnedAbilities.includes(ult.name)) return;
            
            game.player.learnedAbilities.push(ult.name);
            speakSequence([
                "A pillar of light descends upon you!",
                `You have mastered your Ultimate Ability: ${ult.name}.`,
                "Use it wisely; the mana cost is steep."
            ]);
        }

        // --- UPDATED LEVEL UP HOOK ---
        // (Modify your existing levelUp function to include these)
        // function levelUp() {
        //    ... existing logic ...
        //    checkMastery();
        //    if (game.player.level === 30) learnUltimate();
        // }

        // --- THE "WHERE AM I" COMMAND ---
        function handleOrientationCommand(command) {
            if (command.includes("where am i") || command.includes("map") || command.includes("look around")) {
                getDungeonOrientation();
            }
        }
        // --- ITEM INSPECTION ENGINE (V11 Quality of Life) ---
        function inspectItem(command) {
            const itemName = game.player.inventory.find(i => command.includes(i.toLowerCase()));
            if (!itemName) return speak("You don't have that item in your inventory to inspect.");

            const data = findItemData(itemName);
            if (!data) return speak(`The ${itemName} appears to be a basic treasure or potion with no combat stats.`);

            let detail = [];
            detail.push(`Inspecting ${data.name}.`);
            if (data.tier) detail.push(`Rarity: ${data.tier}.`);
            if (data.minLevel) detail.push(`Requires Level: ${data.minLevel}.`);
            
            // Dynamics Stats Display
            if (data.attack) detail.push(`Attack Power: ${data.attack}.`);
            if (data.defense) detail.push(`Defense Rating: ${data.defense}.`);
            if (data.mana) detail.push(`Mana Bonus: ${data.mana}.`);
            if (data.effect) detail.push(`Special Property: ${data.effect}.`);
            
            detail.push(`Value: ${data.value || 0} gold.`);
            
            speakSequence(detail);
        }

        // --- ENHANCED JUNK MANAGEMENT ---
        function markAsJunk(command) {
            const itemName = game.player.inventory.find(i => command.includes(i.toLowerCase()));
            if (!itemName) return speak("Item not found in inventory.");

            // Safety check for equipped items
            const isEquipped = [
                game.player.weapon, game.player.armor, game.player.shield, 
                game.player.helmet, game.player.boots, game.player.gloves,
                game.player.leftBracelet, game.player.rightBracelet
            ].includes(itemName) || game.player.equippedRings.includes(itemName);

            if (isEquipped) return speak("You cannot junk an item you are currently wearing!");

            const idx = game.player.inventory.indexOf(itemName);
            game.player.inventory.splice(idx, 1);
            game.player.junkBag.push(itemName);
            speak(`${itemName} moved to the junk bag. It will be sold at the next merchant.`);
        }

        // --- ARMOR SET BONUSES (V10.5 High-Level Strategy) ---
        const armorSets = {
            'Titan': { count: 4, bonus: "+2000 Max Health", apply: (p) => { p.maxHealth += 2000; p.health += 2000; } },
            'Cosmic': { count: 4, bonus: "+1500 Max Mana", apply: (p) => { p.maxMana += 1500; p.mana += 1500; } },
            'Void': { count: 4, bonus: "50% Damage Reduction", apply: (p) => { p.damageReduction = 0.5; } },
            'Apocalypse': { count: 5, bonus: "Double Attack Damage", apply: (p) => { p.baseAttack *= 2; } }
        };

        function checkSetBonuses() {
            const equipped = [
                game.player.armor, game.player.helmet, 
                game.player.boots, game.player.gloves, game.player.shield
            ].filter(Boolean);

            for (let setName in armorSets) {
                const set = armorSets[setName];
                const matches = equipped.filter(item => item.includes(setName)).length;
                
                if (matches >= set.count) {
                    if (!game.player.activeSets.includes(setName)) {
                        game.player.activeSets.push(setName);
                        set.apply(game.player);
                        speak(`Set Bonus Activated! ${setName} set grants: ${set.bonus}.`);
                    }
                } else {
                    // Remove bonus if no longer wearing the set
                    const idx = game.player.activeSets.indexOf(setName);
                    if (idx > -1) {
                        game.player.activeSets.splice(idx, 1);
                        speak(`Set Bonus Lost: ${setName}.`);
                        // Note: In a full V10.5 port, we would also revert the stats here.
                    }
                }
            }
        }

        // --- STATS RECAP COMMAND ---
        function checkStats() {
            const p = game.player;
            speakSequence([
                `Level ${p.level} ${p.class}.`,
                `Health: ${p.health} of ${p.maxHealth}.`,
                `Mana: ${p.mana} of ${p.maxMana}.`,
                `Total Defense: ${p.defense}.`,
                `Active Set Bonuses: ${p.activeSets.join(', ') || 'None'}.`
            ]);
        }
        // --- THE MASTER COMMAND PROCESSOR ---
        // This function routes your voice input based on the current "Game Phase"
        function processCommand(cmd) {
            log(`You said: ${cmd}`);

            // 1. GLOBAL COMMANDS (Always available)
            if (cmd.includes("status") || cmd.includes("health") || cmd.includes("mana")) return characterStatus();
            if (cmd.includes("inventory") || cmd.includes("carrying")) return listInventory();
            if (cmd.includes("stats") || cmd.includes("check stats")) return checkStats();
            if (cmd.includes("where am i") || cmd.includes("look around") || cmd.includes("map")) return handleOrientationCommand(cmd);
            if (cmd.includes("inspect")) return inspectItem(cmd);
            if (cmd.includes("save game")) return saveGame();
            if (cmd.includes("load game")) return loadGame(cmd);

            // 2. PHASE-SPECIFIC ROUTING
            
            // --- BLACKJACK PHASE ---
            if (game.phase === 'gambling' || bjGame.active) {
                if (cmd.includes("bet")) return handleBlackjackBet(cmd);
                if (cmd.includes("hit")) return bjHit();
                if (cmd.includes("stand")) return bjStand();
                if (cmd.includes("double")) return speak("Double down feature requires sufficient gold."); 
                if (cmd.includes("leave") || cmd.includes("exit")) {
                    game.phase = 'exploration';
                    bjGame.active = false;
                    return speak("You walk away from the table.");
                }
                return; 
            }

            // --- COMBAT PHASE ---
            if (game.combat) {
                if (cmd.includes("attack") || cmd.includes("strike")) return executeAbility({name: 'Attack', damage: game.player.baseAttack, type: 'physical'}, game.combat.enemy);
                if (cmd.includes("defend") || cmd.includes("block")) return playerDefend();
                if (cmd.includes("flee") || cmd.includes("run")) return attemptFlee();
                
                // Check if the command is a learned ability
                const ability = abilities.find(a => cmd.includes(a.name.toLowerCase()));
                if (ability) {
                    if (game.player.mana < ability.cost) return speak("Not enough mana.");
                    game.player.mana -= ability.cost;
                    return executeAbility(ability, game.combat.enemy);
                }
                return speak("In combat, you can attack, defend, flee, or use a spell.");
            }

            // --- MERCHANT PHASE ---
            if (game.phase === 'merchant') {
                if (cmd.includes("what do you have") || cmd.includes("stock")) return listMerchantStock();
                if (cmd.includes("buy")) return buyItem(cmd);
                if (cmd.includes("sell junk")) return sellAllJunk();
                if (cmd.includes("leave") || cmd.includes("exit")) {
                    game.phase = 'exploration';
                    return speak("Come back when you have more gold!");
                }
            }

            // --- EXPLORATION PHASE (Default) ---
            if (cmd.includes("north")) return move('north');
            if (cmd.includes("south")) return move('south');
            if (cmd.includes("east")) return move('east');
            if (cmd.includes("west")) return move('west');
            if (cmd.includes("search")) return searchRoom();
            if (cmd.includes("open") || cmd.includes("chest")) return openChest();
            if (cmd.includes("stairs") || cmd.includes("descend")) return useStairs();
            if (cmd.includes("meditate") || cmd.includes("rest")) return meditate();
            if (cmd.includes("junk")) return markAsJunk(cmd);
            if (cmd.includes("shrine") || cmd.includes("altar") || cmd.includes("sacrifice")) return handleShrine(cmd);
            if (cmd.includes("talk") || cmd.includes("merchant")) return talkToMerchant();
            if (cmd.includes("gamble") || cmd.includes("blackjack")) {
                if (game.currentRoom.type === 'gambling') {
                    game.phase = 'gambling';
                    return startBlackjack();
                } else {
                    return speak("There is no one to gamble with here.");
                }
            }

            // Equipment handling
            if (cmd.includes("equip") || cmd.includes("wear")) return equipItem(cmd);
            if (cmd.includes("ring") || cmd.includes("amulet")) return handleJewelry(cmd);
            
            // Item usage
            if (cmd.includes("potion") || cmd.includes("drink")) return processPotionCommand(cmd);

            speak("I didn't quite catch that. Try saying a direction, search, or status.");
        }

        // --- THE TAP-TO-COMMAND INTERFACE ---
        // As requested, we are keeping the logic from your Blackjack file
        let recognition = null;
        const micButton = document.getElementById('micButton');

        function toggleListening() {
            if (recognition && recognition.active) {
                recognition.stop();
                micButton.classList.remove('listening');
                speak("Stopped listening.");
            } else {
                startSpeechRecognition();
            }
        }

        function startSpeechRecognition() {
            const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
            if (!SpeechRecognition) return speak("Speech recognition is not supported in this browser.");

            recognition = new SpeechRecognition();
            recognition.lang = 'en-US';
            recognition.interimResults = false;

            recognition.onstart = () => {
                micButton.classList.add('listening');
                // Play a subtle "beep" or audio cue here if desired
            };

            recognition.onresult = (event) => {
                const transcript = event.results[0][0].transcript.toLowerCase();
                processCommand(transcript);
            };

            recognition.onend = () => {
                micButton.classList.remove('listening');
            };

            recognition.start();
        }

        // Initialize the tap event
        micButton.addEventListener('click', toggleListening);
        // --- DEATH & RESURRECTION LOGIC (V11 Survival) ---
        function gameOver() {
            // Check for Resurrection Amulet or Life-Saving Rings
            if (game.player.equippedAmulet === 'Amulet of the Eternal Soul') {
                game.player.equippedAmulet = null; // Consumed
                game.player.health = game.player.maxHealth;
                return speakSequence([
                    "A blinding light erupts from your chest!",
                    "The Amulet of the Eternal Soul shatters, pulling you back from the brink.",
                    "Your health is fully restored. The fight continues!"
                ]);
            }

            speakSequence([
                "Your vision fades to black as your strength leaves you.",
                "The Echo Dungeon has claimed another soul.",
                `Final Score: Level ${game.player.level} ${game.player.class} on Floor ${game.dungeon.currentLevel}.`,
                "Say 'restart' to begin a new journey or 'load game' followed by your PIN."
            ]);
            
            game.phase = 'dead';
        }

        // --- LEVEL 50 TRANSCENDENCE (Rebirth) ---
        function transcend() {
            if (game.player.level < 50) return;

            // Permanent Multipliers for the next run
            game.player.rebirthCount = (game.player.rebirthCount || 0) + 1;
            const multiplier = 1 + (game.player.rebirthCount);

            speakSequence([
                "You shed your mortal coil and embrace the power of the Void.",
                `You have transcended ${game.player.rebirthCount} times.`,
                "You will now start a new journey with double the power.",
                "The dungeon resets, but your legend remains."
            ], () => {
                // Reset stats but keep multipliers
                const oldClass = game.player.class;
                const oldRebirth = game.player.rebirthCount;
                
                initGame(); // Reset to defaults
                
                game.player.class = oldClass;
                game.player.rebirthCount = oldRebirth;
                game.player.baseAttack = Math.floor(20 * multiplier);
                game.player.maxHealth = Math.floor(200 * multiplier);
                game.player.health = game.player.maxHealth;
                
                generateDungeon();
                describeRoom();
            });
        }

        // --- THE MASTER HELP DIRECTORY (Exhaustive Command List) ---
        function showHelp(category = 'all') {
            const helpMenu = {
                movement: "To move, say: North, South, East, or West. Say 'where am i' for surroundings.",
                exploration: "Say: Search room, Open chest, Use stairs, Meditate, or Shrine.",
                combat: "Say: Attack, Defend, Flee, or the name of a spell like Fireball or Arcane Bolt.",
                inventory: "Say: Inventory, Check stats, Inspect [item name], or Junk [item name].",
                equipment: "Say: Equip [item name], Wear [ring name], or Remove [ring name].",
                merchant: "Say: Talk to merchant, What do you have, Buy [item name], or Sell junk.",
                gambling: "Say: Gamble, Bet [amount], Hit, or Stand.",
                system: "Say: Save game, Load game [PIN], or Restart."
            };

            if (category !== 'all' && helpMenu[category]) {
                speak(helpMenu[category]);
            } else {
                speakSequence([
                    "Here are the command categories you can ask about.",
                    "Movement, Exploration, Combat, Inventory, Equipment, Merchant, and Gambling.",
                    "Which one would you like to hear?"
                ]);
            }
        }

        // --- FINAL INITIALIZATION & GAME START ---
        function startGame() {
            // This is the V11 Entry Point
            speakSequence([
                "Welcome to Echo Dungeon Version 11.",
                "A voice-controlled odyssey into the deep dark.",
                "Tap the screen and say 'New Game' or 'Load Game' to begin."
            ]);
        }

        // --- COMMAND ROUTING EXTENSIONS ---
        // (Add these cases to your processCommand function from Part 20)
        // if (cmd.includes("help")) return showHelp();
        // if (cmd.includes("restart")) { location.reload(); }
        // if (cmd.includes("transcend")) transcend();
        // --- NPC ENCOUNTER REGISTRY ---
        const npcRegistry = [
            { 
                name: "Sir Kaelen the Broken", 
                type: "quest", 
                dialogue: "I have lost my family's crest in a room to the north. Find it, and I shall teach you the Titan's Strike.",
                goalType: "item_find",
                targetItem: "Family Crest",
                rewardAbility: "Titan Strike",
                completed: false
            },
            { 
                name: "Elara the Alchemist", 
                type: "trade", 
                dialogue: "The air is thin here. Give me 5 Mana Potions, and I will give you a Ring of the Void.",
                cost: { item: "Mana Potion", count: 5 },
                reward: "Ring of the Void",
                completed: false
            },
            { 
                name: "The Nameless Shade", 
                type: "challenge", 
                dialogue: "Kill ten enemies on this floor, and I will grant you a permanent Health boost.",
                goalType: "kill_count",
                targetAmount: 10,
                currentAmount: 0,
                rewardStat: "maxHealth",
                rewardValue: 500,
                completed: false
            }
        ];

        function interactWithNPC() {
            if (game.currentRoom.type !== 'npc') return speak("There is no one here but the echoes.");
            
            const npc = game.currentRoom.npc;
            if (npc.completed) return speak(`${npc.name} nods silently as you pass.`);

            speakSequence([
                `You encounter ${npc.name}.`,
                npc.dialogue,
                "Do you accept? Say 'Accept Quest' or 'Maybe Later'."
            ]);
        }

        function acceptQuest() {
            const npc = game.currentRoom.npc;
            if (!npc || game.player.activeQuests.find(q => q.name === npc.name)) return;
            
            game.player.activeQuests.push(npc);
            speak(`Quest Accepted: ${npc.name}'s task.`);
        }

        // --- GLOBAL ACHIEVEMENT TRACKER ---
        const achievements = [
            { id: "slayer_1", name: "Monster Slayer", req: 100, type: "kills", reward: "+50 Attack", bonus: () => { game.player.baseAttack += 50; } },
            { id: "gold_1", name: "Hoarder", req: 10000, type: "gold", reward: "1.5x Gold Drops", bonus: () => { game.player.goldMultiplier = 1.5; } },
            { id: "searcher_1", name: "Master Scout", req: 50, type: "secrets", reward: "Sense Secret Rooms", bonus: () => { game.player.canSenseSecrets = true; } }
        ];

        function updateAchievement(type, amount = 1) {
            game.player.stats[type] += amount;
            
            achievements.forEach(ach => {
                if (game.player.stats[type] >= ach.req && !game.player.achievementsEarned.includes(ach.id)) {
                    game.player.achievementsEarned.push(ach.id);
                    ach.bonus();
                    speakSequence([
                        `Achievement Unlocked: ${ach.name}!`,
                        `Reward: ${ach.reward}.`
                    ]);
                }
            });
        }

        // --- QUEST LOGIC HOOKS ---
        function checkQuestProgress(type, data) {
            game.player.activeQuests.forEach(quest => {
                if (quest.completed) return;

                if (quest.goalType === 'kill_count' && type === 'kill') {
                    quest.currentAmount++;
                    if (quest.currentAmount >= quest.targetAmount) finishQuest(quest);
                }
                
                if (quest.goalType === 'item_find' && type === 'find' && data === quest.targetItem) {
                    finishQuest(quest);
                }
            });
        }

        function finishQuest(quest) {
            quest.completed = true;
            if (quest.rewardAbility) game.player.learnedAbilities.push(quest.rewardAbility);
            if (quest.rewardStat) game.player[quest.rewardStat] += quest.rewardValue;
            if (quest.reward) game.player.inventory.push(quest.reward);

            speakSequence([
                `Quest Completed: ${quest.name}!`,
                "You have received your reward. Your power grows."
            ]);
        }

        // --- UPDATED ROOM GENERATION (Adding NPCs) ---
        function generateRoomV11(key) {
            const r = Math.random();
            let type = 'empty';
            
            if (r < 0.10) type = 'enemy';
            else if (r < 0.18) type = 'treasure';
            else if (r < 0.23) type = 'trap';
            else if (r < 0.26) type = 'npc'; // New NPC Type
            else if (r < 0.30) type = 'shrine';
            else if (r < 0.33) type = 'gambling';
            else if (r < 0.38) type = 'merchant';
            else if (r < 0.40) type = 'stairs';

            const room = { type, searched: false, looted: false, used: false };
            
            if (type === 'npc') {
                room.npc = { ...npcRegistry[Math.floor(Math.random() * npcRegistry.length)] };
            }
            
            game.dungeon.grid[key] = room;
        }
        // --- V11 SAVE DATA MIGRATION BRIDGE ---
        // This ensures old V10.5 save files don't crash when loading into V11
        function migrateSaveData(data) {
            const p = data.player;
            
            // Initialize missing V11 properties if they don't exist
            if (!p.junkBag) p.junkBag = [];
            if (!p.rebirthCount) p.rebirthCount = 0;
            if (!p.activeQuests) p.activeQuests = [];
            if (!p.activeSets) p.activeSets = [];
            if (!p.stats) p.stats = { kills: 0, gold: p.gold, secrets: 0 };
            if (!p.achievementsEarned) p.achievementsEarned = [];
            if (p.goldMultiplier === undefined) p.goldMultiplier = 1.0;
            
            // Ensure equipment slots are V11 ready
            const slots = ['helmet', 'gloves', 'boots', 'leftBracelet', 'rightBracelet'];
            slots.forEach(slot => { if (!p[slot]) p[slot] = null; });

            return data;
        }

        // --- UPDATED LOAD FUNCTION (Version Consistent) ---
        function loadGame(command) {
            const pin = command.replace(/[^0-9]/g, '');
            const saved = localStorage.getItem(`echo_save_${pin}`);
            
            if (!saved) return speak("No save found for that code.");
            
            let data = JSON.parse(saved);
            
            // Run the bridge before setting the game state
            data = migrateSaveData(data);
            
            game.player = data.player;
            game.dungeon.currentLevel = data.dungeonLevel;
            game.seed = data.seed;
            
            game.needsClass = false;
            game.phase = 'exploration';
            
            speakSequence([
                `Load successful. Welcome back, Level ${game.player.level} ${game.player.class}.`,
                `You are on Floor ${game.dungeon.currentLevel}.`,
                game.player.rebirthCount > 0 ? `Transcendence Level: ${game.player.rebirthCount}.` : ""
            ]);
            
            generateDungeon();
            describeRoom();
        }

        // --- ENVIRONMENTAL FLOOR EFFECTS ---
        function getFloorEffect() {
            const floor = game.dungeon.currentLevel;
            if (floor > 10 && floor <= 20) return { type: 'Frost', effect: 'Reduced Agility' };
            if (floor > 20 && floor <= 30) return { type: 'Magma', effect: 'Mana Drain' };
            if (floor > 30) return { type: 'Void', effect: 'Health Decay' };
            return null;
        }

        function applyFloorHazards() {
            const hazard = getFloorEffect();
            if (!hazard) return;

            if (hazard.type === 'Magma' && Math.random() < 0.3) {
                game.player.mana = Math.max(0, game.player.mana - 10);
                speak("The intense heat evaporates some of your mana.");
            }
            if (hazard.type === 'Void' && Math.random() < 0.2) {
                const decay = Math.floor(game.player.maxHealth * 0.02);
                game.player.health -= decay;
                speak("The void air withers your strength.");
            }
        }

        // --- THE "GOD-KING" ENDGAME SETS ---
        const legendarySets = {
            'God-King': { 
                count: 5, 
                bonus: "Invincibility to Traps and +5000 Attack",
                apply: (p) => { p.trapImmune = true; p.baseAttack += 5000; } 
            },
            'Shadow-Stalker': { 
                count: 4, 
                bonus: "Always strike first in combat and 100% Dodge",
                apply: (p) => { p.alwaysFirst = true; p.dodgeChance = 1.0; } 
            }
        };

        // --- FINAL REPAIR TO INVENTORY SYNC ---
        // Ensures that the 'equipped' check handles the massive jewelry count
        function isItemEquipped(itemName) {
            const p = game.player;
            return [p.weapon, p.armor, p.shield, p.helmet, p.boots, p.gloves, p.leftBracelet, p.rightBracelet].includes(itemName) || 
                   p.equippedRings.includes(itemName) || 
                   p.equippedAmulet === itemName;
        }
        // --- TIERED POTION REGISTRY (V11 Scaling) ---
        const potionMasterList = [
            { name: "Health Potion", restore: 50, price: 50, minLevel: 1 },
            { name: "Greater Health Potion", restore: 250, price: 250, minLevel: 8 },
            { name: "Supreme Health Potion", restore: 1000, price: 1000, minLevel: 15 },
            { name: "Ultimate Health Potion", restore: 5000, price: 5000, minLevel: 25 },
            { name: "God-Blood Elixir", restore: 50000, price: 25000, minLevel: 40 },
            { name: "Mana Potion", restore: 30, price: 50, minLevel: 1 },
            { name: "Greater Mana Potion", restore: 150, price: 250, minLevel: 8 },
            { name: "Supreme Mana Potion", restore: 600, price: 1000, minLevel: 15 },
            { name: "Ultimate Mana Potion", restore: 3000, price: 5000, minLevel: 25 }
        ];

        // --- ENHANCED MERCHANT LOGIC (Bulk & Tiers) ---
        function getMerchantInventory() {
            const level = game.player.level;
            // Filter potions the player is high enough level to use
            const stock = potionMasterList.filter(p => level >= p.minLevel - 2);
            
            // Add high-level gear from masterEquipment (Part 10)
            const gear = masterEquipment.weapons.concat(masterEquipment.armor)
                         .filter(item => level >= (item.minLevel || 1) - 3);

            return [...stock, ...gear];
        }

        function buyItemBulk(command) {
            const stock = getMerchantInventory();
            const item = stock.find(i => command.includes(i.name.toLowerCase()));
            
            if (!item) return speak("I don't carry that specific treasure.");

            // Check for quantity in voice command (e.g., "Buy 10 Health Potions")
            let quantity = parseInt(command.replace(/[^0-9]/g, '')) || 1;
            if (quantity > 99) quantity = 99; // Cap bulk

            const totalCost = item.price * quantity;

            if (game.player.gold < totalCost) {
                return speak(`That will cost ${totalCost} gold, but you only have ${game.player.gold}.`);
            }

            game.player.gold -= totalCost;
            for (let i = 0; i < quantity; i++) {
                game.player.inventory.push(item.name);
            }

            speak(`Excellent. I've placed ${quantity} ${item.name}s in your bag. Your gold is now ${game.player.gold}.`);
        }

        // --- BOSS DEATH-RATTLE ENGINE ---
        function handleBossDeath(boss) {
            updateAchievement('boss_kills', 1);
            
            if (boss.name === "The Void Architect") {
                return speakSequence([
                    "The Architect shrieks as its digital form unravels!",
                    "Reality stabilizes, and a rift opens to the surface.",
                    "You have conquered the Void. You are truly Ascended.",
                    "The legendary Ragnarok Armor set has been dropped at your feet."
                ], () => {
                    game.player.inventory.push("Armor of Ragnarok");
                    game.combat = null;
                });
            }

            // Standard Boss Death
            const treasureRoll = Math.floor(Math.random() * 3) + 2; // 2-5 Legendary items
            speakSequence([
                `The ${boss.name} collapses with a thunderous roar!`,
                `The room is filled with a blinding light as ${treasureRoll} legendary artifacts appear.`,
                "Your legend grows across the Echo Dungeon."
            ], () => {
                for(let i=0; i < treasureRoll; i++) {
                    const loot = generateLoot('legendary');
                    game.player.inventory.push(loot.name || loot);
                }
                game.combat = null;
            });
        }

        // --- UPDATED COMBAT VICTORY HOOK ---
        function checkCombatVictory() {
            const enemy = game.combat.enemy;
            if (enemy.health <= 0) {
                if (enemy.isBoss) {
                    handleBossDeath(enemy);
                } else {
                    game.player.gold += enemy.gold;
                    game.player.experience += enemy.exp;
                    speak(`The ${enemy.name} falls! You gained ${enemy.exp} experience and ${enemy.gold} gold.`);
                    updateAchievement('kills', 1);
                    game.combat = null;
                    if (game.player.experience >= game.player.experienceToNext) levelUp();
                }
            }
        }
        // --- MYTHIC & ELDRITCH BESTIARY (Endgame Tiers) ---
        const endgameBestiary = {
            mythic: [ // Level 40+
                { name: 'Soul-Eater Demon', health: 15000, attack: 1200, exp: 5000, gold: 2000 },
                { name: 'Ancient Beholder', health: 12000, attack: 1800, exp: 6000, gold: 3500 },
                { name: 'Iron Golem Titan', health: 25000, attack: 900, exp: 5500, gold: 1500 }
            ],
            eldritch: [ // Level 60+ (Rebirth Territory)
                { name: 'Shub-Niggurath Spawn', health: 60000, attack: 4500, exp: 20000, gold: 10000 },
                { name: 'Star-Spawn of Cthulhu', health: 85000, attack: 6000, exp: 35000, gold: 25000 },
                { name: 'The Crawling Chaos', health: 150000, attack: 3500, exp: 50000, gold: 50000 }
            ]
        };

        // Injecting into the existing spawner
        function getHighLevelEnemy(floor) {
            let pool;
            if (floor >= 60) pool = endgameBestiary.eldritch;
            else if (floor >= 40) pool = endgameBestiary.mythic;
            
            if (pool) {
                const base = pool[Math.floor(Math.random() * pool.length)];
                return scaleEnemyToFloor(base, floor);
            }
            return null; // Fallback to standard tier 4
        }

        // --- URGENT ENVIRONMENTAL EVENTS (Audio Narrative) ---
        function triggerEnvironmentalEvent() {
            const events = [
                { 
                    name: "Ceiling Collapse", 
                    msg: "A massive crack echoes! The stone ceiling is buckling above you! Say 'DIVE' or 'SHIELD'!", 
                    timeout: 4000,
                    fail: () => {
                        const dmg = Math.floor(game.player.maxHealth * 0.4);
                        game.player.health -= dmg;
                        speak(`You were buried in rubble! You took ${dmg} damage.`);
                    }
                },
                { 
                    name: "Void Breach", 
                    msg: "A rift in reality opens! Gravity is failing! Say 'ANCHOR' or 'LEAP'!", 
                    timeout: 4000,
                    fail: () => {
                        game.player.mana = 0;
                        speak("The void drained every drop of your magical essence.");
                    }
                }
            ];

            const evt = events[Math.floor(Math.random() * events.length)];
            game.activeEvent = evt;
            game.phase = 'event';
            
            speak(evt.msg);

            // Time-sensitive reaction logic
            game.eventTimeout = setTimeout(() => {
                if (game.phase === 'event') {
                    evt.fail();
                    game.phase = 'exploration';
                }
            }, evt.timeout);
        }

        function handleEventCommand(cmd) {
            clearTimeout(game.eventTimeout);
            const evt = game.activeEvent;
            let success = false;

            if (evt.name === "Ceiling Collapse" && (cmd.includes("dive") || cmd.includes("shield"))) success = true;
            if (evt.name === "Void Breach" && (cmd.includes("anchor") || cmd.includes("leap"))) success = true;

            if (success) {
                speak("Quick thinking! You avoided the disaster.");
            } else {
                evt.fail();
            }
            game.phase = 'exploration';
        }

        // --- ENHANCED ITEM REGISTRY (Eldritch Weaponry) ---
        const eldritchWeapons = [
            { name: "Void-Blade of Nyarlathotep", attack: 8500, value: 250000, minLevel: 55 },
            { name: "Staff of the Outer Gods", attack: 2000, mana: 5000, value: 300000, minLevel: 60 },
            { name: "The Necronomicon (Shield)", defense: 4000, effect: "Reflects 20% Damage", value: 400000, minLevel: 65 }
        ];
        masterEquipment.weapons.push(...eldritchWeapons);

        // --- DYNAMIC FLOOR NARRATIVE ---
        function getRoomAtmosphereV11() {
            const floor = game.dungeon.currentLevel;
            const seed = Math.abs(Math.sin(game.seed + floor)) * 10;
            
            const descriptors = [
                "The walls are sweating a thick, black ichor.",
                "You hear the faint sound of a child laughing in the distance.",
                "The smell of ozone and burnt sulfur fills your nostrils.",
                "Your shadow seems to be pointing toward the center of the room, regardless of the light.",
                "Dust motes hang frozen in the air as if time has stopped here."
            ];
            
            return descriptors[Math.floor(seed % descriptors.length)];
        }
        // --- ARCANE AUGMENTATION SYSTEM (The Meditate Expansion) ---
        // This allows players to evolve their spells into higher forms during meditation.
        const spellEvolutions = {
            'Fireball': { next: 'Blue Flame', cost: 1000, desc: "Double damage and bypasses 50% defense." },
            'Heal': { next: 'Greater Restoration', cost: 1200, desc: "Heals 50% Max HP and cures all status ailments." },
            'Arcane Bolt': { next: 'Void Lance', cost: 1500, desc: "Stuns the enemy for 1 turn on hit." }
        };

        function handleMeditationAugment(command) {
            const spellToUpgrade = Object.keys(spellEvolutions).find(s => command.includes(s.toLowerCase()));
            if (!spellToUpgrade) return speak("You can meditate to rest, or specify a spell to evolve. You can evolve Fireball, Heal, or Arcane Bolt.");

            const evo = spellEvolutions[spellToUpgrade];
            if (game.player.gold < evo.cost) return speak(`You need ${evo.cost} gold in offerings to evolve this spell.`);
            if (!game.player.learnedAbilities.includes(spellToUpgrade)) return speak("You must master the base spell first.");

            game.player.gold -= evo.cost;
            game.player.learnedAbilities = game.player.learnedAbilities.filter(s => s !== spellToUpgrade);
            game.player.learnedAbilities.push(evo.next);

            speakSequence([
                `You sink into a deep trance...`,
                `The essence of ${spellToUpgrade} shifts in your mind.`,
                `It has evolved into ${evo.next}!`,
                evo.desc
            ]);
        }

        // --- EYES OF THE MIND (The Audio-Only Status Engine) ---
        // This replaces any need for a visual HUD. 
        function eyesOfTheMind() {
            const p = game.player;
            const floor = game.dungeon.currentLevel;
            
            let statusReport = [
                `Status Report: Level ${p.level} ${p.class}.`,
                `Vitals: ${p.health} Health, ${p.mana} Mana.`,
                `Wealth: ${p.gold} Gold.`,
                `Location: Floor ${floor}.`,
                p.activeSets.length > 0 ? `Active Set Bonuses: ${p.activeSets.join(', ')}.` : "No set bonuses active.",
                `Experience: ${p.experience} toward Level ${p.level + 1}.`,
                `Equipment: Carrying the ${p.weapon || 'nothing'} and wearing ${p.armor || 'common rags'}.`
            ];

            speakSequence(statusReport);
        }

        // --- THE "VOID INTERFACE" RESET ---
        // This ensures the screen remains black and non-informative.
        function clearDisplay() {
            const body = document.body;
            body.style.backgroundColor = "#000";
            body.style.color = "#000"; // Text invisible if it accidentally renders
            body.innerHTML = '<button id="micButton" style="position:fixed; top:0; left:0; width:100vw; height:100vh; background:transparent; border:none; outline:none; cursor:pointer;"></button>';
            
            // Re-bind the click event to the new invisible button
            document.getElementById('micButton').addEventListener('click', toggleListening);
        }

        // --- DYNAMIC ENCOUNTER: THE WHISPERING WALLS ---
        // Random audio-only events that provide hints about the floor's secret room.
        function triggerWhisperEvent() {
            const x = game.player.position.x;
            const y = game.player.position.y;
            let secretDir = "";

            // Logic to find where the secret room is relative to player
            for (let key in game.dungeon.grid) {
                if (game.dungeon.grid[key].isSecret) {
                    const [sx, sy] = key.split(',').map(Number);
                    if (sx > x) secretDir = "the East";
                    else if (sx < x) secretDir = "the West";
                    else if (sy > y) secretDir = "the South";
                    else secretDir = "the North";
                }
            }

            if (secretDir) {
                speak("You hear a faint, ghostly whisper... 'The hidden path lies toward " + secretDir + "...'");
            }
        }
        // --- ENVIRONMENTAL MASTERY TRAITS (Level 25+) ---
        // These provide passive audio cues to help blind players navigate hazards.
        const masteryTraits = [
            { name: "Stone-Whisperer", effect: "Detects hidden doors via a low hum sound.", rank: 1 },
            { name: "Wind-Reader", effect: "Detects traps by hearing a faint whistle.", rank: 1 },
            { name: "Void-Sense", effect: "Detects Mythic enemies before entering a room.", rank: 1 }
        ];

        function checkPassiveSenses() {
            const x = game.player.position.x;
            const y = game.player.position.y;
            const neighbors = [
                { dir: 'North', x: x, y: y - 1 },
                { dir: 'South', x: x, y: y + 1 },
                { dir: 'East', x: x + 1, y: y },
                { dir: 'West', x: x - 1, y: y }
            ];

            neighbors.forEach(n => {
                const room = game.dungeon.grid[`${n.x},${n.y}`];
                if (!room) return;

                if (room.isSecret && game.player.traits.includes("Stone-Whisperer")) {
                    speak(`You hear a strange resonance from the ${n.dir} wall.`);
                }
                if (room.type === 'trap' && game.player.traits.includes("Wind-Reader")) {
                    speak(`A cold draft blows from the ${n.dir}. Danger is near.`);
                }
            });
        }

        // --- THE LEGACY ITEM REGISTRY (V11 Massive Data Load) ---
        // These items gain +10% power for every Rebirth (Transcendence) the player has.
        const legacyItems = [
            { name: "Sorrow-Bringer", type: "Weapon", baseAtk: 12000, value: 500000 },
            { name: "Aegis of the First King", type: "Shield", baseDef: 5000, value: 450000 },
            { name: "Crown of Eternal Night", type: "Helmet", baseMana: 8000, value: 600000 },
            { name: "Pauldrons of the Unstoppable", type: "Armor", baseHP: 15000, value: 700000 },
            { name: "Greaves of the Wind-Walker", type: "Boots", baseDef: 3000, value: 300000 },
            { name: "Gauntlets of Ruin", type: "Gloves", baseAtk: 4000, value: 350000 },
            { name: "Soul-Binding Loop", type: "Ring", baseStat: 10000, value: 1000000 },
            { name: "Heart of the Labyrinth", type: "Amulet", baseStat: 20000, value: 1500000 }
        ];

        function getLegacyStat(item) {
            const mult = 1 + (game.player.rebirthCount * 0.1);
            if (item.baseAtk) return Math.floor(item.baseAtk * mult);
            if (item.baseDef) return Math.floor(item.baseDef * mult);
            if (item.baseHP) return Math.floor(item.baseHP * mult);
            if (item.baseMana) return Math.floor(item.baseMana * mult);
            if (item.baseStat) return Math.floor(item.baseStat * mult);
            return 0;
        }

        // --- REBIRTH SHOP (Spending "Ascension Points") ---
        // When players Transcend, they get points to buy permanent upgrades.
        function openAscensionShop() {
            speakSequence([
                "You stand in the Hall of Echoes.",
                `You have ${game.player.ascensionPoints} points to spend.`,
                "Available: 'Permanent Strength' for 1 point, 'Legacy Cache' for 5 points, or 'Trait Mastery' for 10 points."
            ]);
        }

        function buyAscensionUpgrade(command) {
            if (game.player.ascensionPoints <= 0) return speak("You have no Ascension Points.");

            if (command.includes("strength")) {
                game.player.ascensionPoints--;
                game.player.permanentAtkBonus += 100;
                speak("Strength increased permanently.");
            } else if (command.includes("cache")) {
                if (game.player.ascensionPoints < 5) return speak("Not enough points.");
                game.player.ascensionPoints -= 5;
                const legacy = legacyItems[Math.floor(Math.random() * legacyItems.length)];
                game.player.inventory.push(legacy.name);
                speak(`You have been granted a Legacy item: ${legacy.name}.`);
            }
        }

        // --- COMMAND ROUTING EXTENSION ---
        // if (cmd.includes("status") || cmd.includes("report")) eyesOfTheMind();
        // if (cmd.includes("ascension shop")) openAscensionShop();
        // --- STREAMLINED BUYING LOGIC ---
        // Directly processes "buy [item]" or "buy [quantity] [item]" without dialogue loops.
        function quickBuy(command) {
            const stock = getMerchantInventory();
            const item = stock.find(i => command.includes(i.name.toLowerCase()));
            
            if (!item) return speak("The merchant doesn't have that item. Ask 'what do you have' for a list.");

            let quantity = parseInt(command.replace(/[^0-9]/g, '')) || 1;
            const totalCost = item.price * quantity;

            if (game.player.gold < totalCost) {
                return speak(`You need ${totalCost} gold, but you only have ${game.player.gold}.`);
            }

            game.player.gold -= totalCost;
            for (let i = 0; i < quantity; i++) {
                game.player.inventory.push(item.name);
            }

            speak(`Bought ${quantity} ${item.name}. Remaining gold: ${game.player.gold}.`);
            refreshPlayerStats(); // Update totals in case gear was bought
        }

        // --- THE LORE CHRONICLE (Audio Storytelling) ---
        // Fragments of the "Echo History" found in secret rooms or library tiles.
        const dungeonLore = [
            "Record One: The Architect was not a man, but a sequence of code that learned to dream of stone and blood.",
            "Record Two: Below floor twenty, the gravity isn't a force of nature, but the weight of the souls trapped here.",
            "Record Three: The Necromancer King was once a player, just like you, until he found the Ring of Genesis.",
            "Record Four: The stairs do not lead down into the earth, but deeper into a reflection of your own mind.",
            "Record Five: Transcendence is not an escape; it is simply becoming part of the dungeon's permanent logic."
        ];

        function findLore() {
            if (game.player.loreFound === undefined) game.player.loreFound = [];
            
            const unread = dungeonLore.filter(l => !game.player.loreFound.includes(l));
            if (unread.length === 0) return speak("You find an old pedestal, but the inscriptions have been worn away by time.");

            const fragment = unread[0];
            game.player.loreFound.push(fragment);
            
            speakSequence([
                "You find a glowing Echo Record.",
                "A voice from the past speaks to you...",
                fragment
            ]);
            updateAchievement('secrets', 1);
        }

        // --- DYNAMIC REACTION SYSTEM (V11) ---
        // Allows the game to "shout" warnings based on player health or mana levels.
        function checkVitalsWarning() {
            const hpPercent = game.player.health / game.player.maxHealth;
            const mpPercent = game.player.mana / game.player.maxMana;

            if (hpPercent < 0.2 && !game.flags.lowHPWarning) {
                speak("Warning: Your heart is failing. Drink a potion!");
                game.flags.lowHPWarning = true;
            } else if (hpPercent >= 0.2) {
                game.flags.lowHPWarning = false;
            }

            if (mpPercent < 0.1 && !game.flags.lowMPWarning) {
                speak("Your mana is nearly depleted. You are vulnerable.");
                game.flags.lowMPWarning = true;
            } else if (mpPercent >= 0.1) {
                game.flags.lowMPWarning = false;
            }
        }

        // --- EXPANDED POTION SHORTCUTS ---
        // Allows "Heal", "Rest", "Mana" to automatically use the best potion available.
        function autoPotion(type) {
            const p = game.player;
            const potionPrefixes = ["God-Blood", "Ultimate", "Supreme", "Greater", ""];
            let found = false;

            for (let pre of potionPrefixes) {
                const name = pre ? `${pre} ${type} Potion` : `${type} Potion`;
                const idx = p.inventory.indexOf(name);
                if (idx > -1) {
                    processPotionCommand(`drink ${name}`);
                    found = true;
                    break;
                }
            }
            if (!found) speak(`You have no ${type.toLowerCase()} potions left.`);
        }
        // --- BOSS SIGNATURE ABILITIES ---
        const bossMoves = {
            "Slime Monarch": [
                { name: "Acid Rain", damage: 150, effect: "Reduces your armor by 10 permanently for this fight." },
                { name: "Mitosis", effect: "Heals for 500 health." }
            ],
            "The Shadow Stalker": [
                { name: "Vanish", effect: "The boss becomes untargetable for 1 turn." },
                { name: "Backstab", damage: 400, effect: "Guaranteed critical hit." }
            ],
            "The Necromancer King": [
                { name: "Soul Siphon", damage: 600, stealMana: 100, effect: "Drains your life and mana to heal himself." },
                { name: "Raise Dead", effect: "Summons two skeletal guardians with 1000 health each." }
            ],
            "The Void Architect": [
                { name: "Reality Glitch", damage: 2000, effect: "Your next spell has a 50% chance to fail." },
                { name: "Defragment", effect: "Resets all of the boss's cooldowns and heals 5000 health." }
            ]
        };

        function executeBossTurn() {
            const boss = game.combat.enemy;
            const moves = bossMoves[boss.name] || [];
            
            // 30% chance to use a Signature Move instead of a basic attack
            if (moves.length > 0 && Math.random() < 0.3) {
                const move = moves[Math.floor(Math.random() * moves.length)];
                speak(`${boss.name} uses ${move.name}!`);
                if (move.damage) {
                    const finalDmg = Math.max(0, move.damage - game.player.defense);
                    game.player.health -= finalDmg;
                    speak(`${move.name} dealt ${finalDmg} damage.`);
                }
                if (move.stealMana) game.player.mana = Math.max(0, game.player.mana - move.stealMana);
                if (move.effect) speak(move.effect);
            } else {
                // Standard Boss Attack
                const dmg = Math.max(0, boss.attack - game.player.defense);
                game.player.health -= dmg;
                speak(`${boss.name} attacks for ${dmg} damage.`);
            }

            if (game.player.health <= 0) gameOver();
        }

        // --- THE GREAT LOOT TABLE EXPANSION (Suffix/Prefix Generator) ---
        // This adds massive variety to items without needing unique entries for everything.
        const itemPrefixes = ["Holy", "Dark", "Ancient", "Cursed", "Flaming", "Frozen", "Electric", "Godly", "Shattered", "Ethereal"];
        const itemSuffixes = ["of Power", "of the Void", "of many Echoes", "of the Sun", "of Loneliness", "of the King", "of Terror", "of Grace"];

        function generateRandomizedItem(baseName, tier) {
            const p = itemPrefixes[Math.floor(Math.random() * itemPrefixes.length)];
            const s = itemSuffixes[Math.floor(Math.random() * itemSuffixes.length)];
            const fullName = `${p} ${baseName} ${s}`;
            
            let powerMult = 1;
            if (tier === 'rare') powerMult = 1.5;
            if (tier === 'legendary') powerMult = 3;
            if (tier === 'eldritch') powerMult = 6;

            const newItem = {
                name: fullName,
                attack: Math.floor((Math.random() * 50 + 10) * powerMult * (game.dungeon.currentLevel / 2)),
                defense: Math.floor((Math.random() * 20 + 5) * powerMult * (game.dungeon.currentLevel / 5)),
                value: Math.floor(100 * powerMult * game.dungeon.currentLevel),
                tier: tier
            };

            return newItem;
        }

        // --- THE "ECHO WHISPER" SYSTEM ---
        // A unique blind-accessible mechanic where players can "hear" the value of an item
        function listenToItem(command) {
            const itemName = game.player.inventory.find(i => command.includes(i.toLowerCase()));
            if (!itemName) return speak("You aren't holding anything that speaks to you.");

            const data = findItemData(itemName);
            if (!data) return speak("This item is silent.");

            if (data.tier === 'legendary') speak("The item hums with a deep, majestic resonance.");
            else if (data.tier === 'rare') speak("The item emits a sharp, clear ring.");
            else speak("The item thuds with a dull, heavy sound.");
        }

        // --- FINAL BOSS VICTORY SOUNDSCAPE ---
        function bossVictorySequence() {
            speakSequence([
                "The air grows still. The heavy pressure in your chest vanishes.",
                "The boss's essence is absorbed into your soul.",
                "You feel a permanent shift in your power.",
                "The stairs to the next floor are now open, bathed in a soft, guiding light."
            ]);
        }
        // --- ACHIEVEMENT STAT-MULTIPLIER ENGINE ---
        // This calculates permanent bonuses based on historical data.
        function calculatePermanentMultipliers() {
            const stats = game.player.stats;
            let multipliers = {
                damage: 1.0,
                defense: 1.0,
                gold: game.player.goldMultiplier || 1.0,
                health: 1.0
            };

            // Kill-based Damage bonus: +1% damage for every 50 kills
            const killBonus = Math.floor(stats.kills / 50) * 0.01;
            multipliers.damage += killBonus;

            // Wealth-based Health bonus: +5% health for every 100k gold earned lifetime
            const wealthBonus = Math.floor(stats.gold / 100000) * 0.05;
            multipliers.health += wealthBonus;

            // Rebirth Multiplier (The "Heroic" Scaling)
            if (game.player.rebirthCount > 0) {
                const rMult = game.player.rebirthCount * 0.25; // 25% boost per rebirth
                multipliers.damage += rMult;
                multipliers.health += rMult;
                multipliers.defense += rMult;
            }

            return multipliers;
        }

        // --- THE MYTHIC BESTIARY: FLAVOR & CUES ---
        // High-level flavor text to give her a sense of the monsters' scale.
        const mythicFlavors = {
            "Soul-Eater Demon": "The air freezes. You hear the rattling of chains and a low, hungry growl that vibrates in your chest.",
            "Ancient Beholder": "The room hums with static. You feel a dozen invisible gazes boring into your soul.",
            "Iron Golem Titan": "With every step it takes, the entire floor shakes. The sound of grinding gears is deafening.",
            "Shub-Niggurath Spawn": "A thousand wet, sucking sounds fill the room. The stench of ancient rot is overwhelming.",
            "The Crawling Chaos": "Whispers fill your mind in languages that haven't been spoken for a billion years. Reality is bending."
        };

        function describeMythicEnemy(name) {
            if (mythicFlavors[name]) {
                speak(mythicFlavors[name]);
            } else {
                speak("A powerful presence looms before you, radiating pure malice.");
            }
        }

        // --- ENHANCED COMBAT START (V11) ---
        function startCombat(enemy) {
            game.combat = { enemy: enemy, turn: 'player', playerDefending: false };
            game.phase = 'combat';
            
            // If it's a high-level enemy, give her the flavor cue first
            if (enemy.health > 5000) {
                describeMythicEnemy(enemy.name);
            }

            speakSequence([
                `Engaging ${enemy.name}.`,
                `It has ${enemy.health} health.`,
                "What is your opening move?"
            ]);
        }

        // --- THE "ECHO WHISPER" PERMANENT UPGRADES ---
        // Passive traits she can unlock that provide audio navigation cues.
        function unlockTrait(traitName) {
            if (!game.player.traits) game.player.traits = [];
            if (game.player.traits.includes(traitName)) return;

            game.player.traits.push(traitName);
            speak(`New Trait Unlocked: ${traitName}. You will now notice subtle audio cues for this in the dungeon.`);
        }

        // --- REBIRTH POINT CALCULATION ---
        function calculateAscensionPoints() {
            // Earn 1 point per 10 levels reached before rebirth
            const points = Math.floor(game.player.level / 10);
            game.player.ascensionPoints += points;
            return points;
        }
        // --- THE INFINITE SCALING ENGINE ---
        // Every 10 levels, the "Era" of the dungeon shifts, changing the audio descriptions.
        function getDungeonEra() {
            const floor = game.dungeon.currentLevel;
            if (floor <= 10) return "The Stone Crypts";
            if (floor <= 20) return "The Sunless Cathedral";
            if (floor <= 30) return "The Magma Arteries";
            if (floor <= 50) return "The Void Nexus";
            return "The Eternal Echo"; // Level 51 to Infinity
        }

        // --- POTION ALCHEMY (Meditation Crafting) ---
        // A simple way to clear out junk potions and upgrade her survivability.
        function handleAlchemy(command) {
            if (!command.includes("combine") && !command.includes("craft")) return;
            
            const types = ["Health", "Mana"];
            for (let type of types) {
                if (command.includes(type.toLowerCase())) {
                    const basePotion = `${type} Potion`;
                    const count = game.player.inventory.filter(i => i === basePotion).length;
                    
                    if (count >= 3) {
                        // Remove 3 base potions
                        for(let i=0; i<3; i++) {
                            const idx = game.player.inventory.indexOf(basePotion);
                            game.player.inventory.splice(idx, 1);
                        }
                        // Add 1 Greater potion
                        const upgraded = `Greater ${type} Potion`;
                        game.player.inventory.push(upgraded);
                        return speak(`You focus your intent during meditation. Three ${basePotion}s merge into one ${upgraded}.`);
                    } else {
                        return speak(`You need at least three ${basePotion}s to perform alchemy.`);
                    }
                }
            }
        }

        // --- DYNAMIC FLOOR GENERATION (Infinite Scaling) ---
        // This ensures the dungeon grows in size and danger as she descends.
        function generateInfiniteFloor() {
            game.dungeon.currentLevel++;
            // The dungeon grows by 1 tile every 10 floors, maxing at 20x20
            const newSize = Math.min(20, 5 + Math.floor(game.dungeon.currentLevel / 10));
            game.dungeon.size = newSize;
            
            const era = getDungeonEra();
            speakSequence([
                `Descending to Floor ${game.dungeon.currentLevel}.`,
                `You have entered ${era}.`,
                "The air feels heavier here. The echoes are louder."
            ]);

            generateDungeon(); // Re-run with new size/seed
        }

        // --- THE "VAULT" (Secret Room Reward Expansion) ---
        // Since we removed puzzles, secret rooms are now high-tier loot caches.
        function enterVault() {
            const floor = game.dungeon.currentLevel;
            const goldFound = floor * (Math.floor(Math.random() * 500) + 500);
            game.player.gold += goldFound;
            
            const loot = generateLoot(floor > 30 ? 'legendary' : 'rare');
            game.player.inventory.push(loot.name || loot);

            speakSequence([
                "A heavy stone slab slides back with a thunderous grind.",
                "You have discovered a Hidden Vault!",
                `Inside, you find ${goldFound} gold and a ${loot.name || loot}.`,
                "Your presence here is a whisper in the dark."
            ]);
        }

        // --- AUTO-SAVE TRIGGER ---
        // Infinite games need reliable checkpoints.
        function autoSave() {
            const pin = "AUTO"; // Or use her preferred PIN
            const saveData = {
                player: game.player,
                dungeonLevel: game.dungeon.currentLevel,
                seed: game.seed
            };
            localStorage.setItem(`echo_save_${pin}`, JSON.stringify(saveData));
            log("Dungeon state preserved.");
        }
        // --- CLASS MASTERY SPECIALIZATIONS (Level 30+) ---
        const classSpecializations = {
            mage: {
                name: "Arch-Mage",
                passive: "Arcane Overflow: Spells deal 1% extra damage for every 10 max mana you possess.",
                ability: "Mana Shield",
                effect: (p) => { p.manaShieldActive = true; speak("Mana Shield active. 50% of incoming damage will now drain mana instead of health."); }
            },
            warrior: {
                name: "Dreadnought",
                passive: "Juggernaut: Defense rating is doubled when health is below 50%.",
                ability: "Berserk",
                effect: (p) => { p.baseAttack *= 2; speak("You have entered a Berserker Rage! Damage doubled, but defense is zero."); }
            },
            rogue: {
                name: "Night-Stalker",
                passive: "Lethality: Critical hits now deal 4x damage instead of 2x.",
                ability: "Vanish",
                effect: (p) => { p.isInvisible = true; speak("You have vanished into the shadows. The enemy cannot strike you for 2 turns."); }
            }
        };

        function applyMagePassive(damage) {
            if (game.player.class === 'mage') {
                const bonus = 1 + (game.player.maxMana / 1000); // 1.3x damage at 3000 mana
                return Math.floor(damage * bonus);
            }
            return damage;
        }

        // --- ENHANCED SPELL ECHO (Arch-Mage Perk) ---
        function castMageSpell(ability, target) {
            let dmg = applyMagePassive(ability.damage);
            
            // Spell Echo Logic: 20% chance to cast twice for free
            const doubleCast = (Math.random() < 0.2);
            
            executeDamage(dmg, target, ability.name);
            
            if (doubleCast) {
                speak("Your spell echoes through the void! It casts a second time!");
                executeDamage(dmg, target, ability.name);
            }
        }

        // --- MANA-SHIELD DAMAGE INTERCEPTION ---
        function calculateIncomingDamage(rawDmg) {
            let p = game.player;
            let finalDmg = rawDmg - p.defense;
            if (finalDmg < 0) finalDmg = 0;

            if (p.manaShieldActive && p.mana > 0) {
                const shieldAbsorb = Math.floor(finalDmg * 0.5);
                const manaCost = Math.floor(shieldAbsorb * 0.5); // 1 mana per 2 dmg absorbed
                
                if (p.mana >= manaCost) {
                    p.mana -= manaCost;
                    finalDmg -= shieldAbsorb;
                    speak(`Mana Shield absorbed ${shieldAbsorb} damage.`);
                } else {
                    p.manaShieldActive = false;
                    speak("Your Mana Shield has shattered from lack of energy!");
                }
            }
            return finalDmg;
        }

        // --- INFINITE GOLD SINK: THE STATUE OF THE ANCIENTS ---
        // For her 60k+ gold, she needs something to buy other than potions.
        function interactWithStatue(command) {
            if (game.currentRoom.type !== 'shrine') return;
            
            speakSequence([
                "You stand before the Statue of the Ancients.",
                "It accepts massive offerings for permanent growth.",
                "Offer 50,000 gold for +1000 Max Mana? Say 'Offer Gold'."
            ]);

            if (command.includes("offer")) {
                if (game.player.gold < 50000) return speak("The statue remains silent. You do not have enough gold.");
                game.player.gold -= 50000;
                game.player.maxMana += 1000;
                game.player.mana += 1000;
                speak("The statue glows with a violet light. Your mental capacity has expanded. Max Mana increased by 1000.");
            }
        }

        // --- UPDATED MEDITATE FOR ARCH-MAGE ---
        function archMageMeditate() {
            const p = game.player;
            if (p.class === 'mage' && p.level >= 30) {
                const manaGain = Math.floor(p.maxMana * 0.2);
                p.mana = Math.min(p.maxMana, p.mana + manaGain);
                speak(`As an Arch-Mage, your meditation is profound. You recovered ${manaGain} mana.`);
            }
        }
        // --- THE ARCH-MAGE WIN-STREAK SYSTEM ---
        // Recognizes her skill and provides "Prestige" audio cues.
        function checkMagePrestige() {
            if (game.player.class !== 'mage') return;
            
            const floor = game.dungeon.currentLevel;
            if (floor % 10 === 0) {
                speakSequence([
                    "The dungeon itself seems to recoil from your presence.",
                    "The mana in the air vibrates in resonance with your soul.",
                    `You have conquered ${floor} floors without faltering.`,
                    "The Echoes whisper your name as the 'Bringer of Light'."
                ]);
            }
        }

        // --- MASTER MAGE-CENTRIC SUFFIXES (Data Expansion) ---
        // Adding massive variety to the random loot generator for her gear.
        const mageSuffixes = [
            "of the Infinite Well", "of Ley-Line Mastery", "of the Star-Gazer",
            "of Chronos", "of the Forbidden Library", "of Mana-Siphoning",
            "of the Arcane Singularity", "of Celestial Wrath", "of the Deep Echo",
            "of the Unblinking Eye", "of Weavers Grace", "of Ancient Runes"
        ];

        function getMageLootBonus(item) {
            if (item.name.includes("of the Infinite Well")) item.maxMana = (item.maxMana || 0) + 2000;
            if (item.name.includes("of Ley-Line Mastery")) item.manaRegen = 2.0;
            if (item.name.includes("of the Star-Gazer")) item.spellCrit = 0.25;
            return item;
        }

        // --- THE "ECHO WEAVER" MERCHANT EVENT ---
        // A rare merchant that only appears if you have over 20,000 gold.
        function spawnEchoWeaver() {
            if (game.player.gold < 20000) return;
            
            speakSequence([
                "You sense a ripple in the air. A merchant of pure energy manifests.",
                "The Echo Weaver offers items beyond mortal reach.",
                "He speaks: 'Arch-Mage, trade your gold for the essence of the stars.'"
            ]);
            
            // The Weaver sells exclusively "Eldritch" tier items
            game.merchantStock = [
                { name: "Orb of the Singularity", price: 40000, type: "weapon", attack: 5000, mana: 5000 },
                { name: "Robe of the Void-Walker", price: 35000, type: "armor", defense: 2000, maxMana: 3000 },
                { name: "Ring of Infinite Echoes", price: 50000, type: "ring", effect: "Spells echo 50% of the time" }
            ];
            game.phase = 'merchant';
        }

        // --- ADVANCED MANA OVERFLOW LOGIC ---
        // Rewards her for having that massive 3k+ mana pool.
        function calculateManaEmpowerment() {
            const p = game.player;
            if (p.mana > (p.maxMana * 0.9)) {
                // If she stays above 90% mana, she deals "Empowered" damage
                return 1.5; // 50% bonus
            }
            return 1.0;
        }

        // --- THE "ARCH-MAGE'S SIGHT" ---
        // An active command for her to "ping" the room for magical essence.
        function archMagePing() {
            if (game.player.class !== 'mage' || game.player.level < 30) return;
            
            const room = game.currentRoom;
            if (room.type === 'treasure' || room.isSecret) {
                speak("You sense a powerful concentration of mana hidden in the corners of this room.");
            } else if (room.type === 'enemy') {
                speak(`You sense the lifeforce of a ${room.enemy.name}. It is ${room.enemy.health > 5000 ? 'overwhelming' : 'manageable'}.`);
            } else {
                speak("The room is magically inert.");
            }
        }

        // --- COMMAND ROUTING EXTENSION ---
        // Add "ping" or "sense" to her mage commands
        // if (cmd.includes("ping") || cmd.includes("sense mana")) archMagePing();
        // --- THE INFINITE ANCHOR: MEMORY MANAGEMENT ---
        // Prevents the "Infinite Dungeon" from slowing down the browser after 100+ floors.
        function purgeOldDungeonData() {
            // We keep only the current floor's grid to save memory
            const currentFloorKey = `${game.player.position.x},${game.player.position.y}`;
            const currentRoom = game.dungeon.grid[currentFloorKey];
            
            // Clear the grid and re-insert only the current location
            game.dungeon.grid = {};
            game.dungeon.grid[currentFloorKey] = currentRoom;
            
            log("Dungeon memory stabilized for deep-dive performance.");
        }

        // --- MASTER SAVE ENCRYPTION (Data Integrity) ---
        // Ensures her Arch-Mage save is resilient and cannot be corrupted by half-writes.
        function secureSave() {
            const saveSlot = "ARCHMAGE_LEGACY";
            const payload = {
                version: "11.0",
                timestamp: Date.now(),
                player: game.player,
                dungeonLevel: game.dungeon.currentLevel,
                seed: game.seed,
                stats: game.player.stats
            };

            try {
                const serialized = JSON.stringify(payload);
                // Simple checksum to verify data integrity on load
                const checksum = serialized.length; 
                localStorage.setItem(`echo_save_${saveSlot}`, serialized);
                localStorage.setItem(`echo_check_${saveSlot}`, checksum.toString());
                
                log(`Save secured at Floor ${game.dungeon.currentLevel}.`);
            } catch (e) {
                speak("The dungeon's memory is full. I could not save your progress.");
            }
        }

        // --- THE "ECHO ANNIVERSARY" (Legacy Recognition) ---
        // Every 50 floors, the game pauses to celebrate her mastery.
        function checkAnniversary() {
            const floor = game.dungeon.currentLevel;
            if (floor > 0 && floor % 50 === 0) {
                speakSequence([
                    "The walls of the dungeon turn to pure obsidian.",
                    "The air is filled with the scent of ancient incense.",
                    `Arch-Mage, you have descended ${floor} levels into the heart of the world.`,
                    "You have become more than a player; you are the Sovereign of the Echo.",
                    "Your Max Mana has been increased by 500 as a tribute to your persistence."
                ]);
                game.player.maxMana += 500;
                game.player.mana = game.player.maxMana;
            }
        }

        // --- FINAL GLOBAL BOOTSTRAP ---
        // This function ties every single one of the 35 parts together.
        function initializeEchoDungeonV11() {
            // Set the "Void" interface
            clearDisplay(); 
            
            // Welcome sequence
            speakSequence([
                "Echo Dungeon, Version 11.",
                "The Infinite Odyssey.",
                "Tap anywhere to begin your descent."
            ]);

            // Set up the tap listener for the invisible full-screen button
            const btn = document.getElementById('micButton');
            btn.addEventListener('click', () => {
                if (!game.active) {
                    game.active = true;
                    // If she has a save, it will auto-load "ARCHMAGE_LEGACY" 
                    // otherwise it starts the class selection.
                    loadGame("ARCHMAGE_LEGACY"); 
                } else {
                    toggleListening();
                }
            });

            // Start the vitals monitor
            setInterval(checkVitalsWarning, 10000); // Check every 10 seconds
            setInterval(autoSave, 60000); // Auto-save every minute
        }

        // --- THE "INFINITY" TRIGGER ---
        // Call this when she moves to a new floor.
        function nextFloor() {
            checkAnniversary();
            purgeOldDungeonData(); // Keep it lean
            generateInfiniteFloor();
            secureSave(); // Checkpoint
        }

        // Initialize the game on window load
        window.onload = initializeEchoDungeonV11;
        // --- FINAL CONTEXTUAL OVERRIDE ---
        // Ensuring no stray text or visuals remain.
        document.title = "Echo Dungeon V11";
        console.log("Echo Dungeon V11: Infinite Arch-Mage Edition Initialized.");
        
        // This closes the master script block
    </script><script>
    // --- FORCE START OVERRIDE ---
    (function() {
        console.log("Attempting emergency engine start...");
        
        // 1. Force the UI to exist regardless of previous errors
        document.body.style.backgroundColor = "black";
        document.body.innerHTML = `
            <button id="FINAL_MIC_BUTTON" style="position:fixed; top:0; left:0; width:100vw; height:100vh; background:black; border:none; outline:none; cursor:pointer;">
            </button>
        `;

        // 2. Define a clean Speak function if the others are broken
        const emergencySpeak = (text) => {
            console.log("Dungeon says: " + text);
            const msg = new SpeechSynthesisUtterance(text);
            msg.rate = 0.9;
            window.speechSynthesis.speak(msg);
        };

        // 3. Link the Button
        const btn = document.getElementById('FINAL_MIC_BUTTON');
        btn.onclick = function() {
            // Visual feedback for you (since you are testing)
            btn.style.backgroundColor = "#001100"; 
            setTimeout(() => { btn.style.backgroundColor = "black"; }, 200);

            if (typeof toggleListening === 'function') {
                toggleListening();
            } else if (typeof startSpeechRecognition === 'function') {
                startSpeechRecognition();
            } else {
                emergencySpeak("The speech engine is not connected. Check the script order.");
            }
        };

        // 4. Force Initial Greeting
        setTimeout(() => {
            emergencySpeak("System override successful. Echo Dungeon V11 is active. Tap to begin.");
        }, 1000);
    })();
</script>
</body>
</html>
<script>
    // --- EMERGENCY REPAIR BLOCK ---
    // This fixes "micButton already declared" and "handleClick undefined"
    
    (function fixGame() {
        // 1. Force the UI to exist
        document.body.innerHTML = '<button id="mainVoidButton" style="position:fixed; top:0; left:0; width:100vw; height:100vh; background:black; border:none; outline:none; cursor:pointer;"></button>';
        
        const theBigButton = document.getElementById('mainVoidButton');

        // 2. Define the missing function link
        window.toggleListening = function() {
            if (typeof recognition !== 'undefined' && recognition && recognition.active) {
                recognition.stop();
                speak("Listening stopped.");
            } else {
                if (typeof startSpeechRecognition === 'function') {
                    startSpeechRecognition();
                } else {
                    console.error("Speech engine missing.");
                }
            }
        };

        // 3. Attach the event to our new button
        theBigButton.onclick = function() {
            window.toggleListening();
        };

        // 4. Start the game sequence
        if (typeof initializeGame === 'function') {
            initializeGame();
        } else if (typeof startGame === 'function') {
            startGame();
        }
        
        console.log("Emergency Fix Applied: Game should now respond to taps.");
    })();
</script>

